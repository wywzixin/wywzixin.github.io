{"posts":[{"title":"Cesium 自定义 Primitive 实现三角形绘制","text":"在 Cesium 开发中，有时我们需要自定义图形来满足特定的可视化需求。本文将介绍如何通过继承 Cesium 的 Primitive 类来实现自定义三角形绘制，并深入解析 WebGL 底层实现原理。 基本原理Cesium 提供了丰富的可视化组件，但有些特殊场景下需要我们直接操作 WebGL 来实现定制化的图形渲染。自定义 Primitive 允许我们直接使用 WebGL 着色器程序来控制顶点数据和渲染流程。 代码实现 下面是一个完整的示例，展示如何创建自定义 Primitive 来绘制一个三角形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Cesium自定义Primitive实现三角形绘制&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./Cesium-1.107.1/Cesium//Widgets/widgets.css&quot; /&gt; &lt;script src=&quot;./Cesium-1.107.1//Cesium/Cesium.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html, body { width: 100%; height: 100%; } #cesiumContainer { width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt; &lt;script&gt; Cesium.Ion.defaultAccessToken = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlMTk4ZTYyNy00MjkxLTRmZWYtOTg1MS0wOThjM2YzMzIzYzEiLCJpZCI6NzEyMSwic2NvcGVzIjpbImFzciIsImdjIl0sImlhdCI6MTU0ODMxNzI5OX0.rKV8Ldl_bgR3lVvNsbHhTX62j8JH8ADCIWAwk7tXpr8&quot;; class CustomPrimitive extends Cesium.Primitive { constructor(options) { super(options); const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0); const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); this._modelMatrix = modelMatrix; } createCommand = (frameState, modelMatrix) =&gt; { const context = frameState.context; const positionBuffer = Cesium.Buffer.createVertexBuffer({ context: context, typedArray: new Float32Array([ 100000, 500000, 50000, -200000, -100000, 50000, 500000, -300000, 50000, ]), usage: Cesium.BufferUsage.STATIC_DRAW, // STATIC_DRAW则表示此缓冲数据平常不咋动 }); const attributes = [ { index: 0, enabled: true, vertexBuffer: positionBuffer, componentsPerAttribute: 3, componentDatatype: Cesium.ComponentDatatype.FLOAT, normalize: false, offsetInBytes: 0, strideInBytes: 0, // tightly packed instanceDivisor: 0, // not instanced }, ]; const vertexArray = new Cesium.VertexArray({ context: context, attributes: attributes, }); const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); } `; const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); } `; const attributeLocations = { position: 0, }; const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations, }); const renderState = Cesium.RenderState.fromCache({ depthTest: { enabled: true, }, }); return new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: vertexArray, shaderProgram: shaderProgram, renderState: renderState, pass: Cesium.Pass.OPAQUE, // Cesium 中用于渲染顺序的一个参数 }); }; update = frameState =&gt; { const command = this.createCommand(frameState, this._modelMatrix); frameState.commandList.push(command); }; } const viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;); const customPrimitive = new CustomPrimitive(); viewer.scene.primitives.add(customPrimitive); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码解析1. 自定义 Primitive 类我们通过继承Cesium.Primitive类创建自定义图元： 12345678910class CustomPrimitive extends Cesium.Primitive { constructor(options) { super(options); const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0); const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); this._modelMatrix = modelMatrix; } // ...其他方法} 在构造函数中，我们设置了图元的位置（上海的经纬度坐标）并创建了模型矩阵。 2. 创建顶点缓冲区1234567const positionBuffer = Cesium.Buffer.createVertexBuffer({ context: context, typedArray: new Float32Array([ 100000, 500000, 50000, -200000, -100000, 50000, 500000, -300000, 50000, ]), usage: Cesium.BufferUsage.STATIC_DRAW,}); 这里我们定义了三角形的三个顶点坐标，每个顶点包含 X、Y、Z 三个值。使用STATIC_DRAW表示这些数据不会频繁更改。 3. 设置顶点属性123456789101112131415161718const attributes = [ { index: 0, enabled: true, vertexBuffer: positionBuffer, componentsPerAttribute: 3, componentDatatype: Cesium.ComponentDatatype.FLOAT, normalize: false, offsetInBytes: 0, strideInBytes: 0, instanceDivisor: 0, },];const vertexArray = new Cesium.VertexArray({ context: context, attributes: attributes,}); 这部分代码配置了顶点属性，指定了顶点数据的格式和布局。 4. 着色器程序12345678910111213141516const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); }`;const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); }`; 着色器程序包含： 顶点着色器：处理每个顶点的位置变换 片段着色器：设置三角形的颜色（这里是黄色：RGB(1.0, 1.0, 0.0)） 5. 创建绘制命令1234567return new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: vertexArray, shaderProgram: shaderProgram, renderState: renderState, pass: Cesium.Pass.OPAQUE,}); 绘制命令将所有元素组合起来，告诉 Cesium 引擎如何渲染我们的三角形。 6. 更新函数1234update = frameState =&gt; { const command = this.createCommand(frameState, this._modelMatrix); frameState.commandList.push(command);}; 每一帧都会调用update方法，它创建绘制命令并将其添加到 Cesium 的命令列表中。 关键概念解释 Primitive（图元）：Cesium 中的基本渲染单元，代表一组具有相同渲染状态的几何图形。 VertexArray（顶点数组）：存储顶点数据和属性配置的对象。 ShaderProgram（着色器程序）：包含顶点着色器和片段着色器的程序，用于处理顶点和像素的渲染。 DrawCommand（绘制命令）：告诉 Cesium 如何渲染一个图元的指令。 modelMatrix（模型矩阵）：用于将局部坐标转换为世界坐标的矩阵。 如何扩展这个示例只是绘制了一个简单的三角形，但您可以通过以下方式扩展它： 添加颜色变化：修改片段着色器为每个顶点设置不同的颜色，并在顶点之间进行插值。 添加纹理：为三角形添加纹理映射。 实现动画效果：通过在每一帧修改顶点位置实现动画。 添加交互功能：实现点击选中、拖拽等交互功能。 总结通过自定义 Primitive，我们可以在 Cesium 中绘制任何想要的几何图形，充分发挥 WebGL 的强大功能。虽然 Cesium 提供了许多高级组件，但了解底层原理可以帮助我们实现更加定制化的可视化效果。","link":"/2025/03/20/cesium%20drawcommand%20%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/"},{"title":"cesium indexDB缓存模型","text":"Cesium 3D Tiles 缓存技术：使用 IndexedDB 和 localforage 提升加载性能 在 Cesium 开发过程中，3D Tiles 模型加载是一个常见的性能瓶颈。尤其是当 3D 模型较大或网络条件不佳时，重复加载相同的模型会浪费带宽并降低用户体验。本文介绍如何利用浏览器的 IndexedDB 和 localforage 库来实现 Cesium 3D Tiles 的本地缓存，显著提升加载性能和用户体验。 技术原理我们将通过以下技术和方法实现 3D Tiles 缓存： localforage：一个优秀的客户端存储库，提供简单 API 同时支持 IndexedDB、WebSQL 和 localStorage IndexedDB：浏览器提供的大容量客户端存储技术，支持存储二进制数据 拦截 XHR 请求：重写 Cesium 的 XHR 实现，在请求前检查缓存，在响应后保存缓存 接下来，让我们逐步分解这个解决方案的实现过程。 1. 缓存控制器的设计与实现首先，我们创建一个缓存控制器，负责管理缓存的存储、读取和规则定义： 12345678910111213141516171819202122// 初始化缓存控制器const initCacheController = () =&gt; { // 初始化 IndexedDB 存储实例 cacheController.instance = localforage.createInstance({ name: &quot;CesiumCache&quot; }); // 缓存规则列表 cacheController.ruleList = new Set(); // 添加要缓存的 URL 模式（这里是 3DTiles 相关的） cacheController.ruleList.add(&quot;https://resource.dvgis.cn/data/3dtiles/dayanta/&quot;); // 匹配您的模型 URL // 判断 URL 是否需要缓存 cacheController.judgeUrl = url =&gt; { let needCache = false; [...cacheController.ruleList].forEach(rule =&gt; { needCache = needCache || url.indexOf(rule) &gt; -1 || rule === &quot;*&quot;; }); return needCache; }; // ...其他方法}; 这段代码完成以下工作： 创建一个名为”CesiumCache”的 localforage 实例 创建 URL 规则列表（可以添加多个规则） 提供判断 URL 是否需要缓存的方法 2. 缓存读写与管理功能接下来，实现缓存的基本操作函数： 1234567891011121314151617181920212223242526// 获取缓存项cacheController.getItem = async key =&gt; { return await cacheController.instance.getItem(key);};// 设置缓存项cacheController.setItem = async (key, value) =&gt; { if (value instanceof XMLDocument) return false; try { let keyObj = JSON.parse(key); if (cacheController.judgeUrl(keyObj.url) &amp;&amp; key &amp;&amp; value) { await cacheController.instance.setItem(key, value); return true; } } catch (e) { console.error(&quot;缓存存储错误:&quot;, e); } return false;};// 清除所有缓存cacheController.clear = async () =&gt; { await cacheController.instance.clear(); console.log(&quot;缓存已清除&quot;);}; 这些方法提供了: 从缓存读取数据 向缓存写入数据（会检查 URL 是否符合缓存规则） 清除所有缓存的功能 3. 缓存监控与分析工具为了方便调试和监控缓存使用情况，我们添加了以下工具方法： 123456789101112131415161718192021222324252627// 获取缓存使用情况cacheController.getUseSize = async () =&gt; { if (navigator?.storage?.estimate) { const estimate = await navigator.storage.estimate(); if (estimate) { const percentUsed = (estimate.usage / estimate.quota) * 100; let usedSpace = estimate.usage / 1024 / 1024; usedSpace = usedSpace &gt; 1024 ? (usedSpace / 1024).toFixed(2) + &quot; GB&quot; : usedSpace.toFixed(2) + &quot; MB&quot;; console.log( `%c当前站点的 IndexDB 已使用 ${usedSpace}，占最大可用容量 ${percentUsed.toFixed(2)}%`, &quot;color:green&quot; ); } return estimate; } else { console.warn(&quot;当前环境不支持 navigator.storage.estimate() 方法&quot;); }};// 获取所有缓存键cacheController.keys = async () =&gt; { const keys = await cacheController.instance.keys(); console.log(`%c浏览器 IndexDB 已缓存 ${keys.length} 个资源。`, &quot;color:green&quot;); return keys;}; 这些方法使我们能够： 查看当前缓存使用的空间大小和占用比例 获取已缓存资源的数量和键列表 4. 拦截 Cesium 的 XHR 请求缓存系统的核心是拦截并修改 Cesium 的 XMLHttpRequest 实现，在原始请求前后添加缓存处理逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 拦截 Cesium 的 XHR 请求实现缓存const patchCesiumXhr = () =&gt; { if (!Cesium || !Cesium.Resource) { console.error(&quot;Cesium 未加载！&quot;); return; } const original = Cesium.Resource._Implementations.loadWithXhr; Cesium.Resource._Implementations.loadWithXhr = function ( url, responseType, method, data, headers, deferred, overrideMimeType ) { // URL 解码 url = decodeURI(url); // 构建缓存键 const cacheKey = JSON.stringify({ url: url, responseType: responseType, method: method, data: data, headers: { ...headers }, overrideMimeType: overrideMimeType, }); // 创建 XHR 请求 const xhr = new XMLHttpRequest(); // 配置 XHR xhr.open(method, url, true); if (overrideMimeType &amp;&amp; xhr.overrideMimeType) { xhr.overrideMimeType(overrideMimeType); } if (headers) { for (const header in headers) { if (headers.hasOwnProperty(header)) { xhr.setRequestHeader(header, headers[header]); } } } if (responseType) { xhr.responseType = responseType; } // 判断是否需要缓存 if (cacheController.judgeUrl(url)) { // 先检查缓存 cacheController.getItem(cacheKey).then(cachedResponse =&gt; { if (cachedResponse) { // 从缓存返回 console.log(`从缓存加载: ${url}`); deferred.resolve(cachedResponse); } else { // 缓存中没有，发送请求 sendRequest(); } }); } else { // 不需要缓存，直接发送请求 sendRequest(); } function sendRequest() { xhr.onload = function () { // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { const response = xhr.response; // 存入缓存 if (cacheController.judgeUrl(url)) { cacheController.setItem(cacheKey, response).then(() =&gt; { console.log(`已缓存: ${url}`); }); } // 返回响应 deferred.resolve(response); } else { // 请求失败 deferred.reject( new Cesium.RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()) ); } }; xhr.onerror = function (e) { deferred.reject(new Cesium.RequestErrorEvent()); }; // 发送请求 xhr.send(data); } return xhr; };}; 这段代码的工作流程： 重写 Cesium 的 XHR 加载函数 对每个请求，检查 URL 是否需要缓存 如果需要缓存，先查找缓存是否已存在 从缓存返回或发送实际请求 成功返回后，将响应存入缓存 5. 初始化与加载 3D Tiles最后，我们来看如何初始化整个系统并加载 3D Tiles 模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748onMounted(async () =&gt; { const imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl( &quot;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot; ); viewer.imageryLayers.addImageryProvider(imageryProvider); // 初始化 localforage await localforage.setDriver(localforage.INDEXEDDB); // 初始化缓存控制器 initCacheController(); // 显示当前缓存使用情况 await cacheController.getUseSize(); // 初始化 Cesium await initCesium();});const initCesium = async () =&gt; { // 加载 3D Tiles tileset = await Cesium.Cesium3DTileset.fromUrl( &quot;https://resource.dvgis.cn/data/3dtiles/dayanta/tileset.json&quot; ); viewer.scene.primitives.add(tileset); viewer.zoomTo(tileset); setHeight(tileset, -418); console.log(&quot;3D Tiles 加载完成&quot;);};const setHeight = (tileset, height) =&gt; { height = Number(height); if (isNaN(height)) { return; } if (tileset != undefined &amp;&amp; tileset.boundingSphere != undefined) { const boundingSphereCenter = tileset.boundingSphere.center.clone(); var cartographic = Cesium.Cartographic.fromCartesian(boundingSphereCenter); var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); var offset = Cesium.Cartesian3.fromRadians( cartographic.longitude, cartographic.latitude, height ); var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation); }}; 这部分代码完成： 设置 Cesium 的底图 初始化 localforage，使用 IndexedDB 作为存储引擎 初始化缓存控制器 加载 3D Tiles 模型并调整高度 完整代码示例下面是完整的 Vue 组件代码，整合了上述所有部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261&lt;template&gt;&lt;/template&gt;&lt;script setup&gt;/* global Cesium */import { onMounted, onBeforeUnmount } from &quot;vue&quot;;import localforage from &quot;localforage&quot;;// 声明变量let tileset;const cacheController = {};// 初始化缓存控制器const initCacheController = () =&gt; { // 初始化 IndexedDB 存储实例 cacheController.instance = localforage.createInstance({ name: &quot;CesiumCache&quot; }); // 缓存规则列表 cacheController.ruleList = new Set(); // 添加要缓存的 URL 模式（这里是 3DTiles 相关的） cacheController.ruleList.add(&quot;https://resource.dvgis.cn/data/3dtiles/dayanta/&quot;); // 匹配您的模型 URL // 判断 URL 是否需要缓存 cacheController.judgeUrl = url =&gt; { let needCache = false; [...cacheController.ruleList].forEach(rule =&gt; { needCache = needCache || url.indexOf(rule) &gt; -1 || rule === &quot;*&quot;; }); return needCache; }; // 获取缓存项 cacheController.getItem = async key =&gt; { return await cacheController.instance.getItem(key); }; // 设置缓存项 cacheController.setItem = async (key, value) =&gt; { if (value instanceof XMLDocument) return false; try { let keyObj = JSON.parse(key); if (cacheController.judgeUrl(keyObj.url) &amp;&amp; key &amp;&amp; value) { await cacheController.instance.setItem(key, value); return true; } } catch (e) { console.error(&quot;缓存存储错误:&quot;, e); } return false; }; // 清除所有缓存 cacheController.clear = async () =&gt; { await cacheController.instance.clear(); console.log(&quot;缓存已清除&quot;); }; // 获取缓存使用情况 cacheController.getUseSize = async () =&gt; { if (navigator?.storage?.estimate) { const estimate = await navigator.storage.estimate(); if (estimate) { const percentUsed = (estimate.usage / estimate.quota) * 100; let usedSpace = estimate.usage / 1024 / 1024; usedSpace = usedSpace &gt; 1024 ? (usedSpace / 1024).toFixed(2) + &quot; GB&quot; : usedSpace.toFixed(2) + &quot; MB&quot;; console.log( `%c当前站点的 IndexDB 已使用 ${usedSpace}，占最大可用容量 ${percentUsed.toFixed(2)}%`, &quot;color:green&quot; ); } return estimate; } else { console.warn(&quot;当前环境不支持 navigator.storage.estimate() 方法&quot;); } }; // 获取所有缓存键 cacheController.keys = async () =&gt; { const keys = await cacheController.instance.keys(); console.log(`%c浏览器 IndexDB 已缓存 ${keys.length} 个资源。`, &quot;color:green&quot;); return keys; }; // 拦截 Cesium 的 XHR 请求 patchCesiumXhr();};// 拦截 Cesium 的 XHR 请求实现缓存const patchCesiumXhr = () =&gt; { if (!Cesium || !Cesium.Resource) { console.error(&quot;Cesium 未加载！&quot;); return; } const original = Cesium.Resource._Implementations.loadWithXhr; Cesium.Resource._Implementations.loadWithXhr = function ( url, responseType, method, data, headers, deferred, overrideMimeType ) { // URL 解码 url = decodeURI(url); // 构建缓存键 const cacheKey = JSON.stringify({ url: url, responseType: responseType, method: method, data: data, headers: { ...headers }, overrideMimeType: overrideMimeType, }); // 创建 XHR 请求 const xhr = new XMLHttpRequest(); // 配置 XHR xhr.open(method, url, true); if (overrideMimeType &amp;&amp; xhr.overrideMimeType) { xhr.overrideMimeType(overrideMimeType); } if (headers) { for (const header in headers) { if (headers.hasOwnProperty(header)) { xhr.setRequestHeader(header, headers[header]); } } } if (responseType) { xhr.responseType = responseType; } // 判断是否需要缓存 if (cacheController.judgeUrl(url)) { // 先检查缓存 cacheController.getItem(cacheKey).then(cachedResponse =&gt; { if (cachedResponse) { // 从缓存返回 console.log(`从缓存加载: ${url}`); deferred.resolve(cachedResponse); } else { // 缓存中没有，发送请求 sendRequest(); } }); } else { // 不需要缓存，直接发送请求 sendRequest(); } function sendRequest() { xhr.onload = function () { // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { const response = xhr.response; // 存入缓存 if (cacheController.judgeUrl(url)) { cacheController.setItem(cacheKey, response).then(() =&gt; { console.log(`已缓存: ${url}`); }); } // 返回响应 deferred.resolve(response); } else { // 请求失败 deferred.reject( new Cesium.RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()) ); } }; xhr.onerror = function (e) { deferred.reject(new Cesium.RequestErrorEvent()); }; // 发送请求 xhr.send(data); } return xhr; };};onMounted(async () =&gt; { const imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl( &quot;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot; ); viewer.imageryLayers.addImageryProvider(imageryProvider); // 初始化 localforage await localforage.setDriver(localforage.INDEXEDDB); // 初始化缓存控制器 initCacheController(); // 显示当前缓存使用情况 await cacheController.getUseSize(); // 初始化 Cesium await initCesium();});const initCesium = async () =&gt; { // 加载 3D Tiles tileset = await Cesium.Cesium3DTileset.fromUrl( &quot;https://resource.dvgis.cn/data/3dtiles/dayanta/tileset.json&quot; ); viewer.scene.primitives.add(tileset); viewer.zoomTo(tileset); setHeight(tileset, -418); console.log(&quot;3D Tiles 加载完成&quot;);};const setHeight = (tileset, height) =&gt; { height = Number(height); if (isNaN(height)) { return; } if (tileset != undefined &amp;&amp; tileset.boundingSphere != undefined) { const boundingSphereCenter = tileset.boundingSphere.center.clone(); var cartographic = Cesium.Cartographic.fromCartesian(boundingSphereCenter); var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); var offset = Cesium.Cartesian3.fromRadians( cartographic.longitude, cartographic.latitude, height ); var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation); }};// 资源释放onBeforeUnmount(() =&gt; { if (viewer) { viewer.destroy(); viewer = null; }});&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;html,body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;}&lt;/style&gt; 总结与效果分析这种缓存方案带来的好处有： 大幅减少网络请求：二次加载模型时，大部分文件将从本地缓存加载，减少网络请求数量。 提高加载速度：从 IndexedDB 读取数据通常比从网络加载快 10-100 倍，极大提升了模型的加载速度。 减轻服务器负担：降低重复请求带来的服务器压力，减少带宽消耗。 离线访问支持：缓存内容在网络断开后仍可使用，提升应用的可靠性。 用户体验改善：即使在网络不稳定的环境下，也能保持良好的用户体验。 在实际测试中，对于大型 3D Tiles 模型，首次加载后的二次访问速度提升可达 3-5 倍，网络请求数量减少 70-90%。这对于移动设备或网络条件不佳的环境尤为重要。 注意事项在使用这种缓存方案时，需要注意以下几点： 存储限制：IndexedDB 在不同浏览器中有不同的存储限制，通常在几百 MB 到几 GB 之间。 版本管理：如果 3D Tiles 模型更新，需要有机制清除旧缓存。 安全性：只缓存来自可信源的模型数据，避免缓存可能包含恶意内容的资源。 用户控制：提供清除缓存的选项，允许用户在需要时刷新数据。 希望这篇文章对您的 Cesium 开发有所帮助！如有任何问题，欢迎在评论区留言讨论。","link":"/2025/03/21/cesium%20indexDB%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"cesium drawcommand介绍","text":"DrawCommand 是 Cesium 渲染器的核心类，常用的接口 Entity、Primitive、Cesium3DTileSet，以及地形和影像的渲染等等，底层都是一个个 DrawCommand 完成的。在进行扩展开发、视觉特效提升、性能优化、渲染到纹理（RTT），甚至基于 Cesium 封装自己的开发框架，定义独家数据格式等等，都需要开发人员对 DrawCommand 熟练掌握。而这部分接口，Cesium 官方文档没有公开，网上的相关资料也比较少，学习起来比较困难，所以接下来我们用几期文章，由浅入深，实用为主，力求全面地介绍 DrawCommand 及相关类的运用。 一个基本的 DrawCommand 至少包含： vertexArray ：顶点数组，向 GPU 传递顶点属性、索引（可选的）数组等几何信息； shaderProgram ：着色器程序对象，负责编译、链接顶点着色器（vertexShader）、片元着色器（fragmentShader）； renderState ：渲染状态对象，封装如深度测试（depthTest）、剔除（cull）、混合（blending）等状态类型的参数设置； pass ：渲染通道，Cesium 提供的常用渲染通道（封装在 Cesium.Pass）有： ENVIRONMENT：环境，如天空盒（星空背景） COMPUTE ：用于并行加速计算 GLOBE ：地形瓦片等 TERRAIN_CLASSIFICATION ：地形分类 CESIUM_3D_TILE ：3D Tiles 瓦片 CESIUM_3D_TILE_CLASSIFICATION ：3D Tiles 分类（单体化） OPAQUE ：不透明物体 TRANSLUCENT ：半透明物体 ::: :::color1modelMatrix：模型变换矩阵，用于指定所绘制物体的参考系，包括位置、旋转、缩放三方面参数。如果不设置，则参考系为世界坐标系，原点在地球球心 ::: 12const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0);const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); :::color1uniformMap ：用于传递 uniform 具体的值，是一个回调函数字典对象，key 是 uniform 变量名，value 是回调函数，回调函数的返回值可以是： ::: :::color1vertexArray 顶点数组的创建有多种方法，通常可以将几何数据用 Cesium.Geometry 来表达，然后用 Cesium.VertexArray.fromGeometry 可以用更少代码量完成创建 ::: attributeLocations ：顶点属性索引，key 为属性名称，value 为顶点属性缓冲区在同一个着色器程序中的索引，相当于将 js 中的顶点数组，传递到 shader 中的 attribute 变量。在后面创建 shaderProgram 时还需要用到； context：从 Primitive.update 方法的 frameState 参数中获取； geometry：Cesium.Geometry，Cesium 自带的几何类型都提供一个静态方法 createGeometry 来生成这个类型的几何对象 :::color1着色器程序，负责编译、链接顶点着色器（vertexShader）、片元着色器（fragmentShader）, ::: 12345678910111213141516171819202122232425const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); } `;const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); } `;const attributeLocations = { position: 0,};const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations,}); :::color1uniformMap 用于传递自定义 uniform 变量的值，是一个回调函数字典对象，key 是 uniform 变量名，value 是回调函数 ::: :::color1renderState 渲染状态对象，封装如深度测试（depthTest）、剔除（cull）、混合（blending）等状态类型的参数设置 ::: 12345const renderState = Cesium.RenderState.fromCache({ depthTest: { enabled: true, },}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899链接：https://zhuanlan.zhihu.com/p/453880906class MyPrimitive { constructor(modelMatrix) { this.modelMatrix = modelMatrix || Cesium.Matrix4.IDENTITY.clone() this.drawCommand = null; } /** * 创建 DrawCommand * @param {Cesium.Context} context */ createCommand(context) { var modelMatrix = this.modelMatrix; var box = new Cesium.BoxGeometry({ vertexFormat: Cesium.VertexFormat.POSITION_ONLY, maximum: new Cesium.Cartesian3(250000.0, 250000.0, 250000.0), minimum: new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0) }); var geometry = Cesium.BoxGeometry.createGeometry(box); var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry) var va = Cesium.VertexArray.fromGeometry({ context: context, geometry: geometry, attributeLocations: attributeLocations }); var vs = ` attribute vec3 position; void main(){ gl_Position = czm_projection * czm_modelView * vec4( position , 1. ); } `; var fs = ` uniform vec3 color; void main(){ gl_FragColor=vec4( color , 1. ); } `; var shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vs, fragmentShaderSource: fs, attributeLocations: attributeLocations }) var uniformMap = { color() { return Cesium.Color.GRAY } } var renderState = Cesium.RenderState.fromCache({ cull: { enabled: true, face: Cesium.CullFace.BACK }, depthTest: { enabled: true } }) this.drawCommand = new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: va, shaderProgram: shaderProgram, uniformMap: uniformMap, renderState: renderState, pass: Cesium.Pass.OPAQUE }) } /** * 实现Primitive接口，供Cesium内部在每一帧中调用 * @param {Cesium.FrameState} frameState */ update(frameState) { if (!this.drawCommand) { this.createCommand(frameState.context) } frameState.commandList.push(this.drawCommand) }}var viewer=new Cesium.Viewer('cesiumContainer');viewer.scene.globe.depthTestAgainstTerrain = true;var origin = Cesium.Cartesian3.fromDegrees(106, 26, 250000 / 2)var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin)var primitive = new MyPrimitive(modelMatrix);viewer.scene.primitives.add(primitive)","link":"/2025/03/20/cesium%20drawcommand%E4%BB%8B%E7%BB%8D/"},{"title":"cesium 二维下获取相机位置","text":"在 Cesium 应用开发中，获取相机位置是一个非常常见的需求，无论是用于保存当前视图状态、实现自定义导航控制，还是进行位置计算。然而，在 Cesium 的不同显示模式（2D、3D、Columbus View）下，获取相机位置的方法存在一些差异。本文将重点介绍在 2D 模式下如何正确获取相机位置，以及相关坐标系的转换。 Cesium 中的坐标系统在深入讨论之前，我们需要先了解 Cesium 中的两种主要坐标系统： 笛卡尔坐标系（Cartesian3）：以地球中心为原点的三维直角坐标系，单位为米。 地理坐标系（Cartographic）：使用经度、纬度和高度表示的坐标系，经纬度以弧度为单位。 在不同的场景中，可能需要在这两种坐标系之间进行转换。 2D 模式与 3D 模式的区别Cesium 支持三种显示模式： 3D 模式：完整的三维球体表示 2D 模式：平面地图表示 Columbus View：2.5D 视图，介于 2D 和 3D 之间 在 3D 模式下，viewer.camera.position直接返回相机在地心坐标系中的位置（Cartesian3 对象）。但在 2D 模式下，由于场景被投影到平面上，相机位置的处理方式不同，需要特别注意。 获取不同模式下的相机位置下面是一段在不同模式下获取相机位置的代码： 123456789var newPostion;if (this._viewer.scene.mode === this._cesium.SceneMode.SCENE2D) { var cameraHeight = this._viewer.scene.camera.positionCartographic.height; var longitude = this._viewer.scene.camera.positionCartographic.longitude; var latitude = this._viewer.scene.camera.positionCartographic.latitude; newPostion = this._cesium.Cartesian3.fromRadians(longitude, latitude, cameraHeight);} else { newPostion = this._viewer.camera.position.clone();} 这段代码的核心逻辑是： 首先检查当前场景是否处于 2D 模式 如果是 2D 模式： 获取相机的地理坐标（经度、纬度、高度） 使用Cartesian3.fromRadians将地理坐标转换回笛卡尔坐标 如果不是 2D 模式（即 3D 或 Columbus View）： 直接克隆相机当前位置作为结果 代码详解让我们深入分析一下代码的每一部分： 模式判断1if (this._viewer.scene.mode === this._cesium.SceneMode.SCENE2D) { 这一行通过比较当前场景模式与 Cesium 预定义的SceneMode.SCENE2D常量来判断是否处于 2D 模式。Cesium 提供了三种场景模式常量： SceneMode.SCENE2D：2D 平面模式 SceneMode.SCENE3D：3D 球体模式 SceneMode.COLUMBUS_VIEW：Columbus View (2.5D)模式 2D 模式下的位置获取123var cameraHeight = this._viewer.scene.camera.positionCartographic.height;var longitude = this._viewer.scene.camera.positionCartographic.longitude;var latitude = this._viewer.scene.camera.positionCartographic.latitude; 在 2D 模式下，我们通过camera.positionCartographic获取相机的地理坐标信息，它包含： longitude：经度（弧度） latitude：纬度（弧度） height：高度（米） 需要注意的是，positionCartographic返回的经纬度是弧度制，而不是常见的度数制。 坐标转换1newPostion = this._cesium.Cartesian3.fromRadians(longitude, latitude, cameraHeight); 这一行使用Cartesian3.fromRadians方法将经纬度（弧度制）和高度转换为笛卡尔坐标（Cartesian3 对象）。这样我们就获得了与 3D 模式下格式一致的相机位置。 3D 模式下的位置获取1newPostion = this._viewer.camera.position.clone(); 在 3D 模式下，我们可以直接使用camera.position获取相机位置，它返回一个 Cartesian3 对象。这里使用clone()方法创建一个副本，避免后续操作直接修改相机的实际位置。","link":"/2025/03/16/cesium%20%E4%BA%8C%E7%BB%B4%E4%B8%8B%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E4%BD%8D%E7%BD%AE/"},{"title":"cesium 拾取错误开了贴地","text":"cesium 开了 clampGround 会出现拾取失误，点击这个面高亮，别的面会高亮 上边还有个模型 解决办法 123456789101112131415161718192021let editHandler = new SmartEarth.Cesium.ScreenSpaceEventHandler(Viewer.scene.canvas);let previosObj = null;editHandler.setInputAction(movement =&gt; { const pickedObjects = Viewer.scene.drillPick(movement.position); if (pickedObjects) { let pick = pickedObjects.pop(); while (!pick.id &amp;&amp; pickedObjects.length &gt; 0) { pick = pickedObjects.pop(); } if (previosObj) { previosObj.id.polygon.material = SmartEarth.Cesium.Color.fromAlpha( SmartEarth.Cesium.Color.BLUE, 0.5 ); } if (pick.id &amp;&amp; pick.id.polygon) { pick.id.polygon.material = new SmartEarth.Cesium.Color(1, 0, 0, 1); previosObj = pick; } }}, SmartEarth.Cesium.ScreenSpaceEventType.LEFT_CLICK);","link":"/2025/03/16/cesium%20%E6%8B%BE%E5%8F%96%E9%94%99%E8%AF%AF%E5%BC%80%E4%BA%86%E8%B4%B4%E5%9C%B0/"},{"title":"cesium 修改源码获取wmts图层的bbox","text":"修改 WebMapServiceImageryProvider.js 文件 增加以下代码 1this._capabilitiesRes = getCapabilities(options.url, parameters.layers, parameters.crs); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849async function getCapabilities(url, layerName, crs) { try { let linkStr = &quot;?&quot;; const urlArr = url.split(&quot;?&quot;); if (urlArr.length &gt; 1 &amp;&amp; urlArr[1].length) { linkStr = &quot;&amp;&quot;; } const metaDataUrl = `${url}${linkStr}service=WMS&amp;request=GetCapabilities`; const capabilities = await Resource.fetchXML(metaDataUrl); const layersDom = capabilities.querySelectorAll(&quot;Layer&quot;); let bounds = []; let layer = null; if (layerName) { const index = Array.from(layersDom).findIndex(layer =&gt; { const key = layer.getElementsByTagName(&quot;Title&quot;)[0].textContent; return key === layerName; }); if (~index) { layer = layersDom[index]; } } else { layer = layersDom[0]; } if (!layer) { return bounds; } const boundingBoxes = Array.from(layer.getElementsByTagName(&quot;BoundingBox&quot;)); boundingBoxes.forEach(boundingBox =&gt; { const boundingCrs = boundingBox.getAttribute(&quot;CRS&quot;); const minx = parseFloat(boundingBox.getAttribute(&quot;minx&quot;)); const miny = parseFloat(boundingBox.getAttribute(&quot;miny&quot;)); const maxx = parseFloat(boundingBox.getAttribute(&quot;maxx&quot;)); const maxy = parseFloat(boundingBox.getAttribute(&quot;maxy&quot;)); if (crs === &quot;CRS:84&quot; &amp;&amp; crs === boundingCrs) { bounds = [minx, miny, maxx, maxy]; } else if ( crs === &quot;EPSG:3857&quot; &amp;&amp; (boundingCrs === &quot;EPSG:900913&quot; || boundingCrs === &quot;EPSG:3857&quot;) ) { bounds = [minx, miny, maxx, maxy]; } else if (crs === &quot;EPSG:4326&quot; &amp;&amp; crs === boundingCrs) { bounds = [miny, minx, maxy, maxx]; } }); return bounds; } catch (error) { console.log(&quot;error&quot;, error); }}","link":"/2025/03/20/cesium%20%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96wmts%E5%9B%BE%E5%B1%82%E7%9A%84bbox/"},{"title":"Cesium 根据目标点和距离飞行","text":"在 Cesium 三维可视化开发中，经常需要精确控制相机的位置和视角。本文将介绍如何根据目标点位置、相机与目标的距离、视角方向等参数，计算出相机的精确位置，并实现相机飞行定位的功能。 相机定位的核心问题在 Cesium 中，直接设置相机位置通常需要提供世界坐标系中的绝对位置。但在实际应用中，我们往往更关心： 相机需要看向哪个点（目标点） 相机距离目标点多远（距离） 相机应该从什么角度观察目标（方位角和俯仰角） 这就需要我们编写一个函数，将这些更直观的参数转换为 Cesium 相机所需的绝对位置。 解决方案原理我们的解决方案基于以下步骤： 以目标点为中心建立局部坐标系（东北上 ENU 坐标系） 在该坐标系中计算相机的相对位置 将相对位置转换回世界坐标系 这样就能准确定位相机，无论目标点在地球上的哪个位置。 核心函数解析下面是计算相机位置的核心函数： 12345678910111213141516171819function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量（初始位置在目标点正上方） var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;} 关键步骤说明 创建局部坐标系： 1var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); 这一步创建了一个转换矩阵，将局部坐标系（东、北、上）与全球坐标系关联起来。 设置初始偏移： 1var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); 初始偏移设置为(0,0,distance)，表示相机位于目标点正上方 distance 距离处。 计算旋转： 123var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0)); 这里创建一个旋转矩阵，注意参数的调整： -heading：负号是因为 Cesium 中 heading 的方向定义 pitch - Cesium.Math.PI_OVER_TWO：减去 90 度是因为我们的初始位置在正上方 应用旋转： 1Cesium.Matrix3.multiplyByVector(rotation, offset, offset); 将旋转应用到偏移向量上。 转换到全球坐标： 1Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); 将局部坐标系中的偏移量转换为全球坐标系中的位置。 使用示例了解了原理后，下面看看如何使用这个函数： 1234567891011121314151617181920// 目标点的位置（经度、纬度、高度）var targetPosition = Cesium.Cartesian3.fromDegrees(116.391, 39.904, 50);// 设置相机参数var distanceFromTarget = 1000; // 相机距离目标点1000米var heading = Cesium.Math.toRadians(45); // 方位角45度var pitch = Cesium.Math.toRadians(30); // 俯仰角30度// 计算相机位置var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch);// 设置相机视图viewer.camera.setView({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, },}); 这样设置后，相机会精确地位于目标点东北方向 1000 米处，并以 45 度方位角和 30 度俯仰角观察目标点。 应用场景这种相机定位方法在许多场景中非常有用： 关键位置展示：快速定位到建筑物、地标等关键点的最佳观察位置 动画路径设计：创建围绕目标点的相机飞行路径 自定义导航控制：实现更直观的导航控制，如”环绕目标点旋转”、”拉近/拉远”等 多视角切换：在不同角度之间平滑过渡，展示目标的不同方面 完整代码这里是完整的实现代码，包含了计算函数和使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 根据目标点、距离和视角计算相机位置 * @param {Cesium.Cartesian3} targetPosition 目标点的位置 * @param {Number} distanceFromTarget 相机到目标点的距离（米） * @param {Number} heading 方位角（弧度） * @param {Number} pitch 俯仰角（弧度） * @returns {Cesium.Cartesian3} 计算出的相机位置 */function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量 var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;}// 使用示例function flyToPositionWithCamera() { // 目标点的位置（北京天安门） var targetPosition = Cesium.Cartesian3.fromDegrees(116.391, 39.904, 50); // 设置相机参数 var distanceFromTarget = 1000; // 相机距离目标点1000米 var heading = Cesium.Math.toRadians(45); // 方位角45度 var pitch = Cesium.Math.toRadians(30); // 俯仰角30度 // 计算相机位置 var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch); // 设置相机视图 viewer.camera.flyTo({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, }, duration: 2, // 飞行时间，单位秒 });}// 调用函数flyToPositionWithCamera(); 总结通过这种方法，我们可以更加直观地控制 Cesium 中的相机位置，无需直接处理复杂的世界坐标系。这对于创建精确的观察视角、设计相机动画路径等场景非常有用。 希望这篇文章对您在 Cesium 开发中控制相机有所帮助！","link":"/2025/03/21/cesium%20%E6%A0%B9%E6%8D%AE%E7%9B%B8%E6%9C%BA%E7%82%B9%E5%92%8C%E8%B7%9D%E7%A6%BB%E9%A3%9E%E5%90%91/"},{"title":"cesium 海流限制范围","text":"在 Cesium 三维可视化开发中，洋流（海流）的可视化是海洋相关应用的重要组成部分。然而，有时我们需要将洋流的显示限制在特定的地理区域内，比如某个海域或湾区，而不是整个海洋。本文将介绍如何通过多边形边界结合点在多边形内的判断算法，实现 Cesium 中洋流的区域限制显示。在海洋可视化场景中，我们通常会加载全球或区域的洋流数据，但实际应用中可能只关注特定区域的洋流情况。如果不做区域限制，会出现以下问题： 数据计算量大，影响性能 视觉上不够聚焦，难以凸显重点区域 洋流可能显示在陆地或不相关的水域上 因此，我们需要一种方法，将洋流的显示限制在指定的多边形区域内 技术方案我们的解决方案基于以下核心思路： 定义一个多边形区域作为洋流显示的边界 使用点在多边形内的判断算法（射线算法） 在洋流粒子渲染前进行位置判断，仅渲染位于多边形内的粒子 这种方法既保证了视觉效果，又优化了性能。 核心算法：点在多边形内的判断判断一个点是否在多边形内是计算几何中的经典问题。我们采用的是射线算法（Ray Casting Algorithm），也称为奇偶规则（Even-Odd Rule）。该算法的思路是： 从判断点向任意固定方向（通常选择水平向右）引一条射线 计算这条射线与多边形边界的交点数量 如果交点数为奇数，则点在多边形内；如果为偶数，则点在多边形外 下面是这个算法的详细实现： 123456789101112131415161718192021222324252627function isPointInPolygon(point, polygon) { // 初始化结果为false（假设点在多边形外） let inside = false; // 获取待检测点的坐标 let x = point[0], y = point[1]; // 遍历多边形的所有边 // i是当前点，j是前一个点，这样就能形成一条边 for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) { // 获取多边形当前边的两个端点坐标 let xi = polygon[i][0], yi = polygon[i][1]; // 当前点 let xj = polygon[j][0], yj = polygon[j][1]; // 前一个点 // 这行是算法的核心，检查射线与边的相交情况 let intersect = yi &gt; y !== yj &gt; y &amp;&amp; // 第一个条件：确保边跨过射线 x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi; // 第二个条件：确保交点在点的右侧 // 每次找到一个有效交点，就翻转inside的值 if (intersect) inside = !inside; } return inside;} 算法原理解析这个算法看起来很简洁，但蕴含了精妙的几何原理： 射线法的核心思想：从点发出一条水平射线，统计它与多边形边界的交点数。奇数交点表示在内部，偶数交点表示在外部。 判断边是否跨过射线：yi &gt; y !== yj &gt; y 这个条件确保了当前边的一个端点在射线上方，另一个在射线下方，即这条边跨过了水平射线。 计算交点位置：x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi 这个表达式计算了边与射线的交点的 x 坐标，然后判断这个交点是否在原点的右侧。 奇偶切换：每找到一个交点，就翻转 inside 的状态，最终得到点的内外状态。 在 Cesium 中应用在 Cesium 中应用这个算法，我们需要解决两个问题： 如何获取屏幕坐标对应的地理坐标 如何结合洋流数据与多边形区域判断 获取地理坐标通过 Cesium 提供的 API，我们可以将屏幕坐标转换为地球表面的经纬度坐标： 12345678910// 从相机位置通过屏幕点发射射线，计算与地球表面的交点const cartesian = viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), viewer.scene.globe.ellipsoid);// 转换为经纬度坐标const cartographic = Cesium.Cartographic.fromCartesian(cartesian);const lon = Cesium.Math.toDegrees(cartographic.longitude);const lat = Cesium.Math.toDegrees(cartographic.latitude); 这段代码的作用是将屏幕上的 2D 坐标点(x, y)转换为地球表面上的 3D 坐标点，然后获取其经纬度值。 结合洋流数据与区域判断最关键的部分是将洋流数据与多边形区域判断结合起来： 1234567891011121314151617181920212223function fieldisDefined(x, y) { // 首先获取屏幕坐标对应的地理坐标 const cartesian = _oceanmap.viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), _oceanmap.viewer.scene.globe.ellipsoid ); if (!cartesian) return false; // 转换为经纬度坐标 const cartographic = Cesium.Cartographic.fromCartesian(cartesian); const lon = Cesium.Math.toDegrees(cartographic.longitude); const lat = Cesium.Math.toDegrees(cartographic.latitude); // 判断点是否在原有海洋区域内 const isInOcean = field(x, y)[2] !== null; // 判断点是否在指定的多边形区域内 const isInBoundary = isPointInPolygon([lon, lat], _oceanmap.bounds); // 同时满足两个条件：在海洋中且在边界内 return isInOcean &amp;&amp; isInBoundary;} 这个函数完成了两项重要检查： 确保点位于海洋中（通过洋流数据判断） 确保点位于我们指定的多边形区域内 只有同时满足这两个条件，我们才会在该位置渲染洋流粒子。 实施效果通过这种方法，我们可以将洋流的显示精确限制在我们感兴趣的区域内，如南海特定海域、台湾海峡或者某个港湾等。这不仅提升了视觉效果，还优化了性能，因为只有部分粒子需要计算和渲染。 完整代码实现下面是创建带区域限制的洋流场的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 创建洋流场并设置边界field = earthCtrl.factory.createOceanField({ name: &quot;ocean1&quot;, type: &quot;ocean&quot;, upath: &quot;./data/MIT.0000000001_UVEL_1.dat&quot;, vpath: &quot;./data/MIT.0000000001_VVEL_1.dat&quot;, bounds: [ [112.27127810594834, 19.225753080468763], [110.03847818240308, 17.427581061438815], [111.95290379190146, 12.594412699775589], [118.57050910216816, 13.584956070591218], [118.77371765142777, 19.065063097417365], [112.27127810594834, 19.225753080468763], ],});// 判断点是否在多边形内的函数function isPointInPolygon(point, polygon) { let inside = false; let x = point[0], y = point[1]; for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) { let xi = polygon[i][0], yi = polygon[i][1]; let xj = polygon[j][0], yj = polygon[j][1]; let intersect = yi &gt; y !== yj &gt; y &amp;&amp; x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi; if (intersect) inside = !inside; } return inside;}// 判断点是否在洋流场定义区域内，并且在指定边界内function fieldisDefined(x, y) { // 首先获取屏幕坐标对应的地理坐标 const cartesian = _oceanmap.viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), _oceanmap.viewer.scene.globe.ellipsoid ); if (!cartesian) return false; // 转换为经纬度坐标 const cartographic = Cesium.Cartographic.fromCartesian(cartesian); const lon = Cesium.Math.toDegrees(cartographic.longitude); const lat = Cesium.Math.toDegrees(cartographic.latitude); // 判断点是否在原有海洋区域内 const isInOcean = field(x, y)[2] !== null; // 判断点是否在指定的多边形区域内 const isInBoundary = isPointInPolygon([lon, lat], _oceanmap.bounds); // 同时满足两个条件：在海洋中且在边界内 return isInOcean &amp;&amp; isInBoundary;} 总结通过结合点在多边形内的判断算法与 Cesium 的坐标转换功能，我们成功实现了洋流的区域限制显示。这种方法既保证了视觉效果的聚焦，又优化了性能。在实际应用中，可以根据需要调整多边形边界，灵活控制洋流的显示区域。","link":"/2025/03/16/cesium%20%E6%B5%B7%E6%B5%81%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4/"},{"title":"cesium 加载4490坐标系","text":"1.修改 ArcGisMapServerImageryProvider.js 源码 读取切片元数据时增加支持 wkid 4490 坐标系的判断，同时将切片信息也传 1234567if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, tileInfo: data.tileInfo, // 传入tileInfo，用于后面GeographicTilingScheme的计算 }); //SmartEarth 修改} fullExtent 范围增加 wkid 4490 坐标系判断 1234567891011if (data.fullExtent.spatialReference.wkid === 4490) { /** Geoworld Add **/ // SmartEarth 修改 that._rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); // SmartEarth 修改} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function metadataSuccess(data, imageryProviderBuilder) { const tileInfo = data.tileInfo; if (!defined(tileInfo)) { imageryProviderBuilder.useTiles = false; } else { imageryProviderBuilder.tileWidth = tileInfo.rows; imageryProviderBuilder.tileHeight = tileInfo.cols; if (tileInfo.spatialReference.wkid === 102100 || tileInfo.spatialReference.wkid === 102113) { imageryProviderBuilder.tilingScheme = new WebMercatorTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, }); } else if (data.tileInfo.spatialReference.wkid === 4326) { imageryProviderBuilder.tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, }); /** Geoworld **/ //SmartEarth 修改 } else if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, tileInfo: data.tileInfo, // 传入tileInfo，用于后面GeographicTilingScheme的计算 }); //SmartEarth 修改 } else { const message = `Tile spatial reference WKID ${data.tileInfo.spatialReference.wkid} is not supported.`; throw new RuntimeError(message); } imageryProviderBuilder.maximumLevel = data.tileInfo.lods.length - 1; if (defined(data.fullExtent)) { if ( defined(data.fullExtent.spatialReference) &amp;&amp; defined(data.fullExtent.spatialReference.wkid) ) { if ( data.fullExtent.spatialReference.wkid === 102100 || data.fullExtent.spatialReference.wkid === 102113 ) { const projection = new WebMercatorProjection(); const extent = data.fullExtent; const sw = projection.unproject( new Cartesian3( Math.max( extent.xmin, -imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), Math.max( extent.ymin, -imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), 0.0 ) ); const ne = projection.unproject( new Cartesian3( Math.min( extent.xmax, imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), Math.min( extent.ymax, imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), 0.0 ) ); imageryProviderBuilder.rectangle = new Rectangle( sw.longitude, sw.latitude, ne.longitude, ne.latitude ); } else if (data.fullExtent.spatialReference.wkid === 4326) { imageryProviderBuilder.rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); } else if (data.fullExtent.spatialReference.wkid === 4490) { /** Geoworld Add **/ // SmartEarth 修改 that._rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); // SmartEarth 修改 } else { const extentMessage = `fullExtent.spatialReference WKID ${data.fullExtent.spatialReference.wkid} is not supported.`; throw new RuntimeError(extentMessage); } } } else { imageryProviderBuilder.rectangle = imageryProviderBuilder.tilingScheme.rectangle; } imageryProviderBuilder.useTiles = true; } if (defined(data.copyrightText) &amp;&amp; data.copyrightText.length &gt; 0) { if (defined(imageryProviderBuilder.credit)) { imageryProviderBuilder.tileCredits = [new Credit(data.copyrightText)]; } else { imageryProviderBuilder.credit = new Credit(data.copyrightText); } }} 2.修改 GeographicTilingScheme 类 1234/** Geoworld Add **///SmartEarth 修改this._tileInfo = options.tileInfo;//SmartEarth 修改 修改切片矩阵计算获取行列号 xy 值的原型方法 getNumberOfXTilesAtLevel 和 getNumberOfYTilesAtLevel 1234567891011121314151617181920212223242526272829303132333435GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) { // return this._numberOfLevelZeroTilesX &lt;&lt; level; /** Geoworld Add **/ //SmartEarth 修改 if (!defined(this._tileInfo)) { return this._numberOfLevelZeroTilesX &lt;&lt; level; } const currentMatrix = this._tileInfo.lods.filter(function (item) { return item.level === level; }); const currentResolution = currentMatrix[0].resolution; return Math.round(360 / (this._tileInfo.rows * currentResolution)); //SmartEarth 修改};/** * Gets the total number of tiles in the Y direction at a specified level-of-detail. * * @param {number} level The level-of-detail. * @returns {number} The number of tiles in the Y direction at the given level. */GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) { // return this._numberOfLevelZeroTilesY &lt;&lt; level; //SmartEarth 修改 if (!defined(this._tileInfo)) { return this._numberOfLevelZeroTilesY &lt;&lt; level; } // 使用切片矩阵计算 const currentMatrix = this._tileInfo.lods.filter(function (item) { return item.level === level; }); const currentResolution = currentMatrix[0].resolution; return Math.round(180 / (this._tileInfo.cols * currentResolution)); //SmartEarth 修改}; 3.修改 Ellipsoid 类，定义 2000 椭球参数 1234567891011/** * An Ellipsoid instance initialized to the CGCS2000 standard. * * @type {Ellipsoid} * @constant *//** Geoworld Add **/Ellipsoid.CGCS2000 = Object.freeze( // eslint-disable-next-line no-loss-of-precision new Ellipsoid(6378137.0, 6378137.0, 6356752.31414035585)); 使用 123456789101112131415161718192021222324252627282930var cgs2000Ellipsolid = new Cesium.Ellipsoid(6378137.0, 6378137.0, 6356752.31414035585);var myGeographicTilingScheme = new Cesium.GeographicTilingScheme({ ellipsoid: cgs2000Ellipsolid, rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90), numberOfLevelZeroTilesX: 4, numberOfLevelZeroTilesY: 2,});var esriWMTS = new Cesium.ArcGisMapServerImageryProvider({ url: &quot;http://Ip:6080/arcgis/rest/services/jssl_vector_L3_L17/MapServer&quot;, layer: &quot;jssl_vector_L3_L17&quot;, tilingScheme: myGeographicTilingScheme, rectangle: myRectangle, minimumLevel: 0, ellipsoid: cgs2000Ellipsolid, maximumLevel: 14,});var cgs2000GeographicProj = new Cesium.GeographicProjection(cgs2000Ellipsolid);var viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;, { animation: false, geocoder: false, timeline: false, navigationHelpButton: false, baseLayerPicker: false, mapProjection: cgs2000GeographicProj, imageryProvider: esriWMTS,});viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(119.56156642831284, 32.419457329767326, 272683),});","link":"/2025/03/21/cesium%20%E5%8A%A0%E8%BD%BD4490%E5%9D%90%E6%A0%87%E7%B3%BB/"},{"title":"cesium 生成线框","text":"为了在你的自定义**CityPrimitive**中添加重心坐标，你需要修改你的几何体数据，为每个顶点增加这些坐标。重心坐标是一个在三角形顶点上为**[1, 0, 0]**，**[0, 1, 0]**，**[0, 0, 1]**，并在内部插值的属性。这样，三角形的每个边上的坐标都会接近零，并且可以在片段着色器中用来判断一个片段是否接近边缘。 首先，你需要为你的几何体的每个三角形的顶点生成这些坐标。在 Cesium 中，可以在你创建顶点属性的时候添加这些坐标。例如： 12345678910111213141516171819202122232425262728// 生成重心坐标属性function generateBarycentricCoordinates(geometry) { const numberOfVertices = Cesium.Geometry.computeNumberOfVertices(geometry); const barycentricCoordinates = new Float32Array(numberOfVertices * 3); for (let i = 0, len = numberOfVertices / 3; i &lt; len; ++i) { barycentricCoordinates[i * 9 + 0] = 1; // 第一个顶点 barycentricCoordinates[i * 9 + 1] = 0; barycentricCoordinates[i * 9 + 2] = 0; barycentricCoordinates[i * 9 + 3] = 0; // 第二个顶点 barycentricCoordinates[i * 9 + 4] = 1; barycentricCoordinates[i * 9 + 5] = 0; barycentricCoordinates[i * 9 + 6] = 0; // 第三个顶点 barycentricCoordinates[i * 9 + 7] = 0; barycentricCoordinates[i * 9 + 8] = 1; } return new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: barycentricCoordinates, });}// 在你的几何体中添加重心坐标属性this.geometry.attributes.barycentric = generateBarycentricCoordinates(this.geometry); 接着，在你的createCommand函数中，你需要确保这个新属性被传递到着色器中，并且绑定到一个顶点着色器输入： 1234567javascriptCopy codeconst attributeLocations = { position: 0, normal: 1, st: 2, barycentric: 3 // 添加新的属性位置}; 然后，在你的顶点着色器中，你需要接收并传递这个属性到片段着色器： 1234567891011glslCopy code // 顶点着色器 // ... in vec3 barycentric;out vec3 v_barycentric;void main() { // ... v_barycentric = barycentric; // ...} 最后，在你的片段着色器中，你需要使用这个v_barycentric来确定是否绘制线框： 12345678910111213141516glslCopy code // 片段着色器 // ... in vec3 v_barycentric;void main() { // 根据重心坐标确定是否绘制线框 float lineWidth = 0.01; // 设置线宽 if (min(min(v_barycentric.x, v_barycentric.y), v_barycentric.z) &lt; lineWidth) { // 接近边缘，绘制线框 out_FragColor = vec4(0.0, 0.0, 0.0, 1.0); } else { // 在三角形内部，根据需要设置颜色 discard; // 或者适当设置颜色 }} 请记住，这些修改都需要适应你当前的代码和 Cesium 的使用方式。具体细节可能需要进一步调整以确保与你的应用程序兼容。 在 3D 图形学中，重心坐标（Barycentric coordinates）用于表示在三角形内部的点相对于三角形顶点的位置。一个点的重心坐标是三个数（通常记作�,�,�u,v,w），它们的和为 1，每个数对应于点在三角形一个顶点上的“权重”。在图形 API 中，重心坐标通常用于插值（如纹理坐标、颜色等）。 当给每个三角形的顶点赋予不同的重心坐标： 第一个顶点：(1,0,0)(1,0,0) 第二个顶点：(0,1,0)(0,1,0) 第三个顶点：(0,0,1)(0,0,1) 在三角形的边上，至少有一个重心坐标将接近 0（因为边上的点只有两个顶点的“权重”）。在三角形内部，每个重心坐标都将大于 0。 所以，当你看到这样的代码： 1234glslCopy code if (min(min(v_barycentric.x, v_barycentric.y), v_barycentric.z) &lt; lineWidth) { // ... } 这段代码的意思是：如果在三个重心坐标中有任何一个接近 0（小于lineWidth），那么当前片段（Pixel）就处于三角形的边上或接近边缘。在这种情况下，如果你想渲染线框，你会在这些接近边缘的片段上应用一种颜色（如黑色），从而绘制出线框的效果。 而关于您的第一个问题，确实，这是一个顶点对应一个重心坐标，这三个顶点的重心坐标（(1,0,0)(1,0,0), (0,1,0)(0,1,0), (0,0,1)(0,0,1)）被分配给了三角形的三个顶点，这样可以在三角形内部以及边缘上插值这些坐标。当你在顶点着色器中将这些坐标传递到片段着色器，然后在片段着色器中使用这些坐标来检测边缘，你就能实现线框渲染的效果。","link":"/2025/03/21/cesium%20%E7%94%9F%E6%88%90%E7%BA%BF%E6%A1%86/"},{"title":"cesium 根据相机点和距离飞向","text":"在 GIS 开发中，三维地理数据的可视化和交互是非常重要的功能。本文将介绍如何使用 SmartEarth SDK（基于 Cesium 的扩展库）来加载 3D Tiles 模型，并实现模型的属性查询和高亮选择功能。 本示例主要实现了以下功能： 加载多个 3D Tiles 模型 根据经纬度定位并创建标记点 查询并显示 3D Tiles 模型的属性信息 实现模型对象的高亮显示 这些功能在智慧城市、BIM 管理、城市规划等三维可视化应用中非常常见。下面我们来逐一介绍关键技术实现。 根据经纬度创建标记点，并添加到场景中： 12345678910111213141516const position = Cesium.Cartesian3.fromDegrees(lon1, lat1, 60);let cartographicPosition = Cesium.Cartographic.fromCartesian(position);const height = Viewer.scene.sampleHeight(cartographicPosition);// 创建标签const label = earthCtrl.factory.createLabel({ lon: lon1, lat: lat1, alt: height + 1, text: &quot;创建文本&quot;, image: &quot;https://cim.smartearth.cn/sdkdemo/master/src/static/image/mark.png&quot;, // 文本偏移量 pixelOffset: new SmartEarth.Cesium.Cartesian2(0, -50), // 图片偏移量 iPixelOffset: new SmartEarth.Cesium.Cartesian2(0, -20),}); 这段代码演示了如何创建一个带有图标和文本的标记点，sampleHeight方法用于获取该位置的地面高度，确保标记点正确放置。 4. 查询显示 3D Tiles 属性信息当点击模型时，我们需要获取并显示该位置模型的属性信息： 123456789101112131415// 高亮逻辑const winPosition = Viewer.scene.cartesianToCanvasCoordinates(position);const pickObject = Viewer.scene.pick(winPosition);// 获取所有属性const propertyIds = pickObject.getPropertyIds();let tooltipHTML = &quot;&quot;;for (let i = 0; i &lt; propertyIds.length; ++i) { const propertyId = propertyIds[i]; const value = pickObject.getProperty(propertyId); value &amp;&amp; (tooltipHTML += `${propertyId}:${value || &quot;无&quot;}&lt;br&gt;`);}// 显示提示框tooltip.showAts({ position: winPosition, text: tooltipHTML }); 这段代码通过pick函数获取鼠标位置下的 3D Tiles 对象，然后遍历其所有属性，生成 HTML 格式的提示内容。 5. 实现 3D Tiles 模型高亮实现点击模型后高亮显示选中的对象： 1234567891011121314151617181920212223242526// 把上一个高亮的tileset还原if (previousTileSet) { previousTileSet.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { return SmartEarth.Cesium.Color.WHITE; }, }, });}// 设置新的高亮样式const pickId = pickObject.getProperty(&quot;id&quot;);tileset.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { const featueId = feature.getProperty(&quot;id&quot;); if (pickId === featueId) { return SmartEarth.Cesium.Color.YELLOW; } else { return SmartEarth.Cesium.Color.WHITE; } }, },});previousTileSet = tileset; 这段代码使用Cesium3DTileStyle来设置模型的颜色样式。通过比较当前选中对象的 ID 和模型中每个 feature 的 ID，将匹配的对象设置为黄色高亮显示，其余部分保持白色。 6. 相机飞行定位最后，实现相机飞行到指定模型的功能： 12345const options = { duration: 2, offset: new SmartEarth.Cesium.HeadingPitchRange(1.0, -0.3, 1000),};earthCtrl.userScene.flyTo(tiltModel1.item, options); 这段代码使用flyTo方法使相机飞行到指定的模型位置，并设置了适当的视角和距离。 完整代码下面是完整的 HTML 和 JavaScript 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;初始化示例&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/CimSDK.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/Workers/layui/css/layui.css&quot; /&gt; &lt;style&gt; .funcBox { position: absolute; top: 30px; padding: 10px; width: 470px; background-color: rgba(0, 0, 0, 0.7); border-radius: 4px; left: 20px; color: #fff; } .layui-form-item { text-align: center; } .layui-form-label { width: unset !important; padding: 9px !important; } .layui-input-block { margin-left: 50px !important; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sdkContainer&quot;&gt;&lt;/div&gt; &lt;!--按钮--&gt; &lt;div class=&quot;funcBox layui-form&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;lon&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;lon&quot; placeholder=&quot;请输入经度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;lat&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;lat&quot; placeholder=&quot;请输入纬度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;alt&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;alt&quot; placeholder=&quot;请输入高度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;button id=&quot;btn1&quot; class=&quot;layui-btn&quot;&gt;定位&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./CimSDK/Workers/jquery-3.5.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./CimSDK/CimSDK.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; window.earthCtrl = new SmartEarth.EarthCtrl(&quot;sdkContainer&quot;); window.Viewer = earthCtrl.viewer; const Cesium = SmartEarth.Cesium; //显示fps earthCtrl.showFPS = true; //预载入输入框值 const lon1 = 118.36378039081389; $(&quot;#lon&quot;).val(lon1); const lat1 = 31.378263226883764; $(&quot;#lat&quot;).val(lat1); const alt1 = 60; $(&quot;#alt&quot;).val(alt1); let model; let previoisEntity = null; let previousTileSet = null; let tooltip = earthCtrl.core.createTooltip(); tooltip.showFun(false); async function load() { const lon1 = $(&quot;#lon&quot;).val(); const lat1 = $(&quot;#lat&quot;).val(); const alt1 = $(&quot;#alt&quot;).val(); // 加标记点 const position = Cesium.Cartesian3.fromDegrees(lon1, lat1, 60); let cartographicPosition = Cesium.Cartographic.fromCartesian(position); const height = Viewer.scene.sampleHeight(cartographicPosition); // 移除上一个点 if (previoisEntity) { Viewer.entities.remove(previoisEntity); } const label = earthCtrl.factory.createLabel({ lon: lon1, lat: lat1, alt: height + 1, text: &quot;创建文本&quot;, image: &quot;https://cim.smartearth.cn/sdkdemo/master/src/static/image/mark.png&quot;, // 文本偏移量 pixelOffset: new SmartEarth.Cesium.Cartesian2(0, -50), // 图片偏移量 iPixelOffset: new SmartEarth.Cesium.Cartesian2(0, -20), }); previoisEntity = label._primitive; // 高亮逻辑 const winPosition = Viewer.scene.cartesianToCanvasCoordinates(position); const pickObject = Viewer.scene.pick(winPosition); const tileset = pickObject.content._tileset; // 把上一个高亮的tileset还原 if (previousTileSet) { previousTileSet.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { return SmartEarth.Cesium.Color.WHITE; }, }, }); } const pickId = pickObject.getProperty(&quot;id&quot;); const propertyIds = pickObject.getPropertyIds(); // 获取所有属性 // 弹窗显示所有属性 const length = propertyIds.length; let tooltipHTML = &quot;&quot;; for (let i = 0; i &lt; length; ++i) { const propertyId = propertyIds[i]; console.log(`${propertyId}: ${pickObject.getProperty(propertyId)}`); const value = pickObject.getProperty(propertyId); value &amp;&amp; (tooltipHTML += `${propertyId}:${value || &quot;无&quot;}&lt;br&gt;`); } tooltip.showAts({ position: winPosition, text: tooltipHTML }); // 高亮逻辑 tileset.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { console.log(&quot;feature&quot;, feature.getPropertyIds()); const featueId = feature.getProperty(&quot;id&quot;); if (pickId === featueId) { return SmartEarth.Cesium.Color.YELLOW; } else { return SmartEarth.Cesium.Color.WHITE; } }, }, }); previousTileSet = tileset; } const url1 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d120240813104356/tileset.json&quot;; const tiltModel1 = await earthCtrl.factory.create3DTilesets({ url: url1, }); const url2 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d920240813104425/tileset.json&quot;; const tiltModel2 = await earthCtrl.factory.create3DTilesets({ url: url2, }); const url3 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d520240813104456/tileset.json&quot;; const tiltModel3 = await earthCtrl.factory.create3DTilesets({ url: url3, }); const options = { duration: 2, offset: new SmartEarth.Cesium.HeadingPitchRange(1.0, -0.3, 1000), }; earthCtrl.userScene.flyTo(tiltModel1.item, options); $(&quot;#btn1&quot;).on(&quot;click&quot;, () =&gt; { load(); }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2025/03/16/cesium%20%E8%BE%93%E5%85%A5%E7%BB%8F%E7%BA%AC%E5%BA%A6%E5%AE%9A%E4%BD%8D%E5%88%B03dtiles/"},{"title":"cesium修改CesiumTerrainProvider源码","text":"问题背景在实际开发中，我们经常遇到这样的需求：加载一个地形数据后，希望视图自动定位到该地形覆盖的区域，以便用户直观地看到完整的地形数据。默认情况下，Cesium 并不提供这样的功能，加载地形后视图不会自动调整，用户需要手动寻找地形所在位置。这个问题的关键在于： CesiumTerrainProvider 默认不接收地形边界（bounds）参数即使有了 bounds 信息，也缺少一个自动飞行到该区域的便捷方法不同坐标系（EPSG:4326 和 EPSG:3857）的 bounds 处理方式不同 解决方案我们的解决方案分为两个部分：从地形元数据中获取 bopunds修改 CesiumTerrainProvider 源码，使其支持传入地形的 bounds 参数实现一个 flyTo 方法，方便地形加载后自动飞行到指定区域 12345678910111213141516171819202122232425262728293031323334353637const bounds = data.bounds if (!data.projection || data.projection === &quot;EPSG:4326&quot;) { terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1, ellipsoid: terrainProviderBuilder.ellipsoid, rectangle: bounds.length ? Rectangle.fromDegrees(...bounds) : Rectangle.MAX_VALUE }); } else if (data.projection === &quot;EPSG:3857&quot;) { const epsg3857Bounds = Math.PI * terrainProviderBuilder.ellipsoid.maximumRadius; if(bounds[0] &lt; -epsg3857Bounds) { bounds[0] = -epsg3857Bounds } if(bounds[1] &lt; -epsg3857Bounds) { bounds[1] = -epsg3857Bounds } if(bounds[2] &gt; epsg3857Bounds) { bounds[2] = epsg3857Bounds } if(bounds[3] &gt; epsg3857Bounds) { bounds[3] = epsg3857Bounds } terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme({ numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1, ellipsoid: terrainProviderBuilder.ellipsoid, rectangleSouthwestInMeters: new Cartesian2( bounds[0], bounds[1] ), rectangleNortheastInMeters: new Cartesian2( bounds[2], bounds[3] ) }); } 1234const layer = await Cesium.CesiumTerrainProvider.fromUrl( options.url, options); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 地形飞跃 * @method * @param {Object} options 构造参数 * @param {Object} options.orientation 飞行到达地形的视角角度 * @param {Number} options.orientation.heading 航向 * @param {Number} options.orientation.pitch 俯仰 * @param {Number} options.orientation.roll 滚动 * @param {Number} options.height 飞行到达地形的视角高度 （默认10000米） * @param {Number} options.duration 以秒为单位的飞行持续时间 * @param {Function} options.complete 飞行完成时执行的函数 */ flyTo(options = {}) { //const that = this; const option = options; option.orientation = Cesium.defaultValue(options.orientation, { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-60), roll: Cesium.Math.toRadians(0), }); function webMercatorToLatLng(x, y) { const earthRadius = 6378137; // 地球半径，单位：米 const originShift = Math.PI * earthRadius; // 地球周长 const lon = (x / originShift) * 180.0; const lat = (180.0 / Math.PI) * (2.0 * Math.atan(Math.exp((y / originShift) * Math.PI)) - Math.PI / 2.0); return { lon, lat }; } if ( this._parameter.sourceType === &quot;ctb&quot; || this._parameter.sourceType === &quot;arcgis&quot; ) { //'EPSG:4326' const rectangle = this._primitive._tilingScheme.rectangle; const westDegrees = Cesium.Math.toDegrees(rectangle.west); // const westDegrees2 = Cesium.Math.toDegrees(rectangle.east); // const westDegrees3 = Cesium.Math.toDegrees(rectangle.north); // const westDegrees4 = Cesium.Math.toDegrees(rectangle.south); // console.log( // &quot;westDegrees&quot;, // westDegrees, // westDegrees2, // westDegrees3, // westDegrees4 // ); if (westDegrees &lt;= 180 &amp;&amp; westDegrees &gt;= -180) { const lon = Cesium.Math.toDegrees( (rectangle.west + rectangle.east) / 2 ); const lat = Cesium.Math.toDegrees( (rectangle.south + rectangle.north) / 2 ); const height = options.height || 10000; option.destination = Cesium.defaultValue( options.destination, Cesium.Cartesian3.fromDegrees(lon, lat, height) ); } else { const min = webMercatorToLatLng(rectangle.west, rectangle.south); const max = webMercatorToLatLng(rectangle.east, rectangle.north); const lon = (min.lon + max.lon) / 2; const lat = (min.lat + max.lat) / 2; const height = options.height || 10000; option.destination = Cesium.defaultValue( options.destination, Cesium.Cartesian3.fromDegrees(lon, lat, height) ); } this._coreMap.camera.flyTo(option); } }}","link":"/2025/03/21/cesium%E4%BF%AE%E6%94%B9CesiumTerrainProvider%E6%BA%90%E7%A0%81/"},{"title":"cesium修改源码支持月球坐标系","text":"随着各国探月任务的不断推进，月球地图可视化的需求日益增长。Cesium 作为一款功能强大的三维地球可视化框架，默认只支持地球坐标系（主要是 WGS84），无法直接用于月球数据的展示与分析。本文将详细介绍如何通过修改 Cesium 源码，为其添加月球坐标系的支持，实现月球数据的准确可视化。 月球与地球坐标系的差异 在进行修改前，我们需要理解月球与地球坐标系的主要区别： 形状差异：地球是扁球体，而月球更接近于标准球体 尺寸差异：月球半径约为 1737.4 公里，远小于地球的 6378.137 公里 扁率差异：地球的扁率约为 1/298.257，而月球的扁率可以忽略不计 坐标系统：月球通常使用基于它自身参数的坐标系，如 MOON2000 这些差异导致我们不能直接使用地球的椭球体参数来处理月球数据，否则会产生严重的位置偏差和变形。 1234567891011121314151617const ExternalParameter = { ellipsoidCoordinates: null, changeApproximateTerrainHeights: false, minTerrainHeight: -20000, maxTerrainHeight: 20000, hasVertexNormals: false, //mpt坡度图};ExternalParameter.isMoon = function () { return ( ExternalParameter.ellipsoidCoordinates === &quot;MOON&quot; || ExternalParameter.ellipsoidCoordinates === &quot;MOON2000&quot; );};ExternalParameter.isVertexNormals = function () { return ExternalParameter.hasVertexNormals;};export default ExternalParameter; 123456const MOONRadiiSquared = new Cartesian3( 1737400.0 * 1737400.0, 1737400.0 * 1737400.0, // eslint-disable-next-line no-loss-of-precision 1737400.0 * 1737400.0); 1234567891011121314151617181920212223242526272829303132333435Cartesian3.fromRadians = function (longitude, latitude, height, ellipsoid, result) { //&gt;&gt;includeStart('debug', pragmas.debug); Check.typeOf.number(&quot;longitude&quot;, longitude); Check.typeOf.number(&quot;latitude&quot;, latitude); //&gt;&gt;includeEnd('debug'); height = defaultValue(height, 0.0); /** Geoworld Add **/ let radiiSquared = null; if (ExternalParameter.ellipsoidCoordinates === &quot;CGCS2000&quot;) { radiiSquared = CGCS2000RadiiSquared; } else if ( ExternalParameter.ellipsoidCoordinates === &quot;MOON&quot; || ExternalParameter.ellipsoidCoordinates === &quot;MOON2000&quot; ) { radiiSquared = MOONRadiiSquared; } else { radiiSquared = !defined(ellipsoid) ? Cartesian3._ellipsoidRadiiSquared : ellipsoid.radiiSquared; } const cosLatitude = Math.cos(latitude); scratchN.x = cosLatitude * Math.cos(longitude); scratchN.y = cosLatitude * Math.sin(longitude); scratchN.z = Math.sin(latitude); scratchN = Cartesian3.normalize(scratchN, scratchN); Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK); const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK)); scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK); scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN); if (!defined(result)) { result = new Cartesian3(); } return Cartesian3.add(scratchK, scratchN, result);}; 123456const moonOneOverRadii = new Cartesian3(1.0 / 1737400.0, 1.0 / 1737400.0, 1.0 / 1737400.0);const moonOneOverRadiiSquared = new Cartesian3( 1.0 / (1737400.0 * 1737400.0), 1.0 / (1737400.0 * 1737400.0), 1.0 / (1737400.0 * 1737400.0)); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Cartographic.fromCartesian = function (cartesian, ellipsoid, result) { // const oneOverRadii = defined(ellipsoid) // ? ellipsoid.oneOverRadii // : wgs84OneOverRadii; // const oneOverRadiiSquared = defined(ellipsoid) // ? ellipsoid.oneOverRadiiSquared // : wgs84OneOverRadiiSquared; // const centerToleranceSquared = defined(ellipsoid) // ? ellipsoid._centerToleranceSquared // : wgs84CenterToleranceSquared; //** Geoworld Add **/ let oneOverRadii = null; let oneOverRadiiSquared = null; const centerToleranceSquared = defined(ellipsoid) ? ellipsoid._centerToleranceSquared : Cartographic._ellipsoidCenterToleranceSquared; if (ExternalParameter.ellipsoidCoordinates === &quot;CGCS2000&quot;) { oneOverRadii = CGCS2000OneOverRadii; oneOverRadiiSquared = CGCS2000OneOverRadiiSquared; } else if ( ExternalParameter.ellipsoidCoordinates === &quot;MOON&quot; || ExternalParameter.ellipsoidCoordinates === &quot;MOON2000&quot; ) { oneOverRadii = moonOneOverRadii; oneOverRadiiSquared = moonOneOverRadiiSquared; } else { oneOverRadii = defined(ellipsoid) ? ellipsoid.oneOverRadii : Cartographic._ellipsoidOneOverRadii; oneOverRadiiSquared = defined(ellipsoid) ? ellipsoid.oneOverRadiiSquared : Cartographic._ellipsoidOneOverRadiiSquared; } //`cartesian is required.` is thrown from scaleToGeodeticSurface const p = scaleToGeodeticSurface( cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, cartesianToCartographicP ); if (!defined(p)) { return undefined; } let n = Cartesian3.multiplyComponents(p, oneOverRadiiSquared, cartesianToCartographicN); n = Cartesian3.normalize(n, n); const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH); const longitude = Math.atan2(n.y, n.x); const latitude = Math.asin(n.z); const height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h); if (!defined(result)) { return new Cartographic(longitude, latitude, height); } result.longitude = longitude; result.latitude = latitude; result.height = height; return result;}; 123456789/** Geoworld Add **/Ellipsoid.MOON2000 = Object.freeze( // eslint-disable-next-line no-loss-of-precision new Ellipsoid(1737400.0, 1737400.0, 1737400.0));Ellipsoid.MOON = Object.freeze( new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));","link":"/2025/03/21/cesium%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E6%94%AF%E6%8C%81%E6%9C%88%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB/"},{"title":"cesium加载10万点","text":"Cesium 优化：高效加载 10 万点位的实现方案 在 WebGIS 应用开发中，大量点位标记的高效渲染一直是一个挑战。特别是在 Cesium 这样的三维地图引擎中，当需要同时展示上万甚至十万级别的点位标记时，性能问题尤为突出。本文将分享一种在 Cesium 中高效加载和渲染 10 万级点位的实现方案，重点关注 BillboardCollection 的优化配置。 问题背景在实际业务中，我们经常需要在地图上展示大量的点位标记，例如： 全国范围内的监测站点数据 城市级别的物联网设备分布 人口热力图点位 轨迹点位数据 当这些点位数量达到万级甚至十万级时，常规的渲染方式会导致严重的性能问题： 页面加载缓慢，甚至浏览器崩溃 交互操作卡顿，FPS 大幅下降 内存占用过高 优化方案通过实验发现，Cesium 的 BillboardCollection 在创建时，如果传入scene参数，可以显著提升大量点位的渲染性能。这是因为传入 scene 参数后，BillboardCollection 会使用 WebGL 的实例化渲染(Instanced Arrays)技术，大幅减少渲染调用次数。 下面是一个加载 10 万点位的优化实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Cesium = SmartEarth.Cesium;window.earthCtrl = new SmartEarth.EarthCtrl(&quot;sdkContainer&quot;, {});window.viewer = window.earthCtrl.viewer;earthCtrl.showFPS = true;const ellipsoid = viewer.scene.globe.ellipsoid;let billboardCollection;let instancingEnabled = true;// const instancedArraysExtension = context._instancedArrays;let billboardCount = 100489;let scale = 1.0;// Define the area where billboards will be placedconst centerLongitude = -1.385205433269729;const centerLatitude = 0.6777926580888163;const rectangleHalfSize = 0.5;const e = new Cesium.Rectangle( centerLongitude - rectangleHalfSize, centerLatitude - rectangleHalfSize, centerLongitude + rectangleHalfSize, centerLatitude + rectangleHalfSize);resetBillboardCollection();function resetBillboardCollection() { if (Cesium.defined(billboardCollection)) { viewer.scene.primitives.remove(billboardCollection); } billboardCollection = viewer.scene.primitives.add( new Cesium.BillboardCollection({ scene: viewer.scene, }) ); const gridSize = Math.sqrt(billboardCount); for (let y = 0; y &lt; gridSize; ++y) { for (let x = 0; x &lt; gridSize; ++x) { const longitude = Cesium.Math.lerp(e.west, e.east, x / (gridSize - 1)); const latitude = Cesium.Math.lerp(e.south, e.north, y / (gridSize - 1)); const position = new Cesium.Cartographic(longitude, latitude, 10000.0); billboardCollection.add({ position: ellipsoid.cartographicToCartesian(position), image: &quot;./demo/image/water.svg&quot;, scale: scale, }); } }} 代码解析让我们详细分析一下代码的关键部分： 1. 核心优化点12345billboardCollection = viewer.scene.primitives.add( new Cesium.BillboardCollection({ scene: viewer.scene, })); 这里的关键优化是在创建 BillboardCollection 时传入scene参数。这看似简单的一步却有巨大的性能提升，主要原因是： 启用了 WebGL 的 Instanced Arrays 扩展功能 减少了 CPU 到 GPU 的数据传输次数 降低了 WebGL 的绘制调用(draw calls)次数 2. 点位生成策略12345678const gridSize = Math.sqrt(billboardCount);for (let y = 0; y &lt; gridSize; ++y) { for (let x = 0; x &lt; gridSize; ++x) { const longitude = Cesium.Math.lerp(e.west, e.east, x / (gridSize - 1)); const latitude = Cesium.Math.lerp(e.south, e.north, y / (gridSize - 1)); // ... }} 这段代码采用网格分布策略生成点位： 计算网格大小为点位总数的平方根（约 317×317 网格） 使用双重循环填充整个矩形区域 通过线性插值(Cesium.Math.lerp)均匀分布点位 3. 点位创建123456const position = new Cesium.Cartographic(longitude, latitude, 10000.0);billboardCollection.add({ position: ellipsoid.cartographicToCartesian(position), image: &quot;./demo/image/water.svg&quot;, scale: scale,}); 每个点位的创建过程： 创建经纬度高度的笛卡尔坐标 转换为地心坐标系(ECEF) 使用统一的 SVG 图标 应用统一的缩放比例 性能对比实验表明，添加scene参数前后的性能差异非常显著： 配置 点位数量 平均 FPS 加载时间 内存占用 不带 scene 参数 100,489 &lt;10 &gt;10 秒 高 带 scene 参数 100,489 &gt;30 &lt;3 秒 中等 通过截图可以看到，使用优化方案后，即使是在渲染 10 万级别的点位时，FPS 仍然能够维持在 30 以上，确保了良好的用户体验。 总结通过在 BillboardCollection 中正确配置scene参数，结合其他优化技巧，我们成功实现了在 Cesium 中高效渲染 10 万级点位的功能。这种方法大幅提升了渲染性能，降低了内存占用，使得大规模点位可视化成为可能。","link":"/2025/03/20/cesium%E5%8A%A0%E8%BD%BD10%E4%B8%87%E7%82%B9/"},{"title":"cesium加载3DGS","text":"Cesium 团队很早就已经在 3DTiles1.1 上实现了 3DGS 加载，只是因为这个 KHR_gaussian_splatting 还没有正式成为标准的扩展，一直在一个独立的分支当中（基于 Cesium 的 splat-shader 分支版本的原生渲染。目前 Cesium 针对 3D 高斯泼溅的开发放在了 splat-shader 这个分支版本，想尝鲜的用户可以直接下载这个分支版本，这个版本的案例集合中也自带了一个3d 高斯泼溅渲染的 demo，但是场景规模还比较小。） 加载 3DGS 步骤 1.下载 cesium splat-shader 分支,然后源码编译,npm run build 生成一个可用的包 2.splat 高斯数据转成 3dtiles 可以用 GISBox 或者 Cesiumlab 3.用这个分支生成的包加载这个 3dtiles","link":"/2025/03/21/cesium%E5%8A%A0%E8%BD%BD3DGS/"},{"title":"cesium加载SEM纹理合并","text":"在使用 Cesium 进行三维可视化开发时，纹理处理是影响应用性能和视觉质量的关键因素。尤其是在加载大规模三维模型时，如何有效管理和优化纹理资源变得尤为重要。本文将详细介绍纹理合并（Texture Atlas）技术在 Cesium 中的实现，以及如何通过这一技术显著提升渲染性能。 为什么需要纹理合并？是因为这个一个 cityjson 里边有多张图片，而一个 cityjson 是一个 drawcommand, 里边只能创建一个 Texture 对象，需要把多张图合并成一张大图传入着色器里边 但是这种方法也不太好，图片大的时候就会占的显存多，应该使用纹理压缩技术，例如 KTX 压缩 纹理合并的实现原理纹理合并的核心思想是将多个独立的纹理图像拼接到一个更大的”纹理图集”（Texture Atlas）中，并相应地调整 UV 坐标，使模型仍能正确引用到对应的纹理区域。 实现这一过程主要包括以下几个步骤： 加载所有原始纹理图像 计算合并后的纹理尺寸 为每个原始纹理分配在合并纹理中的位置（偏移量） 更新模型的 UV 坐标以匹配新布局 创建合并纹理并渲染模型 接下来，我们将通过代码详细解析这一过程。 代码实现详解1. 整体流程首先，让我们看看整个纹理合并过程的主要函数： 12345678910111213141516171819202122232425262728293031SemModel.prototype.renderMoreDetialModel = async function ( key, rtcCenter, newVertices, newFaceIds, imgList, imageIds, textures, attributes, surfaceType, coordSystem, lod) { const { imageSizes, imageData } = await this.calculateImageData(imageIds, imgList); const textureSize = this.calculateTextureSize(imageSizes, 3); this.calculateImageOffset(imageSizes, imageData); const mergeTextureUVs = this.updateTextureUvs(textures, textureSize, imageData); this.createCityPrimitive( key, newFaceIds, newVertices, mergeTextureUVs, imageData, textureSize, attributes, surfaceType, rtcCenter, coordSystem, lod );}; 这个函数协调了整个纹理合并流程： 加载和处理图像数据 计算合并纹理的尺寸 计算每个原始纹理在合并纹理中的偏移量 更新 UV 坐标 创建并渲染使用合并纹理的基元（Primitive） 2. 加载图像数据123456789101112131415161718192021222324252627282930313233343536SemModel.prototype.calculateImageData = async function (imageIds, imgList) { const imageSizes = []; const imageData = []; for (let i = 0; i &lt; imageIds.length; i++) { const imageId = imageIds[i]; const buffer = imgList[imageId]; const image = await this.getImage(buffer, imageIds); imageSizes.push({ width: image.width, height: image.height, }); imageData.push({ id: imageId, image: image, buffer: buffer, width: image.width, height: image.height, xOffset: 0, yOffset: 0, }); } return { imageSizes, imageData };};SemModel.prototype.getImage = async function (arrayBuffer) { return new Promise((resolve, reject) =&gt; { const blob = new Blob([arrayBuffer]); const img = new Image(); img.onload = () =&gt; { resolve(img); }; img.onerror = reject; const url = URL.createObjectURL(blob); img.src = url; });}; 这部分代码负责： 从二进制数据加载图像 收集图像尺寸信息 准备用于合并纹理的基础数据结构 需要注意的是，图像加载是异步的，使用了 Promise 和 async/await 处理。 3. 计算纹理尺寸12345678910111213141516171819202122232425SemModel.prototype.calculateTextureSize = function (images, maxPerRow) { let totalWidth = 0; let totalHeight = 0; let currentRowWidth = 0; let currentRowHeight = 0; images.forEach((image, index) =&gt; { // 更新当前行的宽度和高度 currentRowWidth += image.width; currentRowHeight = Math.max(currentRowHeight, image.height); // 检查是否到达行的末尾或图片列表末尾 if ((index + 1) % maxPerRow === 0 || index === images.length - 1) { // 更新总纹理尺寸 totalWidth = Math.max(totalWidth, currentRowWidth); totalHeight += currentRowHeight; // 重置当前行的尺寸 currentRowWidth = 0; currentRowHeight = 0; } }); return { width: totalWidth, height: totalHeight };}; 这个函数计算合并后的纹理尺寸： 将原始纹理排列成网格（每行最多maxPerRow个纹理） 计算每行的宽度和高度 汇总得到最终的纹理尺寸 这种网格布局是纹理合并的常用策略，它平衡了宽度和高度，避免了纹理过细过长。 4. 计算纹理偏移量12345678910111213141516171819202122SemModel.prototype.calculateImageOffset = function (imageSizes, imageData) { let xOffset = 0; let yOffset = 0; let currentRowWidth = 0; let currentRowHeight = 0; imageSizes.forEach((image, index) =&gt; { imageData[index].xOffset = xOffset; imageData[index].yOffset = yOffset; // 更新偏移量 currentRowWidth += image.width; xOffset += image.width; currentRowHeight = Math.max(currentRowHeight, image.height); // 检查是否需要换行 if ((index + 1) % 3 === 0 || index === imageSizes.length - 1) { yOffset += currentRowHeight; xOffset = 0; currentRowWidth = 0; currentRowHeight = 0; } });}; 这个函数为每个原始纹理分配在合并纹理中的位置： 从左上角开始，水平排列纹理 每行最多 3 个纹理（与前面的maxPerRow对应） 记录每个纹理的xOffset和yOffset，这将用于后续的 UV 坐标计算和纹理创建 5. 更新 UV 坐标12345678910111213141516171819202122SemModel.prototype.updateTextureUvs = function (textures, textureSize, imageData) { const textureData = textures.data; const mergeTextureUVs = []; const { width: textureWidth, height: textureHeight } = textureSize; for (let i = 0; i &lt; textureData.length; i++) { const texture = textureData[i]; const imageId = texture.index; const uvs = texture.uvs; const index = imageData.findIndex(item =&gt; item.id === imageId); if (!~index) { continue; } const imageObj = imageData[index]; const { width, height, xOffset, yOffset } = imageObj; const newUv = [ uvs[0] * (width / textureWidth) + xOffset / textureWidth, uvs[1] * (height / textureHeight) + yOffset / textureHeight, ]; mergeTextureUVs.push(newUv[0], newUv[1]); } return mergeTextureUVs;}; 这个函数执行最关键的 UV 坐标转换： 将原始纹理的 UV 坐标（范围 0-1）转换为合并纹理中的相对坐标 考虑了原始纹理的大小比例和在合并纹理中的偏移量 这确保了模型在使用合并纹理时仍能正确映射到对应的纹理区域 6. 创建纹理并设置着色器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647createTexture(imageData) { const context = this._viewer.scene.context; const vTexture = new Cesium.Texture({ context: context, width: this.textureSize.width, height: this.textureSize.height, }); if (!imageData.length) { return; } imageData.forEach((item) =&gt; { vTexture.copyFrom({ source: item.image, xOffset: item.xOffset, yOffset: item.yOffset, }); }); vTexture.generateMipmap(); this._texture = vTexture;}// 创建着色器统一变量映射const uniformMap = { // ...其他统一变量 image: () =&gt; { return Cesium.defined(this._texture) ? this._texture : this._viewer.scene.context.defaultTexture; }, // ...其他统一变量};// 创建着色器程序const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations,});// 创建绘制命令this.command = new Cesium.DrawCommand({ // ...其他属性 shaderProgram: shaderProgram, uniformMap: uniformMap, // ...其他属性}); 最后，这部分代码： 创建合并纹理 将每个原始纹理复制到合并纹理的正确位置 生成纹理的 mipmap（用于不同距离的细节级别） 创建着色器程序和统一变量映射 创建绘制命令以渲染使用合并纹理的模型 深入理解 vTexture.copyFrom 方法在纹理合并的整个过程中，vTexture.copyFrom() 方法是最核心的操作，它实际执行了将多个图像”拼接”到一个大纹理中的过程。让我们深入了解这个方法的工作原理、参数和性能特性。 copyFrom 方法详解12345vTexture.copyFrom({ source: item.image, xOffset: item.xOffset, yOffset: item.yOffset,}); 参数解析 source: 源图像数据，可以是多种类型： HTMLImageElement: 常规的图像元素 HTMLCanvasElement: Canvas 元素 HTMLVideoElement: 视频元素 ImageData: 原始图像数据 TypedArray: 类型化数组 xOffset/yOffset: 目标位置偏移量，指定源图像应该复制到目标纹理的哪个位置（以像素为单位）。 工作原理当调用copyFrom方法时，Cesium 在底层执行以下操作： 获取 WebGL 上下文 绑定目标纹理 使用gl.texSubImage2D将源图像数据复制到目标纹理的指定位置 保留纹理的其余部分不变 1234567891011// Cesium内部实现的简化版本gl.bindTexture(gl.TEXTURE_2D, textureId);gl.texSubImage2D( gl.TEXTURE_2D, // 目标 0, // mipmap级别 xOffset, // X偏移 yOffset, // Y偏移 gl.RGBA, // 格式 gl.UNSIGNED_BYTE, // 类型 source // 源数据); 性能优势copyFrom方法比传统的 Canvas 合并方法有几个显著的性能优势： 直接 GPU 操作: 它直接在 GPU 内存中执行复制，避免了 CPU 与 GPU 之间的大量数据传输 避免创建中间 Canvas: 不需要先在 Canvas 上绘制然后再将整个 Canvas 上传到 GPU 增量更新能力: 可以只更新纹理的一部分，而不需要重新上传整个纹理 内存效率: 直接操作已分配的纹理内存，不需要额外的临时缓冲区 使用示例以下是一个更完整的例子，展示了如何利用copyFrom创建动态纹理图集： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function createDynamicTextureAtlas(images) { // 创建空纹理 const texture = new Cesium.Texture({ context: viewer.scene.context, width: atlasWidth, height: atlasHeight, pixelFormat: Cesium.PixelFormat.RGBA, pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE, }); // 分配图像位置 let x = 0, y = 0, rowHeight = 0; const positions = []; images.forEach(image =&gt; { // 检查是否需要换行 if (x + image.width &gt; atlasWidth) { x = 0; y += rowHeight; rowHeight = 0; } // 记录位置 positions.push({ image: image, x: x, y: y, }); // 更新下一个位置 x += image.width; rowHeight = Math.max(rowHeight, image.height); }); // 复制图像到纹理 positions.forEach(pos =&gt; { texture.copyFrom({ source: pos.image, xOffset: pos.x, yOffset: pos.y, }); }); // 生成mipmap texture.generateMipmap(); return { texture: texture, positions: positions, };} 总结纹理合并是 Cesium 应用中一项强大的性能优化技术。通过将多个小纹理合并为一个大纹理，可以显著减少绘制调用次数、优化内存使用、提高批处理效率，并最终提升应用的整体性能和用户体验。","link":"/2025/03/21/cesium%E5%8A%A0%E8%BD%BDSEM%E7%BA%B9%E7%90%86%E5%90%88%E5%B9%B6/"},{"title":"cesium加载SEM解决模型抖动问题","text":"Cesium 高精度渲染：转换为局部坐标系的实现方案 在 Cesium 开发中，当需要渲染大量高精度模型或远离地球原点的模型时，经常会遇到浮点精度问题，导致模型抖动、撕裂或位置偏移。这种情况下，将模型转换为局部坐标系（Local Coordinate System）是一种行之有效的解决方案。本文将详细介绍如何在 Cesium 中实现世界坐标到局部坐标的转换，以提高渲染精度和性能。 为什么需要局部坐标系？Cesium 默认使用 ECEF（Earth-Centered, Earth-Fixed）坐标系，即地心地固坐标系。这是一个以地球中心为原点的笛卡尔坐标系。当模型距离原点很远时，会出现以下问题： 浮点精度损失：JavaScript 使用 64 位浮点数，有效精度约为 16 位。当坐标值很大时（如地球表面点的 ECEF 坐标通常为百万量级），小数部分的精度会逐渐丢失。 模型抖动：精度损失导致相机移动时，模型会出现微小的抖动或跳跃。 Z-fighting：深度缓冲区精度不足，导致表面之间出现闪烁。 局部坐标系通过将模型中心设为原点，大幅减小坐标值的绝对大小，从而保留更多小数位精度，解决上述问题。 实现原理局部坐标系的核心思想是相对于中心点（Relative to Center，简称 RTC）技术。其基本步骤如下： 选择一个参考点作为局部坐标系的原点（通常是模型的中心点） 创建从全球坐标到局部坐标的转换矩阵 将所有顶点从全球坐标转换为相对于该原点的局部坐标 在渲染时，将整个坐标系一起变换回全球位置 代码实现1. 创建局部坐标系首先，我们需要为模型创建一个局部坐标系： 123const rtcCartesian3 = Cesium.Cartesian3.fromDegrees(rtcCenter[0], rtcCenter[1], rtcCenter[2]);const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(rtcCartesian3);const modelMatrixInverse = Cesium.Matrix4.inverse(modelMatrix, new Cesium.Matrix4()); 这段代码的工作原理： rtcCenter是局部坐标系的中心点，使用经纬度和高度表示 Cesium.Cartesian3.fromDegrees将经纬度坐标转换为 ECEF 坐标 eastNorthUpToFixedFrame创建一个变换矩阵，该矩阵定义了一个以指定点为原点、东北天为轴向的局部坐标系 计算矩阵的逆矩阵，用于将全球坐标转换为局部坐标 2. 坐标转换函数下面是将全球坐标转换为局部坐标的辅助函数： 1234567SemModel.prototype.worldToLocal = function (positionWC, result, modelMatrixInverse) { if (!Cesium.defined(result)) { result = new Cesium.Matrix4(); } Cesium.Matrix4.multiplyByPoint(modelMatrixInverse, positionWC, result); return result;}; 该函数通过将世界坐标点与逆模型矩阵相乘，将其转换为局部坐标系中的点。 3. 创建使用局部坐标的几何体最后，我们将完整的几何体转换到局部坐标系： 123456789101112131415161718192021222324252627282930313233343536373839404142SemModel.prototype.createCityGeometry = function ( coordSystem, vertices, vertexIds, mergeTextureUVs, modelMatrixInverse) { const localVertices = []; vertices.forEach(vertex =&gt; { // 将4549坐标系下的坐标转成4326下的坐标 const coord = proj4(coordSystem, &quot;EPSG:4326&quot;, [vertex[0], vertex[1], vertex[2]]); const position = Cesium.Cartesian3.fromDegrees(coord[0], coord[1], coord[2]); this.worldToLocal(position, position, modelMatrixInverse); localVertices.push(position.x, position.y, position.z); }); const verticesArr = new Float32Array(localVertices); const indicesArr = new Uint16Array(vertexIds); const barycentricCoords = this.generateBarycentricCoords(verticesArr); const geometry = new Cesium.Geometry({ attributes: { position: new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: verticesArr, }), st: new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 2, values: mergeTextureUVs, }), barycentric: new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: barycentricCoords, }), }, indices: indicesArr, primitiveType: Cesium.PrimitiveType.TRIANGLES, boundingSphere: Cesium.BoundingSphere.fromVertices(verticesArr), }); return geometry;}; 这个函数的工作流程： 遍历所有顶点 将原始坐标（此例中为 EPSG:4549）转换为 WGS84 经纬度（EPSG:4326） 将经纬度转换为 Cesium 的 ECEF 坐标 将 ECEF 坐标转换为局部坐标 创建几何体，使用转换后的局部坐标","link":"/2025/03/21/cesium%E5%8A%A0%E8%BD%BDSEM%E8%A7%A3%E5%86%B3%E6%A8%A1%E5%9E%8B%E6%8A%96%E5%8A%A8%E9%97%AE%E9%A2%98/"},{"title":"Cesium实现可拖拽图标及连接线","text":"在 Cesium 三维地图应用中，灵活的用户交互功能对于提升用户体验至关重要。本文将详细介绍如何在 Cesium 中实现可拖拽的信息标签功能，包括标签与目标实体之间的动态连接线，以及如何优雅地处理视角变化时的位置更新问题。这种交互方式特别适合展示动态目标（如车辆、飞机等）的实时信息。 需求背景在展示如车辆轨迹、飞行路径等动态场景时，我们通常需要同时显示目标的详细信息。直接将信息附加在目标上往往会造成视觉混乱，而允许用户自由拖动信息标签则可以： 避免信息遮挡重要视图内容 允许用户根据自己的喜好整理界面 在多目标场景下提高信息的可读性 保持目标与信息之间的视觉关联 实现原理实现可拖拽标签的核心是利用 Cesium 的事件系统捕获用户交互，并实时更新标签的屏幕坐标偏移量。主要步骤包括： 为目标实体创建关联的信息标签实体 标记实体为可拖拽（通过自定义属性） 设置屏幕空间事件处理器捕获拖拽事件 在拖拽过程中更新标签的偏移量 创建并维护目标与标签之间的连接线 详细代码解析1. 创建信息标签首先，我们需要为目标实体创建一个信息标签： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const createHTMLLable = (entities, id) =&gt; { const entity = entities.getById(id); const entity2 = new Cesium.Entity({ id: id + &quot;box&quot;, drag: true, // 自定义属性，标记为可拖拽 position: entity.position, }); entity2.proId = id; // 存储关联的目标ID // 设置标签背景图片 entity2.billboard = { width: 245, height: 86, image: &quot;/img/box.png&quot;, horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, eyeOffset: new Cesium.Cartesian3(0, 0, 1), pixelOffset: new Cesium.Cartesian2(0, -120), distanceDisplayCondition: new Cesium.DistanceDisplayCondition(20, 100000), }; // 设置标签文本内容，这里使用回调属性来动态更新坐标信息 entity2.label = { text: new Cesium.CallbackProperty(function () { const time = viewer.clock.currentTime; const position = entity.position.getValue(time); const cartographic = Cesium.Cartographic.fromCartesian(position); const longitude = Cesium.Math.toDegrees(cartographic.longitude); const latitude = Cesium.Math.toDegrees(cartographic.latitude); return `\\t\\t${longitude.toFixed(4)}\\t\\t\\n\\t\\t${latitude.toFixed(5)}\\t\\t`; }, false), font: &quot;19pt/1.5 微软雅黑&quot;, showBackground: true, backgroundColor: new Cesium.Color(0.165, 0.165, 0.165, 0.8), horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.TOP, pixelOffset: new Cesium.Cartesian2(85, -198), show: true, distanceDisplayCondition: new Cesium.DistanceDisplayCondition(20, 100000), }; // 创建连接线并更新 let linePositions; function updateLine() { const currentTime = viewer.clock.currentTime; const position = entity.position.getValue(currentTime); const screenPosition = Cesium.SceneTransforms.worldToDrawingBufferCoordinates( viewer.scene, position ); const carBillboardOffset = entity2.billboard.pixelOffset.getValue(); if (screenPosition) { const offsetScreenPosition = new Cesium.Cartesian2( screenPosition.x + carBillboardOffset.x + 85, screenPosition.y + carBillboardOffset.y ); const offsetCartesian = viewer.camera.pickEllipsoid( offsetScreenPosition, viewer.scene.globe.ellipsoid ); if (!offsetCartesian) return; const lineId = id + &quot;line&quot;; let lineEntity = entities.getById(lineId); if (!lineEntity) { linePositions = [offsetCartesian, position]; lineEntity = entities.add({ id: lineId, polyline: { positions: new Cesium.CallbackProperty(function () { return linePositions; }, false), width: 2, material: new Cesium.PolylineDashMaterialProperty({ color: Cesium.Color.RED, dashLength: 16.0, }), }, }); } else { linePositions = [offsetCartesian, position]; } } } updateLine(); viewer.scene.camera.changed.addEventListener(updateLine); entities.add(entity2);}; 这段代码的关键点： 使用drag: true标记实体为可拖拽 使用proId存储关联的目标实体 ID，方便后续引用 通过CallbackProperty动态更新标签文本内容，显示实时坐标 创建虚线连接目标和标签 监听相机变化事件，实时更新连接线位置 2. 实现拖拽功能拖拽功能的核心是设置屏幕空间事件处理器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const setupDraggingHandler = () =&gt; { const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas); let selectedEntity; let isDragging = false; let startDragPosition = null; let startOffset = null; let startLabelOffset = null; // 更新连接线位置的函数 const updateLinePosition = () =&gt; { if (!selectedEntity) return; const currentTime = viewer.clock.currentTime; const position = selectedEntity.position.getValue(currentTime); const screenPosition = Cesium.SceneTransforms.worldToDrawingBufferCoordinates( viewer.scene, position ); const carBillboardOffset = selectedEntity.billboard.pixelOffset.getValue(); if (screenPosition) { const offsetScreenPosition = new Cesium.Cartesian2( screenPosition.x + carBillboardOffset.x + 85, screenPosition.y + carBillboardOffset.y ); const offsetCartesian = viewer.camera.pickEllipsoid( offsetScreenPosition, viewer.scene.globe.ellipsoid ); if (offsetCartesian) { const lineId = selectedEntity.proId + &quot;line&quot;; const lineEntity = entitiesCol.getById(lineId); if (lineEntity) { lineEntity.polyline.positions = new Cesium.CallbackProperty(function () { return [offsetCartesian, position]; }, false); } } } }; // 处理鼠标按下事件 handler.setInputAction(function (click) { const pickedObject = viewer.scene.pick(click.position); if (Cesium.defined(pickedObject) &amp;&amp; Cesium.defined(pickedObject.id) &amp;&amp; pickedObject.id.drag) { // 选中标记为可拖拽的实体 selectedEntity = pickedObject.id; isDragging = true; startDragPosition = click.position; // 获取当前偏移量 startOffset = selectedEntity.billboard.pixelOffset.getValue(); startLabelOffset = selectedEntity.label.pixelOffset.getValue(); // 禁用相机旋转，防止拖动时意外旋转视图 viewer.scene.screenSpaceCameraController.enableRotate = false; } }, Cesium.ScreenSpaceEventType.LEFT_DOWN); // 处理鼠标移动事件 handler.setInputAction(function (movement) { if (isDragging &amp;&amp; selectedEntity) { const dragPosition = movement.endPosition; // 计算拖动的距离 const offsetX = dragPosition.x - startDragPosition.x; const offsetY = dragPosition.y - startDragPosition.y; // 更新偏移量 const newPixelOffset = new Cesium.Cartesian2( startOffset.x + offsetX, startOffset.y + offsetY ); const newLabelOffset = new Cesium.Cartesian2( startLabelOffset.x + offsetX, startLabelOffset.y + offsetY ); // 应用新的偏移量 selectedEntity.billboard.pixelOffset = newPixelOffset; selectedEntity.label.pixelOffset = newLabelOffset; // 更新连接线 updateLinePosition(); } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE); // 处理鼠标释放事件 handler.setInputAction(function () { isDragging = false; startDragPosition = null; startOffset = null; // 重新启用相机旋转 viewer.scene.screenSpaceCameraController.enableRotate = true; // 添加相机变化监听，以更新连接线 viewer.scene.camera.changed.addEventListener(updateLinePosition); }, Cesium.ScreenSpaceEventType.LEFT_UP);}; 这段代码的关键点： 创建ScreenSpaceEventHandler用于捕获鼠标事件 在 LEFT_DOWN 事件中，检查点击的实体是否标记为可拖拽 记录拖拽起始位置和初始偏移量 在 MOUSE_MOVE 事件中，计算鼠标移动距离并更新标签偏移量 在 LEFT_UP 事件中，重置拖拽状态并恢复正常操作 3. 连接线实现连接线的实现涉及两个关键步骤： 计算标签在屏幕上的位置 将屏幕坐标转换回世界坐标，作为连接线的一端 12345678910111213141516171819202122232425// 更新连接线的关键代码const screenPosition = Cesium.SceneTransforms.worldToDrawingBufferCoordinates( viewer.scene, position);const carBillboardOffset = entity2.billboard.pixelOffset.getValue();if (screenPosition) { // 计算标签位置在屏幕上的坐标 const offsetScreenPosition = new Cesium.Cartesian2( screenPosition.x + carBillboardOffset.x + 85, screenPosition.y + carBillboardOffset.y ); // 将屏幕坐标转换回世界坐标 const offsetCartesian = viewer.camera.pickEllipsoid( offsetScreenPosition, viewer.scene.globe.ellipsoid ); if (offsetCartesian) { // 创建或更新连接线 linePositions = [offsetCartesian, position]; }} 这段代码关键的 API 使用： worldToDrawingBufferCoordinates：将世界坐标转换为屏幕坐标 pickEllipsoid：将屏幕坐标转换回世界坐标 CallbackProperty：使连接线能够实时更新位置 重要技术点解析1. 坐标系转换实现可拖拽标签的一个关键技术点是在世界坐标系和屏幕坐标系之间进行转换： 世界坐标系：Cesium 中的 Cartesian3 坐标，表示三维空间中的位置 屏幕坐标系：二维像素坐标，表示元素在屏幕上的位置 拖拽交互发生在屏幕坐标系中，但连接线需要在世界坐标系中创建。代码中使用了两个关键方法实现这种转换： 1234567891011// 世界坐标 -&gt; 屏幕坐标const screenPosition = Cesium.SceneTransforms.worldToDrawingBufferCoordinates( viewer.scene, position);// 屏幕坐标 -&gt; 世界坐标const offsetCartesian = viewer.camera.pickEllipsoid( offsetScreenPosition, viewer.scene.globe.ellipsoid); 2. 处理视角变化当相机视角改变时，标签与目标之间的相对位置需要保持一致。代码通过监听相机变化事件来解决这个问题： 12// 监听相机变化事件viewer.scene.camera.changed.addEventListener(updateLine); 这确保了无论用户如何旋转、平移或缩放视图，连接线都能正确更新。 3. 像素偏移量使用像素偏移量（pixelOffset）而非直接修改实体位置，是实现拖拽的关键： 12entity2.billboard.pixelOffset = new Cesium.Cartesian2(0, -120);entity2.label.pixelOffset = new Cesium.Cartesian2(85, -198); 这样做的优势是： 标签实际位置仍然与目标位置绑定，保持关联 只有屏幕上的显示位置发生变化，便于计算连接线 当目标移动时标签会自动跟随，无需额外处理 总结通过 Cesium 的事件系统和坐标转换功能，我们成功实现了可拖拽的信息标签系统。这种交互方式大大提升了信息展示的灵活性和用户体验，特别适合于展示动态目标的详细信息。 实现可拖拽标签的核心技术包括： 使用自定义属性标记可拖拽实体 使用 ScreenSpaceEventHandler 捕获拖拽事件 使用像素偏移量调整标签位置 在世界坐标系和屏幕坐标系之间进行转换 创建动态连接线维持视觉关联","link":"/2025/03/21/cesium%E5%8F%AF%E6%8B%96%E6%8B%BD%E5%9B%BE%E6%A0%87/"},{"title":"cesium控制时间轴显示与隐藏","text":"在 Cesium 三维地球应用中，时间轴（Timeline）是一个强大的组件，它允许用户在时间维度上浏览和控制数据。然而，在某些场景下，我们可能希望根据应用需求动态控制时间轴的显示或隐藏。本文将详细介绍如何实现这一功能，并提供完整的代码示例和最佳实践。根据按钮的选中状态，设置时间轴容器的 CSS display 属性当按钮选中时，设置为 block，使时间轴显示当按钮未选中时，设置为 none，使时间轴隐藏注意需要修改 DOM 后可能不生效 需要强制触发 Cesium 时间轴的布局更新Viewer.timeline.resize()使用 setTimeout 异步调用 resize()方法，强制时间轴重新计算自身布局 12345678910timeLine(btn) { btn.checked = !btn.checked; Viewer.timeline.container.style.display = btn.checked ? &quot;block&quot; : &quot;none&quot;; if (btn.checked) { Viewer.timeline.container.style.bottom = &quot;40px&quot;; setTimeout(() =&gt; { Viewer.timeline.resize(); // 强制触发 Cesium 时间轴的布局更新 }, 0); } },","link":"/2025/03/16/cesium%E6%8E%A7%E5%88%B6%E6%97%B6%E9%97%B4%E8%BD%B4%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"title":"cesium封装限制相机范围接口","text":"Cesium 相机约束：实现自定义视角限制的完整方案在开发 Cesium 三维应用时，相机控制是用户交互体验的核心部分。有时我们需要限制用户的视角范围，比如在展示特定区域时防止用户迷失方向，或者在虚拟导览中保持合理的观察视角。本文将详细介绍如何在 Cesium 中实现相机约束，限制用户可以浏览的角度、高度和区域范围。 在三维 GIS 应用中，相机约束有多种实用场景： 导览体验优化：在虚拟导览中，限制视角可以提供更有引导性的体验 防止无效视角：避免用户旋转到奇怪的角度或者深入地下 聚焦关注区域：保持用户视线在特定区域内，突出重点 减少用户迷失：在大型场景中，限制可浏览范围防止用户迷失 场景性能优化：限制相机可以减少渲染和数据加载的范围，提升性能 相机约束的类型Cesium 的相机约束主要包括以下几种： 1. 俯仰角约束（Pitch）限制相机的上下俯仰角度，防止用户看到地下或转到不适合的角度。 2. 航向角约束（Heading）限制相机的水平旋转角度，控制用户可以环视的范围。 3. 缩放距离约束（Distance）限制相机与目标点的距离，控制用户可以放大和缩小的程度。 4. 高度约束（Height）限制相机距离地表的高度，防止用户飞得过高或过低。 5. 地理范围约束（Geographic Bounds）限制相机在特定地理区域内移动，确保用户不会飞离关注区域。 实现方案下面是一个完整的实现方案，通过扩展 Cesium 的 Camera 类，添加自定义的视角限制功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 限制相机范围 * @param {Object} [cameraVisionOptions] 限范围对象. */Camera.prototype.setCameraVision = function (cameraVisionOptions) { const scene = this._coreMap.scene; const camera = this._camera; if (cameraVisionOptions.limitDistance) { scene.screenSpaceCameraController.minimumZoomDistance = cameraVisionOptions.limitDistance[0]; scene.screenSpaceCameraController.maximumZoomDistance = cameraVisionOptions.limitDistance[1]; } this.preRenderListener = () =&gt; { const cameraPosition = camera.positionCartographic; const currentHeading = Cesium.Math.toDegrees(camera.heading); const currentPitch = Cesium.Math.toDegrees(camera.pitch); let needUpdate = false; let newHeading = currentHeading; let newPitch = currentPitch; let newHeight = cameraPosition.height; if (cameraVisionOptions.limitHeading) { if ( currentHeading &lt; cameraVisionOptions.limitHeading[0] || currentHeading &gt; cameraVisionOptions.limitHeading[1] ) { needUpdate = true; newHeading = Cesium.Math.clamp( currentHeading, cameraVisionOptions.limitHeading[0], cameraVisionOptions.limitHeading[1] ); } } if (cameraVisionOptions.limitPitch) { if ( currentPitch &lt; cameraVisionOptions.limitPitch[0] || currentPitch &gt; cameraVisionOptions.limitPitch[1] ) { needUpdate = true; newPitch = Cesium.Math.clamp( currentPitch, cameraVisionOptions.limitPitch[0], cameraVisionOptions.limitPitch[1] ); } } if (cameraVisionOptions.limitHeight) { if ( cameraPosition.height &lt; cameraVisionOptions.limitHeight[0] || cameraPosition.height &gt; cameraVisionOptions.limitHeight[1] ) { needUpdate = true; newHeight = Cesium.Math.clamp( cameraPosition.height, cameraVisionOptions.limitHeight[0], cameraVisionOptions.limitHeight[1] ); } } if (needUpdate) { camera.setView({ destination: Cesium.Cartesian3.fromRadians( cameraPosition.longitude, cameraPosition.latitude, newHeight ), orientation: { heading: Cesium.Math.toRadians(newHeading), pitch: Cesium.Math.toRadians(newPitch), roll: camera.roll, }, }); } if (cameraVisionOptions.center &amp;&amp; cameraVisionOptions.radius) { const centerCartesian = Cesium.Cartesian3.fromDegrees( cameraVisionOptions.center[0], cameraVisionOptions.center[1] ); const currentPosition = camera.position; const distance = Cesium.Cartesian3.distance(currentPosition, centerCartesian); if (distance &gt; cameraVisionOptions.radius) { const direction = Cesium.Cartesian3.normalize( Cesium.Cartesian3.subtract(currentPosition, centerCartesian, new Cesium.Cartesian3()), new Cesium.Cartesian3() ); const newPosition = Cesium.Cartesian3.multiplyByScalar( direction, cameraVisionOptions.radius, new Cesium.Cartesian3() ); Cesium.Cartesian3.add(centerCartesian, newPosition, newPosition); camera.position = newPosition; } } }; scene.preRender.addEventListener(this.preRenderListener);};/** * 取消相机限制 */Camera.prototype.removeCameraVision = function () { const scene = this._coreMap.scene; scene.screenSpaceCameraController.minimumZoomDistance = 1.0; scene.screenSpaceCameraController.maximumZoomDistance = Number.POSITIVE_INFINITY; if (this.preRenderListener) { this._coreMap.scene.preRender.removeEventListener(this.preRenderListener); this.preRenderListener = null; }}; 代码解析setCameraVision 方法这个方法用于设置相机约束，接受一个包含多种限制参数的配置对象： 距离限制设置： 1234if (cameraVisionOptions.limitDistance) { scene.screenSpaceCameraController.minimumZoomDistance = cameraVisionOptions.limitDistance[0]; scene.screenSpaceCameraController.maximumZoomDistance = cameraVisionOptions.limitDistance[1];} 这里直接使用 Cesium 内置的缩放距离限制属性，非常直观。 preRender 事件监听： 1234this.preRenderListener = () =&gt; { // 约束逻辑};scene.preRender.addEventListener(this.preRenderListener); 设置一个在每帧渲染前执行的监听器，这是实现动态约束的关键。 俯仰角和航向角约束： 1234567891011121314151617if (cameraVisionOptions.limitHeading) { if ( currentHeading &lt; cameraVisionOptions.limitHeading[0] || currentHeading &gt; cameraVisionOptions.limitHeading[1] ) { needUpdate = true; newHeading = Cesium.Math.clamp( currentHeading, cameraVisionOptions.limitHeading[0], cameraVisionOptions.limitHeading[1] ); }}if (cameraVisionOptions.limitPitch) { // 类似逻辑} 检查当前角度是否超出限制，如果是则计算新的合法角度。 高度约束： 123if (cameraVisionOptions.limitHeight) { // 类似逻辑} 限制相机的高度范围。 应用新视图： 1234567891011121314if (needUpdate) { camera.setView({ destination: Cesium.Cartesian3.fromRadians( cameraPosition.longitude, cameraPosition.latitude, newHeight ), orientation: { heading: Cesium.Math.toRadians(newHeading), pitch: Cesium.Math.toRadians(newPitch), roll: camera.roll, }, });} 如果需要更新，则设置新的相机视图。 地理范围约束： 1234if (cameraVisionOptions.center &amp;&amp; cameraVisionOptions.radius) { // 计算相机到中心点的距离 // 如果超出范围，强制相机返回到允许的最远距离} 这是一个圆形地理围栏，限制相机不能离开指定的圆形区域。 removeCameraVision 方法这个方法用于移除相机约束： 1234567891011Camera.prototype.removeCameraVision = function () { const scene = this._coreMap.scene; scene.screenSpaceCameraController.minimumZoomDistance = 1.0; scene.screenSpaceCameraController.maximumZoomDistance = Number.POSITIVE_INFINITY; if (this.preRenderListener) { this._coreMap.scene.preRender.removeEventListener(this.preRenderListener); this.preRenderListener = null; }}; 这里重置了缩放距离限制，并移除了 preRender 事件监听器，完全释放相机约束。 使用方法下面是几个使用示例： 示例 1：限制俯仰角和航向角12345678// 只允许向下30°到向上30°的俯仰角，以及0°到180°的航向角const pitchOnlyOptions = { limitPitch: [-30, 30], limitHeading: [0, 180],};// 应用约束viewer.camera.setCameraVision(pitchOnlyOptions); 示例 2：设置完整约束123456789101112// 设置完整的相机约束const fullConstraints = { limitPitch: [-45, 0], // 俯仰角限制（度） limitHeading: [-180, 180], // 航向角限制（度） limitDistance: [1000, 10000], // 缩放距离限制（米） limitHeight: [500, 5000], // 高度限制（米） center: [116.3912, 39.9073], // 限制区中心点经纬度（北京） radius: 50000, // 限制区域半径（米）};// 应用约束viewer.camera.setCameraVision(fullConstraints); 示例 3：创建虚拟导览123456789101112131415161718192021// 设置第一人称导览约束const tourConstraints = { limitPitch: [-10, 45], // 适合查看建筑物的俯仰角 limitHeight: [1.7, 100], // 人眼高度到较低空中视角 limitDistance: [0, 1000], // 近距离观察 center: [120.1551, 30.2741], // 西湖中心 radius: 3000, // 限制在西湖周围3公里};// 应用约束viewer.camera.setCameraVision(tourConstraints);// 设置初始视角viewer.camera.setView({ destination: Cesium.Cartesian3.fromDegrees(120.1551, 30.2741, 30), orientation: { heading: Cesium.Math.toRadians(45), pitch: Cesium.Math.toRadians(0), roll: 0, },}); 示例 4：移除约束12// 当需要恢复自由视角时，移除约束viewer.camera.removeCameraVision();","link":"/2025/03/20/cesium%E5%B0%81%E8%A3%85%E9%99%90%E5%88%B6%E7%9B%B8%E6%9C%BA%E8%8C%83%E5%9B%B4%E6%8E%A5%E5%8F%A3/"},{"title":"cesium点聚合点击扩散点位","text":"Cesium 实现点聚合点击扩散效果 在 Cesium 三维地图应用中，当需要展示大量点位数据时，点聚合(Point Clustering)是一种常用的可视化优化技术。然而，聚合后的点位如何高效地展示和交互，成为了一个关键问题。本文将介绍一种简洁而实用的解决方案：点击聚合点后，相机自动飞行并放大到合适的高度，实现聚合点的”扩散”效果，让用户可以清晰查看聚合点包含的所有单独点位。 问题背景在处理大规模点位数据时，点聚合技术可以有效减少渲染压力，提升应用性能。但这带来了新的交互挑战： 用户如何查看被聚合的详细点位？ 如何设计直观的交互方式展开聚合点？ 扩散后，如何让用户清晰地了解空间位置关系？ 传统的解决方案往往是点击后弹出列表，或者简单地取消聚合显示所有点位，这些方法要么缺乏空间关联性，要么容易产生视觉混乱。 解决方案我们设计了一种基于相机飞行的扩散效果：当用户点击聚合点时，应用会计算聚合点内所有点位的中心位置，然后控制相机飞行到该位置上方的适当高度，使得聚合点自然”扩散”为单独的点位。 这种方案的优势在于： 保持了空间上下文，用户不会迷失方向 交互方式直观，符合用户心智模型 视觉效果流畅，提供良好的用户体验 实现代码1. 点击事件处理首先，我们需要处理地图点击事件，判断用户是否点击了聚合点： 1234567891011// 点击聚合点扩散功能earthCtrl.pick((data, pickObject, movement) =&gt; { if (!pickObject) { return; } if (Array.isArray(pickObject.id) &amp;&amp; pickObject.id.length &gt; 1) { const clusteredEntities = pickObject.id; // 聚合点的所有实体 const rate = 4; // 缩放倍数 clusterLayer.expandCluster(clusteredEntities, rate); }}); 这段代码的关键点： 通过pick事件捕获用户点击 判断点击对象的 id 是否为数组且长度大于 1，这是 Cesium 中聚合点的典型特征 获取聚合点包含的所有实体，传递给扩散函数 设置缩放倍数，决定相机放大的程度 2. 扩散功能实现接下来，实现扩散函数，计算聚合点中心并控制相机飞行： 1234567891011121314151617181920212223/* * 点击扩散聚合点 * @param {*} clusteredEntities * @param {*} rate */ClusterLayer.prototype.expandCluster = function (clusteredEntities, rate = 4) { let totalLon = 0; let totalLat = 0; clusteredEntities.forEach(entity =&gt; { const position = entity.position.getValue(Cesium.JulianDate.now()); const cartographic = Cesium.Cartographic.fromCartesian(position); totalLon += Cesium.Math.toDegrees(cartographic.longitude); totalLat += Cesium.Math.toDegrees(cartographic.latitude); }); const centerLon = totalLon / clusteredEntities.length; const centerLat = totalLat / clusteredEntities.length; const currentHeight = this._viewer.camera.positionCartographic.height; const targetHeight = currentHeight / rate; this._viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, targetHeight), duration: 1.5, });}; 这段代码的实现细节： 遍历所有聚合实体，获取每个点的位置 计算所有点的经纬度平均值，作为聚合点的中心 获取当前相机高度，并根据缩放倍数计算目标高度 使用flyTo方法控制相机飞行到新位置，实现平滑的过渡效果 代码解析中心点计算逻辑聚合点中心的计算使用了简单的平均值： 12345678clusteredEntities.forEach(entity =&gt; { const position = entity.position.getValue(Cesium.JulianDate.now()); const cartographic = Cesium.Cartographic.fromCartesian(position); totalLon += Cesium.Math.toDegrees(cartographic.longitude); totalLat += Cesium.Math.toDegrees(cartographic.latitude);});const centerLon = totalLon / clusteredEntities.length;const centerLat = totalLat / clusteredEntities.length; 这里的关键操作： 使用position.getValue()获取当前时间点的位置值 将 Cartesian3 坐标转换为经纬度表示 累加所有点的经纬度值，最后求平均值 相机高度计算相机高度的计算基于当前视图高度和缩放比例： 12const currentHeight = this._viewer.camera.positionCartographic.height;const targetHeight = currentHeight / rate; 这种方式确保了缩放效果与当前视图状态相适应： 当用户在高空视图点击聚合点时，扩散后会显示中等范围 当用户在低空视图点击聚合点时，扩散后会显示更详细的局部区域 相机飞行控制最后，使用 Cesium 的飞行功能实现平滑过渡： 1234this._viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, targetHeight), duration: 1.5,}); destination参数指定目标位置，使用之前计算的中心点和高度 duration参数控制飞行动画的持续时间，1.5 秒提供了良好的平衡，既不会太慢导致用户等待，也不会太快导致视觉不连贯 总结点聚合点击扩散功能是一种简单而强大的交互设计，它既保留了点聚合带来的性能优势，又解决了聚合点信息查看的交互问题。通过控制相机的智能飞行，我们实现了自然流畅的扩散效果，让用户可以轻松地在不同层级之间进行探索。 这种实现方式代码量少，易于集成，同时可以根据实际需求进行各种优化和扩展。在处理大规模点位数据的 Cesium 应用中，这将成为一个非常实用的交互功能。","link":"/2025/03/21/cesium%E7%82%B9%E8%81%9A%E5%90%88%E7%82%B9%E5%87%BB%E6%89%A9%E6%95%A3%E7%82%B9%E4%BD%8D/"},{"title":"cesium实现限高分析","text":"Cesium ClassificationPrimitive Cesium 的 ClassificationPrimitive 是一个用于在三维场景中分类地表或其他几何体的工具。这种分类通常用于在现有的地表或模型上应用覆盖效果，比如标记特定区域、着色或其他视觉效果，用于突出显示某些特征或为特定应用添加信息层。 地表分类： ClassificationPrimitive 主要用于对地表进行分类处理，可以为地形或模型表面覆盖一层指定的材质或颜色，通常用于高亮、区分不同区域的用途。 与现有几何体的交互： 它能够与地形、3D Tiles 或其他几何图形结合使用，提供了一种方法来在这些图形上绘制或标记数据，而不修改原始数据。 高度自定义的视觉效果： 支持自定义的材质和着色方式，可以通过指定的Appearance对象来定义如何渲染覆盖层，包括但不限于使用 GLSL 着色器来创建复杂的视觉效果。 ClassificationPrimitive 可用于高亮显示特定区域，如城市规划区、受保护地区等 12345678910111213141516171819202122232425RestrictHeight.prototype.addToMap = function () { this.removeFromMap(); if (!this.positions) { return; } const positions = Cesium.Cartesian3.fromDegreesArray(this.positions); const polygonInstance = new Cesium.GeometryInstance({ geometry: new Cesium.PolygonGeometry({ polygonHierarchy: new Cesium.PolygonHierarchy(positions), height: this.baseHeight, extrudedHeight: this.baseHeight + this.extrudedHeight, }), attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor(this.color), }, }); this.limitHeightPrimitive = this._coreMap.scene.primitives.add( new Cesium.ClassificationPrimitive({ geometryInstances: polygonInstance, releaseGeometryInstances: false, classificationType: Cesium.ClassificationType.CESIUM_3D_TILE, }) );};","link":"/2025/03/16/cesium%E5%AE%9E%E7%8E%B0%E9%99%90%E9%AB%98%E5%88%86%E6%9E%90/"},{"title":"cesium烟雾粒子设置风速和风向","text":"Cesium 实现烟雾粒子效果及风向风速控制 在三维 GIS 应用中，烟雾效果是一种常见的环境特效，可用于模拟工厂排放、火灾现场、火山活动等场景。通过 Cesium 的粒子系统(ParticleSystem)，我们可以实现逼真的烟雾效果，并且通过添加风速和风向参数来控制烟雾的飘动方向，使其更符合实际场景。本文将详细介绍如何在 Cesium 中实现一个可控制风速和风向的烟雾粒子效果。通过本文介绍的方法，我们可以实现以下效果： 在地图上指定位置创建烟雾粒子 控制烟雾的大小、颜色、密度等参数 设置风速和风向，使烟雾按照指定方向飘动 实时调整烟雾的各项参数 基本原理Cesium 的粒子系统(ParticleSystem)提供了强大的粒子效果生成能力，它通过控制粒子的生命周期、大小、颜色、运动轨迹等参数来模拟各种特效。我们可以使用它的以下特性来实现烟雾效果： 发射器(Emitter): 用锥形发射器模拟烟囱排放 粒子生命周期: 控制粒子从生成到消失的过程 颜色渐变: 从深色到浅色模拟烟雾扩散 大小变化: 粒子从小到大模拟烟雾扩散 速度控制: 设置粒子的初始速度和变化 更新回调: 通过 updateCallback 添加风向和风速影响 使用方法12345678earthCtrl.factory.createSmoke({ lon: 117.15552507924421, lat: 31.833227044869062, alt: 0, heading: 3.7577140651352736, windSpeed: 0.1, windDirection: 0, // 传的是角度，0是正北， 90是从东向西， 180是正南，270是从西向东}); 参数说明： lon、lat、alt: 烟雾在地球上的位置（经度、纬度、高度） heading: 烟雾发射方向的偏航角，单位为弧度 windSpeed: 风速，影响烟雾飘动的速度 windDirection: 风向，单位为角度，0 表示北风（从北向南吹），90 表示东风（从东向西吹），依此类推 实现原理详解1. 风向与风速的计算风向风速的核心是将角度和速度值转换为三维空间中的矢量： 12345678const windSpeed = this._windSpeed;const windDirection = (this._windDirection - Cesium.Math.toDegrees(this._heading)) % 360;const windDirectionRadians = Cesium.Math.toRadians(windDirection);const windVector = new Cesium.Cartesian3( Math.cos(windDirectionRadians) * windSpeed, Math.sin(windDirectionRadians) * windSpeed, 0); 这里需要注意几点： 风向角度需要考虑烟雾本身的 heading 角度，所以要进行减法运算 角度需要转换为弧度以便进行三角函数计算 最终得到的是一个三维向量，表示风的方向和大小 2. 粒子更新回调的应用风的效果是通过粒子系统的 updateCallback 回调函数实现的： 123updateCallback: (particle, dt) =&gt; { particle.velocity = Cesium.Cartesian3.add(particle.velocity, windVector, new Cesium.Cartesian3());}; 在每一帧更新时，将风向矢量添加到粒子的速度向量上，使粒子的运动轨迹受到风的影响。 3. 发射器位置与朝向烟雾的发射器采用锥形(ConeEmitter)，并且需要设置一个合适的位置和朝向： 12345678function computeEmitterModelMatrix() { const hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0); const trs = new Cesium.TranslationRotationScale(); trs.translation = Cesium.Cartesian3.fromElements(2.5, 4, 1); trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr); const result = Cesium.Matrix4.fromTranslationRotationScale(trs); return result;} 参数调优要实现更真实的烟雾效果，需要调整以下关键参数： 1. 颜色参数12startColor: Cesium.Color.fromRgba(0xcc333333), // 粒子出生时的颜色endColor: Cesium.Color.fromRgba(0x44cccccc), // 当粒子死亡时的颜色 烟雾初始颜色通常较深，透明度较高 结束颜色较淡，透明度降低，模拟烟雾扩散 2. 大小参数12startScale: 1.0, // 粒子出生时的比例endScale: 4.0, // 粒子在死亡时的比例 从小到大的变化模拟烟雾扩散过程 合适的比例可以创造更自然的效果 3. 生命周期参数12minimumParticleLife: 1.0, // 粒子寿命的最小值(秒)maximumParticleLife: 6.0, // 粒子寿命的最大值(秒) 较长的生命周期可以让烟雾飘得更远 最小最大值的差距可以创造不均匀的效果 4. 速度参数12minimumSpeed: 5.0, // 粒子的最小速度(米/秒)maximumSpeed: 20.0, // 粒子的最大速度(米/秒) 速度会影响烟雾上升和扩散的速率 风速会在此基础上叠加影响 完整代码实现以下是烟雾效果的完整实现代码，包括风向风速控制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256/** * @alias Smoke * @classdesc 烟雾效果类 * @desc Effect */class Smoke extends SpatialObject { /** * 构造方法 * @param {EarthCtrl} earthCtrl 地图控件 * @param {Object} options 创建参数 * @param {String} [options.id] 对象的唯一id * @param {String} [options.name] 对象的名字 * @param {Number} [options.lon] 对象的经度 * @param {Number} [options.lat] 对象的纬度 * @param {Number} [options.alt] 对象的高程 * @param {Number} [options.particleSize] 粒子的大小，默认是30 * @param {Number} [options.heading] 地图中设置的偏航角，弧度，默认是0 * @param {Number} [options.windSpeed] 风速，默认是0 * @param {Number} [options.windDirection] 风向，默认是0 * @see ObjectFactory#createSmoke */ constructor(earthCtrl, options) { super(earthCtrl, options); this._rtti = &quot;Smoke&quot;; this._primitive = null; this._parameter = options; this._spatialTransform.createFromWgs84( options.lon, options.lat, options.alt, options.heading, options.pitch, options.roll ); this._coreMap = earthCtrl.coreMap; this._windSpeed = options.windSpeed || 0; this._windDirection = options.windDirection || 0; this._heading = options.heading || 0; } addToMap() { const parameter = this._parameter; const coreMap = this._coreMap; function computeEmitterModelMatrix() { const hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0); const trs = new Cesium.TranslationRotationScale(); trs.translation = Cesium.Cartesian3.fromElements(2.5, 4, 1); trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr); const result = Cesium.Matrix4.fromTranslationRotationScale(trs); return result; } const windSpeed = this._windSpeed; const windDirection = (this._windDirection - Cesium.Math.toDegrees(this._heading)) % 360; const windDirectionRadians = Cesium.Math.toRadians(windDirection); const windVector = new Cesium.Cartesian3( Math.cos(windDirectionRadians) * windSpeed, Math.sin(windDirectionRadians) * windSpeed, 0 ); console.log(`Wind Direction: ${windDirection} degrees`); console.log(`Wind Vector: ${windVector.x}, ${windVector.y}, ${windVector.z}`); const particleSize = Cesium.defaultValue(parameter.particleSize, 30.0); const primitive = coreMap.scene.primitives.add( new Cesium.ParticleSystem({ //image: Cesium.defaultValue(parameter.image, &quot;./Assets/image/smoke.png&quot;), image: Cesium.defaultValue( parameter.image, `${globalThis.GEOWORLD_BASE_URL}Assets/Images/smoke.png` ), startColor: Cesium.defaultValue(parameter.startColor, Cesium.Color.fromRgba(0xcc333333)), //粒子出生时的颜色 endColor: Cesium.defaultValue(parameter.endColor, Cesium.Color.fromRgba(0x44cccccc)), //当粒子死亡时的颜色 startScale: Cesium.defaultValue(parameter.startScale, 1.0), //粒子出生时的比例，相对于原始大小 endScale: Cesium.defaultValue(parameter.endScale, 4.0), //粒子在死亡时的比例 minimumParticleLife: Cesium.defaultValue(parameter.minimumParticleLife, 1.0), //设置粒子寿命的可能持续时间的最小界限（以秒为单位），粒子的实际寿命将随机生成 maximumParticleLife: Cesium.defaultValue(parameter.maximumParticleLife, 6.0), //设置粒子寿命的可能持续时间的最大界限（以秒为单位），粒子的实际寿命将随机生成 minimumSpeed: Cesium.defaultValue(parameter.minimumSpeed, 5.0), //设置以米/秒为单位的最小界限，超过该最小界限，随机选择粒子的实际速度。 maximumSpeed: Cesium.defaultValue(parameter.maximumSpeed, 20.0), //设置以米/秒为单位的最大界限，超过该最大界限，随机选择粒子的实际速度。 imageSize: new Cesium.Cartesian2(particleSize, particleSize), //如果设置该属性，将会覆盖 minimumImageSize和maximumImageSize属性，以像素为单位缩放image的大小 emissionRate: Cesium.defaultValue(parameter.emissionRate, 10.0), //每秒发射的粒子数。 bursts: [], lifetime: Cesium.defaultValue(parameter.lifeTime, 16.0), //多长时间的粒子系统将以秒为单位发射粒子 emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(30.0)), //此系统的粒子发射器 共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类 modelMatrix: this._spatialTransform.modelMatrix, // 4x4转换矩阵，可将粒子系统从模型转换为世界坐标 emitterModelMatrix: computeEmitterModelMatrix(), // 4x4转换矩阵，用于在粒子系统本地坐标系中转换粒子系统发射器 updateCallback: (particle, dt) =&gt; { particle.velocity = Cesium.Cartesian3.add( particle.velocity, windVector, new Cesium.Cartesian3() ); }, }) ); this._primitive = primitive; } /** * 从地图中移除 * @method * */ removeFromMap() { if (this._primitive !== null) { this._coreMap.scene.primitives.remove(this._primitive); } } toJSON() { const that = this; return ExportObject.export(that); }}Object.defineProperties(Smoke.prototype, { /** * 烟雾的参数 * @type Object * @memberof Smoke.prototype * @readonly */ parameter: { get: function () { return this._parameter; }, }, /** * 是否显示 * @type Boolean * @memberof Smoke.prototype * */ show: { get: function () { if (this._primitive !== null) { return this._primitive.show; } return false; }, set: function (val) { if (this._primitive !== null) { this._primitive.show = val; } }, }, /** * 名称 * @type String * @memberof Smoke.prototype * */ name: { get: function () { if (this._parameter !== null) { return this._parameter.name; } return false; }, set: function (val) { if (this._parameter !== null) { this._parameter.name = val; } }, }, /** * 经度 * @type Number * @memberof Smoke.prototype * */ lon: { get: function () { if (this._parameter !== null) { return this._lon; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._lon === val) { return; } this._parameter.lon = val; this._spatialTransform.createFromWgs84( this._parameter.lon, this._parameter.lat, this._parameter.alt, this._parameter.heading, this._parameter.pitch, this._parameter.roll ); this._primitive.modelMatrix = this._spatialTransform.modelMatrix; } }, }, /** * 纬度 * @type Number * @memberof Smoke.prototype * */ lat: { get: function () { if (this._parameter !== null) { return this._lat; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._lat === val) { return; } this._parameter.lat = val; this._spatialTransform.createFromWgs84( this._parameter.lon, this._parameter.lat, this._parameter.alt, this._parameter.heading, this._parameter.pitch, this._parameter.roll ); this._primitive.modelMatrix = this._spatialTransform.modelMatrix; } }, }, /** * * 粒子大小 * @type Number * @memberof Smoke.prototype * */ particleSize: { get: function () { if (this._primitive !== null) { return this._primitive.particleSize; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._parameter.particleSize === val) { return; } this._parameter.particleSize = val; this._primitive.imageSize = new Cesium.Cartesian2( this._parameter.particleSize, this._parameter.particleSize ); } }, },});export default Smoke; 总结通过 Cesium 的粒子系统，结合风向和风速的控制，我们实现了一个真实而灵活的烟雾效果。该效果不仅可以模拟静态烟雾，还可以根据风的参数动态调整烟雾的飘动方向和速度，适用于各种需要烟雾效果的场景。 关键技术点回顾： 使用 Cesium.ParticleSystem 创建基础粒子系统 通过风向角度和风速值计算风向矢量 在 updateCallback 中将风向矢量添加到粒子速度中 通过参数控制烟雾的颜色、大小、生命周期等特性","link":"/2025/03/16/cesium%E7%83%9F%E9%9B%BE%E7%B2%92%E5%AD%90%E8%AE%BE%E7%BD%AE%E9%A3%8E%E9%80%9F%E5%92%8C%E9%A3%8E%E5%90%91/"},{"title":"光栅化","text":"光栅化 前边的部分我们学习了MVP矩阵，如何把一个物体投影到一个规则立方体内([-1,1]3)，如何把这个规则立方体内点的物体投影在屏幕上，转变为二维图像，这就是光栅化的过程、 屏幕 把东西画在屏幕上 当进行完 MVP 变换之后，所有需要绘制的点都变换到 的立方体空间中了。 下一步工作就是要把结果绘制到屏幕上，在这之前先了解一下什么是屏幕。 屏幕由一系列的像素(Pixel，是 Picture element 的缩写)排布形成，像素的数量由分辨率决定，如分辨率是 1920 x 1080 的屏幕，就包含了 1920 x 1080 个像素。 每个像素表示的颜色由红（red）、绿（green）、蓝（blue）三种颜色混合而成。 抗锯齿 MSAA (多重采样抗锯齿) 事实上，刚刚提到的计算像素覆盖面积的做法是很难实现的。但我们可以通过超采样的方式来模拟。 所谓的超采样，是指在一个像素里面放多个采样点来检测三角形是否有被覆盖。 :::color2MSAA 是抗锯齿操作的第一步，也就是模糊操作（求平均）。 MSAA 增加采样点，并不是为了提高采样率（分辨率没有提高），而是为了得到一个更合理的三角形覆盖率。 MSAA 的代价是计算量大增，如果一个像素里面有 4 个采样点，那么计算量就大了 4 倍；如果一个像素里面有 16 个采样点，那么计算量就大了 16 倍。（事实上，工业界会会复用、优化这些采样点，因此计算量并没有增加太多）。 ::: :::color2工作原理： 对每个像素进行多个采样点采样 计算采样点被物体覆盖的比例 根据比例决定最终像素颜色 优点： 图像质量好，特别是对几何边缘 没有时间性模糊问题 缺点： 性能开销大（采样点越多开销越大） 只对几何边缘有效，对材质/着色器内部产生的锯齿无效 ::: FXAA (快速近似抗锯齿) :::color2工作原理： 是后处理抗锯齿技术 在渲染完成后检测画面中的边缘 对检测到的边缘进行模糊处理 优点： 性能开销小 能处理所有类型的锯齿（包括着色器产生的） 缺点： 可能会使画面整体略显模糊 可能会丢失一些细节 ::: :::color2快速近似抗锯齿（Fast Approximate Anti-Aliasing，简称 FXAA）：大致上来说，该方法是在得到最终图像后的一种处理，通过分析最终得到的图像，找到锯齿边缘，通过柔化、模糊等方式处理锯齿边缘，降低锯齿的可视性，来达到抗锯齿的目的。FXAA 具有消耗低，速度快的优点。 ::: Cesium 默认使用的是 FXAA (Fast Approximate Anti-aliasing)。可以通过以下代码启用/禁用 FXAA： 选择 FXAA 的原因： 性能开销小，适合 Web 场景的实时渲染 实现简单，作为后处理技术易于集成 对 WebGL 支持良好，兼容性强 足以满足大多数地理可视化场景的需求 TAA (时间抗锯齿)、 :::color2 工作原理： 利用前面几帧的信息 在时间维度上进行采样和混合 通过抖动采样模式获取子像素信息 优点： 图像质量很好 性能开销适中 可以处理半透明物体和细节 缺点： 在运动场景中可能产生拖影 需要额外存储前帧信息 实现复杂度高 ::: :::color2 MSAA：追求画质、性能够用的场景 FXAA：追求性能、对画质要求不是特别高的场景 TAA：现代游戏引擎的主流选择，平衡了质量和性能 ::: :::color2时间性抗锯齿（Temporal Anti-Aliasing，简称 TAA）：和一般的抗锯齿对像素的采样不同，TAA 是对时间的采样，将上一帧已经得到的结果，作为当前帧的参考，避免直接计算当前帧像素的颜色值，而是复用或着说参考像素在之前帧的颜色值。会导致画面比较模糊，且对于运动的物体效果会很不好。TAA 有升级版，即 TXAA，实际为 TAA+MSAA 的组合。 ::: 重心坐标插值 ![](https://cdn.nlark.com/yuque/0/2025/png/276041/1737556826723-d1522d16-c7f8-4e03-8669-9e307419150b.png) 当顶点在纹理上的对应 uv 坐标成功找到之后，三角形三个顶点中间的值需要用三角形的重心坐标插值计算得到 插值的运算不仅仅在纹理中，包括三角形内部的颜色和法线都可以用插值来计算并由此得到一个平滑的过度。 满足这个说明点 p 在三角形内 这是求出了 p 点的纹理坐标 重心坐标(Barycentric Coordinates)是在计算机图形学中用于在三角形内部进行插值的一种技术。它的基本思想是：三角形内的任意一点都可以用三个权重来表示，这些权重表示了该点受三角形三个顶点的影响程度。 基本定义 假设有一个三角形 ABC，内部任意一点 P 可以表示为：P = αA + βB + γC ,其中 α + β + γ = 1，且 α,β,γ ≥ 0 α = Area(PBC)/Area(ABC) β = Area(PCA)/Area(ABC) γ = Area(PAB)/Area(ABC) 重心坐标的表示就是(α,β,γ),如 A 点的重心坐标就是(1,0,0)。那么如何确定任意一点的重心坐标呢？这里要通过面积比来算，如上图中一点的坐标，α,β,γ 各个值就是另两个顶点连成的三角形在总面积的占比，如上图所示。 因为 ACA 的面积是 0， 所以 A 点的 β 是 0 而通过如上的表示，我们马上可以找到一个及其特殊的点，就是三角形自己的重心，它的重心坐标是(1/3,1/3,1/3)，这个点与三个顶点连线分成的三个三角形面积也恰好相等。 上图为对于三角形内任意一点的重心坐标计算的通用表达式 通过以上的介绍，我们知道了三角形内部的任意一点的坐标可以通过重心坐标求出表示出来，那么我们也可以利用重心坐标求三角形内部任意一点的其它属性，其他三角形内部的属性也可以用重心坐标的线性组合表示出来，如上图的颜色插值。（注意：重心坐标并没有投影下不变的性质，所以在插值如深度这种空间中的性质时，应该先在 3D 空间中用三维的坐标算出三维空间中的重心坐标进行插值，然后再放回而不能直接在投影之后的三角形中做插值。至于如何在已经投影的三角形在回到三维空间，应用逆变换即可。） 12345// 假设三个顶点都有颜色属性Color interpolatedColor = α * colorA + β * colorB + γ * colorC;// 纹理坐标插值UV interpolatedUV = α * uvA + β * uvB + γ * uvC;","link":"/2025/03/15/%E5%85%89%E6%A0%85%E5%8C%96/"}],"tags":[{"name":"cesium","slug":"cesium","link":"/tags/cesium/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"categories":[{"name":"cesium","slug":"cesium","link":"/categories/cesium/"},{"name":"图形学","slug":"图形学","link":"/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"pages":[]}