{"posts":[{"title":"Cesium 自定义 Primitive 实现三角形绘制","text":"在 Cesium 开发中，有时我们需要自定义图形来满足特定的可视化需求。本文将介绍如何通过继承 Cesium 的 Primitive 类来实现自定义三角形绘制，并深入解析 WebGL 底层实现原理。 基本原理Cesium 提供了丰富的可视化组件，但有些特殊场景下需要我们直接操作 WebGL 来实现定制化的图形渲染。自定义 Primitive 允许我们直接使用 WebGL 着色器程序来控制顶点数据和渲染流程。 代码实现 下面是一个完整的示例，展示如何创建自定义 Primitive 来绘制一个三角形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Cesium自定义Primitive实现三角形绘制&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./Cesium-1.107.1/Cesium//Widgets/widgets.css&quot; /&gt; &lt;script src=&quot;./Cesium-1.107.1//Cesium/Cesium.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html, body { width: 100%; height: 100%; } #cesiumContainer { width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt; &lt;script&gt; Cesium.Ion.defaultAccessToken = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlMTk4ZTYyNy00MjkxLTRmZWYtOTg1MS0wOThjM2YzMzIzYzEiLCJpZCI6NzEyMSwic2NvcGVzIjpbImFzciIsImdjIl0sImlhdCI6MTU0ODMxNzI5OX0.rKV8Ldl_bgR3lVvNsbHhTX62j8JH8ADCIWAwk7tXpr8&quot;; class CustomPrimitive extends Cesium.Primitive { constructor(options) { super(options); const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0); const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); this._modelMatrix = modelMatrix; } createCommand = (frameState, modelMatrix) =&gt; { const context = frameState.context; const positionBuffer = Cesium.Buffer.createVertexBuffer({ context: context, typedArray: new Float32Array([ 100000, 500000, 50000, -200000, -100000, 50000, 500000, -300000, 50000, ]), usage: Cesium.BufferUsage.STATIC_DRAW, // STATIC_DRAW则表示此缓冲数据平常不咋动 }); const attributes = [ { index: 0, enabled: true, vertexBuffer: positionBuffer, componentsPerAttribute: 3, componentDatatype: Cesium.ComponentDatatype.FLOAT, normalize: false, offsetInBytes: 0, strideInBytes: 0, // tightly packed instanceDivisor: 0, // not instanced }, ]; const vertexArray = new Cesium.VertexArray({ context: context, attributes: attributes, }); const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); } `; const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); } `; const attributeLocations = { position: 0, }; const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations, }); const renderState = Cesium.RenderState.fromCache({ depthTest: { enabled: true, }, }); return new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: vertexArray, shaderProgram: shaderProgram, renderState: renderState, pass: Cesium.Pass.OPAQUE, // Cesium 中用于渲染顺序的一个参数 }); }; update = frameState =&gt; { const command = this.createCommand(frameState, this._modelMatrix); frameState.commandList.push(command); }; } const viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;); const customPrimitive = new CustomPrimitive(); viewer.scene.primitives.add(customPrimitive); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码解析1. 自定义 Primitive 类我们通过继承Cesium.Primitive类创建自定义图元： 12345678910class CustomPrimitive extends Cesium.Primitive { constructor(options) { super(options); const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0); const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); this._modelMatrix = modelMatrix; } // ...其他方法} 在构造函数中，我们设置了图元的位置（上海的经纬度坐标）并创建了模型矩阵。 2. 创建顶点缓冲区1234567const positionBuffer = Cesium.Buffer.createVertexBuffer({ context: context, typedArray: new Float32Array([ 100000, 500000, 50000, -200000, -100000, 50000, 500000, -300000, 50000, ]), usage: Cesium.BufferUsage.STATIC_DRAW,}); 这里我们定义了三角形的三个顶点坐标，每个顶点包含 X、Y、Z 三个值。使用STATIC_DRAW表示这些数据不会频繁更改。 3. 设置顶点属性123456789101112131415161718const attributes = [ { index: 0, enabled: true, vertexBuffer: positionBuffer, componentsPerAttribute: 3, componentDatatype: Cesium.ComponentDatatype.FLOAT, normalize: false, offsetInBytes: 0, strideInBytes: 0, instanceDivisor: 0, },];const vertexArray = new Cesium.VertexArray({ context: context, attributes: attributes,}); 这部分代码配置了顶点属性，指定了顶点数据的格式和布局。 4. 着色器程序12345678910111213141516const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); }`;const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); }`; 着色器程序包含： 顶点着色器：处理每个顶点的位置变换 片段着色器：设置三角形的颜色（这里是黄色：RGB(1.0, 1.0, 0.0)） 5. 创建绘制命令1234567return new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: vertexArray, shaderProgram: shaderProgram, renderState: renderState, pass: Cesium.Pass.OPAQUE,}); 绘制命令将所有元素组合起来，告诉 Cesium 引擎如何渲染我们的三角形。 6. 更新函数1234update = frameState =&gt; { const command = this.createCommand(frameState, this._modelMatrix); frameState.commandList.push(command);}; 每一帧都会调用update方法，它创建绘制命令并将其添加到 Cesium 的命令列表中。 关键概念解释 Primitive（图元）：Cesium 中的基本渲染单元，代表一组具有相同渲染状态的几何图形。 VertexArray（顶点数组）：存储顶点数据和属性配置的对象。 ShaderProgram（着色器程序）：包含顶点着色器和片段着色器的程序，用于处理顶点和像素的渲染。 DrawCommand（绘制命令）：告诉 Cesium 如何渲染一个图元的指令。 modelMatrix（模型矩阵）：用于将局部坐标转换为世界坐标的矩阵。 如何扩展这个示例只是绘制了一个简单的三角形，但您可以通过以下方式扩展它： 添加颜色变化：修改片段着色器为每个顶点设置不同的颜色，并在顶点之间进行插值。 添加纹理：为三角形添加纹理映射。 实现动画效果：通过在每一帧修改顶点位置实现动画。 添加交互功能：实现点击选中、拖拽等交互功能。 总结通过自定义 Primitive，我们可以在 Cesium 中绘制任何想要的几何图形，充分发挥 WebGL 的强大功能。虽然 Cesium 提供了许多高级组件，但了解底层原理可以帮助我们实现更加定制化的可视化效果。","link":"/2025/03/16/cesium%20drawcommand%20%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/"},{"title":"ccesium drawcommand介绍","text":"DrawCommand 是 Cesium 渲染器的核心类，常用的接口 Entity、Primitive、Cesium3DTileSet，以及地形和影像的渲染等等，底层都是一个个 DrawCommand 完成的。在进行扩展开发、视觉特效提升、性能优化、渲染到纹理（RTT），甚至基于 Cesium 封装自己的开发框架，定义独家数据格式等等，都需要开发人员对 DrawCommand 熟练掌握。而这部分接口，Cesium 官方文档没有公开，网上的相关资料也比较少，学习起来比较困难，所以接下来我们用几期文章，由浅入深，实用为主，力求全面地介绍 DrawCommand 及相关类的运用。 一个基本的 DrawCommand 至少包含： vertexArray ：顶点数组，向 GPU 传递顶点属性、索引（可选的）数组等几何信息； shaderProgram ：着色器程序对象，负责编译、链接顶点着色器（vertexShader）、片元着色器（fragmentShader）； renderState ：渲染状态对象，封装如深度测试（depthTest）、剔除（cull）、混合（blending）等状态类型的参数设置； pass ：渲染通道，Cesium 提供的常用渲染通道（封装在 Cesium.Pass）有： ENVIRONMENT：环境，如天空盒（星空背景） COMPUTE ：用于并行加速计算 GLOBE ：地形瓦片等 TERRAIN_CLASSIFICATION ：地形分类 CESIUM_3D_TILE ：3D Tiles 瓦片 CESIUM_3D_TILE_CLASSIFICATION ：3D Tiles 分类（单体化） OPAQUE ：不透明物体 TRANSLUCENT ：半透明物体 ::: :::color1modelMatrix：模型变换矩阵，用于指定所绘制物体的参考系，包括位置、旋转、缩放三方面参数。如果不设置，则参考系为世界坐标系，原点在地球球心 ::: 12const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0);const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); :::color1uniformMap ：用于传递 uniform 具体的值，是一个回调函数字典对象，key 是 uniform 变量名，value 是回调函数，回调函数的返回值可以是： ::: :::color1vertexArray 顶点数组的创建有多种方法，通常可以将几何数据用 Cesium.Geometry 来表达，然后用 Cesium.VertexArray.fromGeometry 可以用更少代码量完成创建 ::: attributeLocations ：顶点属性索引，key 为属性名称，value 为顶点属性缓冲区在同一个着色器程序中的索引，相当于将 js 中的顶点数组，传递到 shader 中的 attribute 变量。在后面创建 shaderProgram 时还需要用到； context：从 Primitive.update 方法的 frameState 参数中获取； geometry：Cesium.Geometry，Cesium 自带的几何类型都提供一个静态方法 createGeometry 来生成这个类型的几何对象 :::color1着色器程序，负责编译、链接顶点着色器（vertexShader）、片元着色器（fragmentShader）, ::: 12345678910111213141516171819202122232425const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); } `;const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); } `;const attributeLocations = { position: 0,};const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations,}); :::color1uniformMap 用于传递自定义 uniform 变量的值，是一个回调函数字典对象，key 是 uniform 变量名，value 是回调函数 ::: :::color1renderState 渲染状态对象，封装如深度测试（depthTest）、剔除（cull）、混合（blending）等状态类型的参数设置 ::: 12345const renderState = Cesium.RenderState.fromCache({ depthTest: { enabled: true, },}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899链接：https://zhuanlan.zhihu.com/p/453880906class MyPrimitive { constructor(modelMatrix) { this.modelMatrix = modelMatrix || Cesium.Matrix4.IDENTITY.clone() this.drawCommand = null; } /** * 创建 DrawCommand * @param {Cesium.Context} context */ createCommand(context) { var modelMatrix = this.modelMatrix; var box = new Cesium.BoxGeometry({ vertexFormat: Cesium.VertexFormat.POSITION_ONLY, maximum: new Cesium.Cartesian3(250000.0, 250000.0, 250000.0), minimum: new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0) }); var geometry = Cesium.BoxGeometry.createGeometry(box); var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry) var va = Cesium.VertexArray.fromGeometry({ context: context, geometry: geometry, attributeLocations: attributeLocations }); var vs = ` attribute vec3 position; void main(){ gl_Position = czm_projection * czm_modelView * vec4( position , 1. ); } `; var fs = ` uniform vec3 color; void main(){ gl_FragColor=vec4( color , 1. ); } `; var shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vs, fragmentShaderSource: fs, attributeLocations: attributeLocations }) var uniformMap = { color() { return Cesium.Color.GRAY } } var renderState = Cesium.RenderState.fromCache({ cull: { enabled: true, face: Cesium.CullFace.BACK }, depthTest: { enabled: true } }) this.drawCommand = new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: va, shaderProgram: shaderProgram, uniformMap: uniformMap, renderState: renderState, pass: Cesium.Pass.OPAQUE }) } /** * 实现Primitive接口，供Cesium内部在每一帧中调用 * @param {Cesium.FrameState} frameState */ update(frameState) { if (!this.drawCommand) { this.createCommand(frameState.context) } frameState.commandList.push(this.drawCommand) }}var viewer=new Cesium.Viewer('cesiumContainer');viewer.scene.globe.depthTestAgainstTerrain = true;var origin = Cesium.Cartesian3.fromDegrees(106, 26, 250000 / 2)var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin)var primitive = new MyPrimitive(modelMatrix);viewer.scene.primitives.add(primitive)","link":"/2025/03/16/cesium%20drawcommand/"},{"title":"cesium indexDB缓存模型","text":"Cesium 3D Tiles 缓存技术：使用 IndexedDB 和 localforage 提升加载性能 在 Cesium 开发过程中，3D Tiles 模型加载是一个常见的性能瓶颈。尤其是当 3D 模型较大或网络条件不佳时，重复加载相同的模型会浪费带宽并降低用户体验。本文介绍如何利用浏览器的 IndexedDB 和 localforage 库来实现 Cesium 3D Tiles 的本地缓存，显著提升加载性能和用户体验。 技术原理我们将通过以下技术和方法实现 3D Tiles 缓存： localforage：一个优秀的客户端存储库，提供简单 API 同时支持 IndexedDB、WebSQL 和 localStorage IndexedDB：浏览器提供的大容量客户端存储技术，支持存储二进制数据 拦截 XHR 请求：重写 Cesium 的 XHR 实现，在请求前检查缓存，在响应后保存缓存 接下来，让我们逐步分解这个解决方案的实现过程。 1. 缓存控制器的设计与实现首先，我们创建一个缓存控制器，负责管理缓存的存储、读取和规则定义： 12345678910111213141516171819202122// 初始化缓存控制器const initCacheController = () =&gt; { // 初始化 IndexedDB 存储实例 cacheController.instance = localforage.createInstance({ name: &quot;CesiumNetworkPlug&quot; }); // 缓存规则列表 cacheController.ruleList = new Set(); // 添加要缓存的 URL 模式（这里是 3DTiles 相关的） cacheController.ruleList.add(&quot;https://resource.dvgis.cn/data/3dtiles/dayanta/&quot;); // 匹配您的模型 URL // 判断 URL 是否需要缓存 cacheController.judgeUrl = url =&gt; { let needCache = false; [...cacheController.ruleList].forEach(rule =&gt; { needCache = needCache || url.indexOf(rule) &gt; -1 || rule === &quot;*&quot;; }); return needCache; }; // ...其他方法}; 这段代码完成以下工作： 创建一个名为”CesiumNetworkPlug”的 localforage 实例 创建 URL 规则列表（可以添加多个规则） 提供判断 URL 是否需要缓存的方法 2. 缓存读写与管理功能接下来，实现缓存的基本操作函数： 1234567891011121314151617181920212223242526// 获取缓存项cacheController.getItem = async key =&gt; { return await cacheController.instance.getItem(key);};// 设置缓存项cacheController.setItem = async (key, value) =&gt; { if (value instanceof XMLDocument) return false; try { let keyObj = JSON.parse(key); if (cacheController.judgeUrl(keyObj.url) &amp;&amp; key &amp;&amp; value) { await cacheController.instance.setItem(key, value); return true; } } catch (e) { console.error(&quot;缓存存储错误:&quot;, e); } return false;};// 清除所有缓存cacheController.clear = async () =&gt; { await cacheController.instance.clear(); console.log(&quot;缓存已清除&quot;);}; 这些方法提供了: 从缓存读取数据 向缓存写入数据（会检查 URL 是否符合缓存规则） 清除所有缓存的功能 3. 缓存监控与分析工具为了方便调试和监控缓存使用情况，我们添加了以下工具方法： 123456789101112131415161718192021222324252627// 获取缓存使用情况cacheController.getUseSize = async () =&gt; { if (navigator?.storage?.estimate) { const estimate = await navigator.storage.estimate(); if (estimate) { const percentUsed = (estimate.usage / estimate.quota) * 100; let usedSpace = estimate.usage / 1024 / 1024; usedSpace = usedSpace &gt; 1024 ? (usedSpace / 1024).toFixed(2) + &quot; GB&quot; : usedSpace.toFixed(2) + &quot; MB&quot;; console.log( `%c当前站点的 IndexDB 已使用 ${usedSpace}，占最大可用容量 ${percentUsed.toFixed(2)}%`, &quot;color:green&quot; ); } return estimate; } else { console.warn(&quot;当前环境不支持 navigator.storage.estimate() 方法&quot;); }};// 获取所有缓存键cacheController.keys = async () =&gt; { const keys = await cacheController.instance.keys(); console.log(`%c浏览器 IndexDB 已缓存 ${keys.length} 个资源。`, &quot;color:green&quot;); return keys;}; 这些方法使我们能够： 查看当前缓存使用的空间大小和占用比例 获取已缓存资源的数量和键列表 4. 拦截 Cesium 的 XHR 请求缓存系统的核心是拦截并修改 Cesium 的 XMLHttpRequest 实现，在原始请求前后添加缓存处理逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 拦截 Cesium 的 XHR 请求实现缓存const patchCesiumXhr = () =&gt; { if (!Cesium || !Cesium.Resource) { console.error(&quot;Cesium 未加载！&quot;); return; } const original = Cesium.Resource._Implementations.loadWithXhr; Cesium.Resource._Implementations.loadWithXhr = function ( url, responseType, method, data, headers, deferred, overrideMimeType ) { // URL 解码 url = decodeURI(url); // 构建缓存键 const cacheKey = JSON.stringify({ url: url, responseType: responseType, method: method, data: data, headers: { ...headers }, overrideMimeType: overrideMimeType, }); // 创建 XHR 请求 const xhr = new XMLHttpRequest(); // 配置 XHR xhr.open(method, url, true); if (overrideMimeType &amp;&amp; xhr.overrideMimeType) { xhr.overrideMimeType(overrideMimeType); } if (headers) { for (const header in headers) { if (headers.hasOwnProperty(header)) { xhr.setRequestHeader(header, headers[header]); } } } if (responseType) { xhr.responseType = responseType; } // 判断是否需要缓存 if (cacheController.judgeUrl(url)) { // 先检查缓存 cacheController.getItem(cacheKey).then(cachedResponse =&gt; { if (cachedResponse) { // 从缓存返回 console.log(`从缓存加载: ${url}`); deferred.resolve(cachedResponse); } else { // 缓存中没有，发送请求 sendRequest(); } }); } else { // 不需要缓存，直接发送请求 sendRequest(); } function sendRequest() { xhr.onload = function () { // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { const response = xhr.response; // 存入缓存 if (cacheController.judgeUrl(url)) { cacheController.setItem(cacheKey, response).then(() =&gt; { console.log(`已缓存: ${url}`); }); } // 返回响应 deferred.resolve(response); } else { // 请求失败 deferred.reject( new Cesium.RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()) ); } }; xhr.onerror = function (e) { deferred.reject(new Cesium.RequestErrorEvent()); }; // 发送请求 xhr.send(data); } return xhr; };}; 这段代码的工作流程： 重写 Cesium 的 XHR 加载函数 对每个请求，检查 URL 是否需要缓存 如果需要缓存，先查找缓存是否已存在 从缓存返回或发送实际请求 成功返回后，将响应存入缓存 5. 初始化与加载 3D Tiles最后，我们来看如何初始化整个系统并加载 3D Tiles 模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748onMounted(async () =&gt; { const imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl( &quot;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot; ); viewer.imageryLayers.addImageryProvider(imageryProvider); // 初始化 localforage await localforage.setDriver(localforage.INDEXEDDB); // 初始化缓存控制器 initCacheController(); // 显示当前缓存使用情况 await cacheController.getUseSize(); // 初始化 Cesium await initCesium();});const initCesium = async () =&gt; { // 加载 3D Tiles tileset = await Cesium.Cesium3DTileset.fromUrl( &quot;https://resource.dvgis.cn/data/3dtiles/dayanta/tileset.json&quot; ); viewer.scene.primitives.add(tileset); viewer.zoomTo(tileset); setHeight(tileset, -418); console.log(&quot;3D Tiles 加载完成&quot;);};const setHeight = (tileset, height) =&gt; { height = Number(height); if (isNaN(height)) { return; } if (tileset != undefined &amp;&amp; tileset.boundingSphere != undefined) { const boundingSphereCenter = tileset.boundingSphere.center.clone(); var cartographic = Cesium.Cartographic.fromCartesian(boundingSphereCenter); var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); var offset = Cesium.Cartesian3.fromRadians( cartographic.longitude, cartographic.latitude, height ); var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation); }}; 这部分代码完成： 设置 Cesium 的底图 初始化 localforage，使用 IndexedDB 作为存储引擎 初始化缓存控制器 加载 3D Tiles 模型并调整高度 完整代码示例下面是完整的 Vue 组件代码，整合了上述所有部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261&lt;template&gt;&lt;/template&gt;&lt;script setup&gt;/* global Cesium */import { onMounted, onBeforeUnmount } from &quot;vue&quot;;import localforage from &quot;localforage&quot;;// 声明变量let tileset;const cacheController = {};// 初始化缓存控制器const initCacheController = () =&gt; { // 初始化 IndexedDB 存储实例 cacheController.instance = localforage.createInstance({ name: &quot;CesiumNetworkPlug&quot; }); // 缓存规则列表 cacheController.ruleList = new Set(); // 添加要缓存的 URL 模式（这里是 3DTiles 相关的） cacheController.ruleList.add(&quot;https://resource.dvgis.cn/data/3dtiles/dayanta/&quot;); // 匹配您的模型 URL // 判断 URL 是否需要缓存 cacheController.judgeUrl = url =&gt; { let needCache = false; [...cacheController.ruleList].forEach(rule =&gt; { needCache = needCache || url.indexOf(rule) &gt; -1 || rule === &quot;*&quot;; }); return needCache; }; // 获取缓存项 cacheController.getItem = async key =&gt; { return await cacheController.instance.getItem(key); }; // 设置缓存项 cacheController.setItem = async (key, value) =&gt; { if (value instanceof XMLDocument) return false; try { let keyObj = JSON.parse(key); if (cacheController.judgeUrl(keyObj.url) &amp;&amp; key &amp;&amp; value) { await cacheController.instance.setItem(key, value); return true; } } catch (e) { console.error(&quot;缓存存储错误:&quot;, e); } return false; }; // 清除所有缓存 cacheController.clear = async () =&gt; { await cacheController.instance.clear(); console.log(&quot;缓存已清除&quot;); }; // 获取缓存使用情况 cacheController.getUseSize = async () =&gt; { if (navigator?.storage?.estimate) { const estimate = await navigator.storage.estimate(); if (estimate) { const percentUsed = (estimate.usage / estimate.quota) * 100; let usedSpace = estimate.usage / 1024 / 1024; usedSpace = usedSpace &gt; 1024 ? (usedSpace / 1024).toFixed(2) + &quot; GB&quot; : usedSpace.toFixed(2) + &quot; MB&quot;; console.log( `%c当前站点的 IndexDB 已使用 ${usedSpace}，占最大可用容量 ${percentUsed.toFixed(2)}%`, &quot;color:green&quot; ); } return estimate; } else { console.warn(&quot;当前环境不支持 navigator.storage.estimate() 方法&quot;); } }; // 获取所有缓存键 cacheController.keys = async () =&gt; { const keys = await cacheController.instance.keys(); console.log(`%c浏览器 IndexDB 已缓存 ${keys.length} 个资源。`, &quot;color:green&quot;); return keys; }; // 拦截 Cesium 的 XHR 请求 patchCesiumXhr();};// 拦截 Cesium 的 XHR 请求实现缓存const patchCesiumXhr = () =&gt; { if (!Cesium || !Cesium.Resource) { console.error(&quot;Cesium 未加载！&quot;); return; } const original = Cesium.Resource._Implementations.loadWithXhr; Cesium.Resource._Implementations.loadWithXhr = function ( url, responseType, method, data, headers, deferred, overrideMimeType ) { // URL 解码 url = decodeURI(url); // 构建缓存键 const cacheKey = JSON.stringify({ url: url, responseType: responseType, method: method, data: data, headers: { ...headers }, overrideMimeType: overrideMimeType, }); // 创建 XHR 请求 const xhr = new XMLHttpRequest(); // 配置 XHR xhr.open(method, url, true); if (overrideMimeType &amp;&amp; xhr.overrideMimeType) { xhr.overrideMimeType(overrideMimeType); } if (headers) { for (const header in headers) { if (headers.hasOwnProperty(header)) { xhr.setRequestHeader(header, headers[header]); } } } if (responseType) { xhr.responseType = responseType; } // 判断是否需要缓存 if (cacheController.judgeUrl(url)) { // 先检查缓存 cacheController.getItem(cacheKey).then(cachedResponse =&gt; { if (cachedResponse) { // 从缓存返回 console.log(`从缓存加载: ${url}`); deferred.resolve(cachedResponse); } else { // 缓存中没有，发送请求 sendRequest(); } }); } else { // 不需要缓存，直接发送请求 sendRequest(); } function sendRequest() { xhr.onload = function () { // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { const response = xhr.response; // 存入缓存 if (cacheController.judgeUrl(url)) { cacheController.setItem(cacheKey, response).then(() =&gt; { console.log(`已缓存: ${url}`); }); } // 返回响应 deferred.resolve(response); } else { // 请求失败 deferred.reject( new Cesium.RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()) ); } }; xhr.onerror = function (e) { deferred.reject(new Cesium.RequestErrorEvent()); }; // 发送请求 xhr.send(data); } return xhr; };};onMounted(async () =&gt; { const imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl( &quot;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot; ); viewer.imageryLayers.addImageryProvider(imageryProvider); // 初始化 localforage await localforage.setDriver(localforage.INDEXEDDB); // 初始化缓存控制器 initCacheController(); // 显示当前缓存使用情况 await cacheController.getUseSize(); // 初始化 Cesium await initCesium();});const initCesium = async () =&gt; { // 加载 3D Tiles tileset = await Cesium.Cesium3DTileset.fromUrl( &quot;https://resource.dvgis.cn/data/3dtiles/dayanta/tileset.json&quot; ); viewer.scene.primitives.add(tileset); viewer.zoomTo(tileset); setHeight(tileset, -418); console.log(&quot;3D Tiles 加载完成&quot;);};const setHeight = (tileset, height) =&gt; { height = Number(height); if (isNaN(height)) { return; } if (tileset != undefined &amp;&amp; tileset.boundingSphere != undefined) { const boundingSphereCenter = tileset.boundingSphere.center.clone(); var cartographic = Cesium.Cartographic.fromCartesian(boundingSphereCenter); var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); var offset = Cesium.Cartesian3.fromRadians( cartographic.longitude, cartographic.latitude, height ); var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation); }};// 资源释放onBeforeUnmount(() =&gt; { if (viewer) { viewer.destroy(); viewer = null; }});&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;html,body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;}&lt;/style&gt; 总结与效果分析这种缓存方案带来的好处有： 大幅减少网络请求：二次加载模型时，大部分文件将从本地缓存加载，减少网络请求数量。 提高加载速度：从 IndexedDB 读取数据通常比从网络加载快 10-100 倍，极大提升了模型的加载速度。 减轻服务器负担：降低重复请求带来的服务器压力，减少带宽消耗。 离线访问支持：缓存内容在网络断开后仍可使用，提升应用的可靠性。 用户体验改善：即使在网络不稳定的环境下，也能保持良好的用户体验。 在实际测试中，对于大型 3D Tiles 模型，首次加载后的二次访问速度提升可达 3-5 倍，网络请求数量减少 70-90%。这对于移动设备或网络条件不佳的环境尤为重要。 注意事项在使用这种缓存方案时，需要注意以下几点： 存储限制：IndexedDB 在不同浏览器中有不同的存储限制，通常在几百 MB 到几 GB 之间。 版本管理：如果 3D Tiles 模型更新，需要有机制清除旧缓存。 安全性：只缓存来自可信源的模型数据，避免缓存可能包含恶意内容的资源。 用户控制：提供清除缓存的选项，允许用户在需要时刷新数据。 希望这篇文章对您的 Cesium 开发有所帮助！如有任何问题，欢迎在评论区留言讨论。","link":"/2025/03/20/cesium%20indexDB%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"cesium 二维下获取相机位置","text":"12345678910var newPostion;if (this._viewer.scene.mode === this._cesium.SceneMode.SCENE2D) { var cameraHeight = this._viewer.scene.camera.positionCartographic.height; var longitude = this._viewer.scene.camera.positionCartographic.longitude; var latitude = this._viewer.scene.camera.positionCartographic.latitude; newPostion = this._cesium.Cartesian3.fromRadians(longitude, latitude, cameraHeight);} else { newPostion = this._viewer.camera.position.clone();}&lt;!-- more --&gt; viewer.camera.position 返回相机在地心坐标系中的位置（Cartesian3）。 viewer.scene.camera.positionCartographic 返回相机在地理坐标系中的位置（Cartographic）。","link":"/2025/03/16/cesium%20%E4%BA%8C%E7%BB%B4%E4%B8%8B%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E4%BD%8D%E7%BD%AE/"},{"title":"cesium 修改源码获取wmts图层的bbox","text":"修改 WebMapServiceImageryProvider.js 文件 增加以下代码 1this._capabilitiesRes = getCapabilities(options.url, parameters.layers, parameters.crs); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849async function getCapabilities(url, layerName, crs) { try { let linkStr = &quot;?&quot;; const urlArr = url.split(&quot;?&quot;); if (urlArr.length &gt; 1 &amp;&amp; urlArr[1].length) { linkStr = &quot;&amp;&quot;; } const metaDataUrl = `${url}${linkStr}service=WMS&amp;request=GetCapabilities`; const capabilities = await Resource.fetchXML(metaDataUrl); const layersDom = capabilities.querySelectorAll(&quot;Layer&quot;); let bounds = []; let layer = null; if (layerName) { const index = Array.from(layersDom).findIndex(layer =&gt; { const key = layer.getElementsByTagName(&quot;Title&quot;)[0].textContent; return key === layerName; }); if (~index) { layer = layersDom[index]; } } else { layer = layersDom[0]; } if (!layer) { return bounds; } const boundingBoxes = Array.from(layer.getElementsByTagName(&quot;BoundingBox&quot;)); boundingBoxes.forEach(boundingBox =&gt; { const boundingCrs = boundingBox.getAttribute(&quot;CRS&quot;); const minx = parseFloat(boundingBox.getAttribute(&quot;minx&quot;)); const miny = parseFloat(boundingBox.getAttribute(&quot;miny&quot;)); const maxx = parseFloat(boundingBox.getAttribute(&quot;maxx&quot;)); const maxy = parseFloat(boundingBox.getAttribute(&quot;maxy&quot;)); if (crs === &quot;CRS:84&quot; &amp;&amp; crs === boundingCrs) { bounds = [minx, miny, maxx, maxy]; } else if ( crs === &quot;EPSG:3857&quot; &amp;&amp; (boundingCrs === &quot;EPSG:900913&quot; || boundingCrs === &quot;EPSG:3857&quot;) ) { bounds = [minx, miny, maxx, maxy]; } else if (crs === &quot;EPSG:4326&quot; &amp;&amp; crs === boundingCrs) { bounds = [miny, minx, maxy, maxx]; } }); return bounds; } catch (error) { console.log(&quot;error&quot;, error); }}","link":"/2025/03/16/cesium%20%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96wmts%E5%9B%BE%E5%B1%82%E7%9A%84bbox/"},{"title":"cesium 拾取错误开了贴地","text":"cesium 开了 clampGround 会出现拾取失误，点击这个面高亮，别的面会高亮 上边还有个模型 解决办法 123456789101112131415161718192021let editHandler = new SmartEarth.Cesium.ScreenSpaceEventHandler(Viewer.scene.canvas);let previosObj = null;editHandler.setInputAction(movement =&gt; { const pickedObjects = Viewer.scene.drillPick(movement.position); if (pickedObjects) { let pick = pickedObjects.pop(); while (!pick.id &amp;&amp; pickedObjects.length &gt; 0) { pick = pickedObjects.pop(); } if (previosObj) { previosObj.id.polygon.material = SmartEarth.Cesium.Color.fromAlpha( SmartEarth.Cesium.Color.BLUE, 0.5 ); } if (pick.id &amp;&amp; pick.id.polygon) { pick.id.polygon.material = new SmartEarth.Cesium.Color(1, 0, 0, 1); previosObj = pick; } }}, SmartEarth.Cesium.ScreenSpaceEventType.LEFT_CLICK);","link":"/2025/03/16/cesium%20%E6%8B%BE%E5%8F%96%E9%94%99%E8%AF%AF%E5%BC%80%E4%BA%86%E8%B4%B4%E5%9C%B0/"},{"title":"cesium 加载4490坐标系","text":"1.修改 ArcGisMapServerImageryProvider.js 源码 读取切片元数据时增加支持 wkid 4490 坐标系的判断，同时将切片信息也传 1234567if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, tileInfo: data.tileInfo, // 传入tileInfo，用于后面GeographicTilingScheme的计算 }); //SmartEarth 修改} fullExtent 范围增加 wkid 4490 坐标系判断 1234567891011if (data.fullExtent.spatialReference.wkid === 4490) { /** Geoworld Add **/ // SmartEarth 修改 that._rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); // SmartEarth 修改} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function metadataSuccess(data, imageryProviderBuilder) { const tileInfo = data.tileInfo; if (!defined(tileInfo)) { imageryProviderBuilder.useTiles = false; } else { imageryProviderBuilder.tileWidth = tileInfo.rows; imageryProviderBuilder.tileHeight = tileInfo.cols; if (tileInfo.spatialReference.wkid === 102100 || tileInfo.spatialReference.wkid === 102113) { imageryProviderBuilder.tilingScheme = new WebMercatorTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, }); } else if (data.tileInfo.spatialReference.wkid === 4326) { imageryProviderBuilder.tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, }); /** Geoworld **/ //SmartEarth 修改 } else if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, tileInfo: data.tileInfo, // 传入tileInfo，用于后面GeographicTilingScheme的计算 }); //SmartEarth 修改 } else { const message = `Tile spatial reference WKID ${data.tileInfo.spatialReference.wkid} is not supported.`; throw new RuntimeError(message); } imageryProviderBuilder.maximumLevel = data.tileInfo.lods.length - 1; if (defined(data.fullExtent)) { if ( defined(data.fullExtent.spatialReference) &amp;&amp; defined(data.fullExtent.spatialReference.wkid) ) { if ( data.fullExtent.spatialReference.wkid === 102100 || data.fullExtent.spatialReference.wkid === 102113 ) { const projection = new WebMercatorProjection(); const extent = data.fullExtent; const sw = projection.unproject( new Cartesian3( Math.max( extent.xmin, -imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), Math.max( extent.ymin, -imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), 0.0 ) ); const ne = projection.unproject( new Cartesian3( Math.min( extent.xmax, imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), Math.min( extent.ymax, imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), 0.0 ) ); imageryProviderBuilder.rectangle = new Rectangle( sw.longitude, sw.latitude, ne.longitude, ne.latitude ); } else if (data.fullExtent.spatialReference.wkid === 4326) { imageryProviderBuilder.rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); } else if (data.fullExtent.spatialReference.wkid === 4490) { /** Geoworld Add **/ // SmartEarth 修改 that._rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); // SmartEarth 修改 } else { const extentMessage = `fullExtent.spatialReference WKID ${data.fullExtent.spatialReference.wkid} is not supported.`; throw new RuntimeError(extentMessage); } } } else { imageryProviderBuilder.rectangle = imageryProviderBuilder.tilingScheme.rectangle; } imageryProviderBuilder.useTiles = true; } if (defined(data.copyrightText) &amp;&amp; data.copyrightText.length &gt; 0) { if (defined(imageryProviderBuilder.credit)) { imageryProviderBuilder.tileCredits = [new Credit(data.copyrightText)]; } else { imageryProviderBuilder.credit = new Credit(data.copyrightText); } }} 2.修改 GeographicTilingScheme 类 1234/** Geoworld Add **///SmartEarth 修改this._tileInfo = options.tileInfo;//SmartEarth 修改 修改切片矩阵计算获取行列号 xy 值的原型方法 getNumberOfXTilesAtLevel 和 getNumberOfYTilesAtLevel 1234567891011121314151617181920212223242526272829303132333435GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) { // return this._numberOfLevelZeroTilesX &lt;&lt; level; /** Geoworld Add **/ //SmartEarth 修改 if (!defined(this._tileInfo)) { return this._numberOfLevelZeroTilesX &lt;&lt; level; } const currentMatrix = this._tileInfo.lods.filter(function (item) { return item.level === level; }); const currentResolution = currentMatrix[0].resolution; return Math.round(360 / (this._tileInfo.rows * currentResolution)); //SmartEarth 修改};/** * Gets the total number of tiles in the Y direction at a specified level-of-detail. * * @param {number} level The level-of-detail. * @returns {number} The number of tiles in the Y direction at the given level. */GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) { // return this._numberOfLevelZeroTilesY &lt;&lt; level; //SmartEarth 修改 if (!defined(this._tileInfo)) { return this._numberOfLevelZeroTilesY &lt;&lt; level; } // 使用切片矩阵计算 const currentMatrix = this._tileInfo.lods.filter(function (item) { return item.level === level; }); const currentResolution = currentMatrix[0].resolution; return Math.round(180 / (this._tileInfo.cols * currentResolution)); //SmartEarth 修改}; 3.修改 Ellipsoid 类，定义 2000 椭球参数 1234567891011/** * An Ellipsoid instance initialized to the CGCS2000 standard. * * @type {Ellipsoid} * @constant *//** Geoworld Add **/Ellipsoid.CGCS2000 = Object.freeze( // eslint-disable-next-line no-loss-of-precision new Ellipsoid(6378137.0, 6378137.0, 6356752.31414035585)); 使用 123456789101112131415161718192021222324252627282930var cgs2000Ellipsolid = new Cesium.Ellipsoid(6378137.0, 6378137.0, 6356752.31414035585);var myGeographicTilingScheme = new Cesium.GeographicTilingScheme({ ellipsoid: cgs2000Ellipsolid, rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90), numberOfLevelZeroTilesX: 4, numberOfLevelZeroTilesY: 2,});var esriWMTS = new Cesium.ArcGisMapServerImageryProvider({ url: &quot;http://Ip:6080/arcgis/rest/services/jssl_vector_L3_L17/MapServer&quot;, layer: &quot;jssl_vector_L3_L17&quot;, tilingScheme: myGeographicTilingScheme, rectangle: myRectangle, minimumLevel: 0, ellipsoid: cgs2000Ellipsolid, maximumLevel: 14,});var cgs2000GeographicProj = new Cesium.GeographicProjection(cgs2000Ellipsolid);var viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;, { animation: false, geocoder: false, timeline: false, navigationHelpButton: false, baseLayerPicker: false, mapProjection: cgs2000GeographicProj, imageryProvider: esriWMTS,});viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(119.56156642831284, 32.419457329767326, 272683),});","link":"/2025/03/16/cesium%20%E5%8A%A0%E8%BD%BD4490%E5%9D%90%E6%A0%87%E7%B3%BB/"},{"title":"Cesium 根据相机点和距离飞向","text":"在 Cesium 三维可视化开发中，经常需要精确控制相机的位置和视角。本文将介绍如何根据目标点位置、相机与目标的距离、视角方向等参数，计算出相机的精确位置，并实现相机飞行定位的功能。 相机定位的核心问题在 Cesium 中，直接设置相机位置通常需要提供世界坐标系中的绝对位置。但在实际应用中，我们往往更关心： 相机需要看向哪个点（目标点） 相机距离目标点多远（距离） 相机应该从什么角度观察目标（方位角和俯仰角） 这就需要我们编写一个函数，将这些更直观的参数转换为 Cesium 相机所需的绝对位置。 解决方案原理我们的解决方案基于以下步骤： 以目标点为中心建立局部坐标系（东北上 ENU 坐标系） 在该坐标系中计算相机的相对位置 将相对位置转换回世界坐标系 这样就能准确定位相机，无论目标点在地球上的哪个位置。 核心函数解析下面是计算相机位置的核心函数： 12345678910111213141516171819function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量（初始位置在目标点正上方） var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;} 关键步骤说明 创建局部坐标系： 1var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); 这一步创建了一个转换矩阵，将局部坐标系（东、北、上）与全球坐标系关联起来。 设置初始偏移： 1var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); 初始偏移设置为(0,0,distance)，表示相机位于目标点正上方 distance 距离处。 计算旋转： 123var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0)); 这里创建一个旋转矩阵，注意参数的调整： -heading：负号是因为 Cesium 中 heading 的方向定义 pitch - Cesium.Math.PI_OVER_TWO：减去 90 度是因为我们的初始位置在正上方 应用旋转： 1Cesium.Matrix3.multiplyByVector(rotation, offset, offset); 将旋转应用到偏移向量上。 转换到全球坐标： 1Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); 将局部坐标系中的偏移量转换为全球坐标系中的位置。 使用示例了解了原理后，下面看看如何使用这个函数： 1234567891011121314151617181920// 目标点的位置（经度、纬度、高度）var targetPosition = Cesium.Cartesian3.fromDegrees(116.391, 39.904, 50);// 设置相机参数var distanceFromTarget = 1000; // 相机距离目标点1000米var heading = Cesium.Math.toRadians(45); // 方位角45度var pitch = Cesium.Math.toRadians(30); // 俯仰角30度// 计算相机位置var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch);// 设置相机视图viewer.camera.setView({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, },}); 这样设置后，相机会精确地位于目标点东北方向 1000 米处，并以 45 度方位角和 30 度俯仰角观察目标点。 应用场景这种相机定位方法在许多场景中非常有用： 关键位置展示：快速定位到建筑物、地标等关键点的最佳观察位置 动画路径设计：创建围绕目标点的相机飞行路径 自定义导航控制：实现更直观的导航控制，如”环绕目标点旋转”、”拉近/拉远”等 多视角切换：在不同角度之间平滑过渡，展示目标的不同方面 完整代码这里是完整的实现代码，包含了计算函数和使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 根据目标点、距离和视角计算相机位置 * @param {Cesium.Cartesian3} targetPosition 目标点的位置 * @param {Number} distanceFromTarget 相机到目标点的距离（米） * @param {Number} heading 方位角（弧度） * @param {Number} pitch 俯仰角（弧度） * @returns {Cesium.Cartesian3} 计算出的相机位置 */function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量 var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;}// 使用示例function flyToPositionWithCamera() { // 目标点的位置（北京天安门） var targetPosition = Cesium.Cartesian3.fromDegrees(116.391, 39.904, 50); // 设置相机参数 var distanceFromTarget = 1000; // 相机距离目标点1000米 var heading = Cesium.Math.toRadians(45); // 方位角45度 var pitch = Cesium.Math.toRadians(30); // 俯仰角30度 // 计算相机位置 var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch); // 设置相机视图 viewer.camera.flyTo({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, }, duration: 2, // 飞行时间，单位秒 });}// 调用函数flyToPositionWithCamera(); 总结通过这种方法，我们可以更加直观地控制 Cesium 中的相机位置，无需直接处理复杂的世界坐标系。这对于创建精确的观察视角、设计相机动画路径等场景非常有用。 希望这篇文章对您在 Cesium 开发中控制相机有所帮助！","link":"/2025/03/16/cesium%20%E6%A0%B9%E6%8D%AE%E7%9B%B8%E6%9C%BA%E7%82%B9%E5%92%8C%E8%B7%9D%E7%A6%BB%E9%A3%9E%E5%90%91/"},{"title":"Cesium 根据相机点和距离飞向","text":"12345678910111213141516171819202122232425262728293031323334353637function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量 var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;}// 使用示例var targetPosition = Cesium.Cartesian3.fromDegrees(longitude, latitude, height);var distanceFromTarget = 1000; // 米var heading = Cesium.Math.toRadians(45); // 方位角，弧度var pitch = Cesium.Math.toRadians(30); // 俯仰角，弧度var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch);// 设置相机位置viewer.camera.setView({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, },});","link":"/2025/03/16/cesium%20%E6%A0%B9%E6%8D%AE%E7%9B%B8%E6%9C%BA%E7%82%B9%E5%92%8C%E8%B7%9D%E7%A6%BB%E9%A3%9E%E5%90%912/"},{"title":"cesium 洋流限制范围","text":"123456789101112131415161718192021222324252627282930313233field = earthCtrl.factory.createOceanField({ name: 'ocean1', type: &quot;ocean&quot;, upath: &quot;./data/MIT.0000000001_UVEL_1.dat&quot;, vpath: &quot;./data/MIT.0000000001_VVEL_1.dat&quot;, bounds: [ [ 112.27127810594834, 19.225753080468763 ], [ 110.03847818240308, 17.427581061438815 ], [ 111.95290379190146, 12.594412699775589 ], [ 118.57050910216816, 13.584956070591218 ], [ 118.77371765142777, 19.065063097417365 ], [ 112.27127810594834, 19.225753080468763 ] ] }); } 1234567891011121314151617function isPointInPolygon(point, polygon) { let inside = false; let x = point[0], y = point[1]; for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) { let xi = polygon[i][0], yi = polygon[i][1]; let xj = polygon[j][0], yj = polygon[j][1]; let intersect = yi &gt; y !== yj &gt; y &amp;&amp; x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi; if (intersect) inside = !inside; } return inside;} 1234567891011121314151617181920212223function fieldisDefined(x, y) { // 首先获取屏幕坐标对应的地理坐标 const cartesian = _oceanmap.viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), _oceanmap.viewer.scene.globe.ellipsoid ); if (!cartesian) return false; // 转换为经纬度坐标 const cartographic = Cesium.Cartographic.fromCartesian(cartesian); const lon = Cesium.Math.toDegrees(cartographic.longitude); const lat = Cesium.Math.toDegrees(cartographic.latitude); // 判断点是否在原有海洋区域内 const isInOcean = field(x, y)[2] !== null; // 判断点是否在指定的多边形区域内 const isInBoundary = isPointInPolygon([lon, lat], _oceanmap.bounds); // 同时满足两个条件：在海洋中且在边界内 return isInOcean &amp;&amp; isInBoundary;} 12345// 从相机位置通过屏幕点发射射线，计算与地球表面的交点const cartesian = _oceanmap.viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), _oceanmap.viewer.scene.globe.ellipsoid); :::tips这行代码的作用是将屏幕上的 2D 坐标点 (x, y) 转换为地球表面上的 3D 坐标点。 ::: 123456789101112131415161718192021222324252627function isPointInPolygon(point, polygon) { // 初始化结果为false（假设点在多边形外） let inside = false; // 获取待检测点的坐标 let x = point[0], y = point[1]; // 遍历多边形的所有边 // i是当前点，j是前一个点，这样就能形成一条边 for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) { // 获取多边形当前边的两个端点坐标 let xi = polygon[i][0], yi = polygon[i][1]; // 当前点 let xj = polygon[j][0], yj = polygon[j][1]; // 前一个点 // 这行是算法的核心，检查射线与边的相交情况 let intersect = yi &gt; y !== yj &gt; y &amp;&amp; // 第一个条件：确保边跨过射线 x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi; // 第二个条件：确保交点在点的右侧 // 每次找到一个有效交点，就翻转inside的值 if (intersect) inside = !inside; } return inside;} :::tips这是一个经典的射线算法（Ray Casting Algorithm）用来判断一个点是否在多边形内部。让我详细解释这个算法的原理： 主要思路是：从目标点引出一条水平射线，统计这条射线与多边形边界的交点数量。如果交点数量为奇数，则点在多边形内部；如果为偶数，则在外部。 ::: :::tips让我用一个具体的例子来说明： 假设我们有一个点 P(x, y)，我们要判断它是否在多边形内： 我们从点 P 向右引一条水平射线。 对于多边形的每条边： 首先判断这条边是否跨过射线：(yi &gt; y) !== (yj &gt; y) 这表示一个端点在射线上方，另一个在下方 然后判断交点是否在点的右侧：x &lt; (xj - xi) * (y - yi) / (yj - yi) + xi 这是用线性插值计算交点的 x 坐标，判断是否在点的右边 计数规则： 每找到一个交点，就翻转 inside 的值 最终如果 inside 为 true，说明交点数为奇数，点在内部 如果为 false，说明交点数为偶数，点在外部 :::","link":"/2025/03/16/cesium%20%E6%B4%8B%E6%B5%81%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4/"},{"title":"cesium 生成线框","text":"为了在你的自定义**CityPrimitive**中添加重心坐标，你需要修改你的几何体数据，为每个顶点增加这些坐标。重心坐标是一个在三角形顶点上为**[1, 0, 0]**，**[0, 1, 0]**，**[0, 0, 1]**，并在内部插值的属性。这样，三角形的每个边上的坐标都会接近零，并且可以在片段着色器中用来判断一个片段是否接近边缘。 首先，你需要为你的几何体的每个三角形的顶点生成这些坐标。在 Cesium 中，可以在你创建顶点属性的时候添加这些坐标。例如： 12345678910111213141516171819202122232425262728// 生成重心坐标属性function generateBarycentricCoordinates(geometry) { const numberOfVertices = Cesium.Geometry.computeNumberOfVertices(geometry); const barycentricCoordinates = new Float32Array(numberOfVertices * 3); for (let i = 0, len = numberOfVertices / 3; i &lt; len; ++i) { barycentricCoordinates[i * 9 + 0] = 1; // 第一个顶点 barycentricCoordinates[i * 9 + 1] = 0; barycentricCoordinates[i * 9 + 2] = 0; barycentricCoordinates[i * 9 + 3] = 0; // 第二个顶点 barycentricCoordinates[i * 9 + 4] = 1; barycentricCoordinates[i * 9 + 5] = 0; barycentricCoordinates[i * 9 + 6] = 0; // 第三个顶点 barycentricCoordinates[i * 9 + 7] = 0; barycentricCoordinates[i * 9 + 8] = 1; } return new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: barycentricCoordinates, });}// 在你的几何体中添加重心坐标属性this.geometry.attributes.barycentric = generateBarycentricCoordinates(this.geometry); 接着，在你的createCommand函数中，你需要确保这个新属性被传递到着色器中，并且绑定到一个顶点着色器输入： 1234567javascriptCopy codeconst attributeLocations = { position: 0, normal: 1, st: 2, barycentric: 3 // 添加新的属性位置}; 然后，在你的顶点着色器中，你需要接收并传递这个属性到片段着色器： 1234567891011glslCopy code // 顶点着色器 // ... in vec3 barycentric;out vec3 v_barycentric;void main() { // ... v_barycentric = barycentric; // ...} 最后，在你的片段着色器中，你需要使用这个v_barycentric来确定是否绘制线框： 12345678910111213141516glslCopy code // 片段着色器 // ... in vec3 v_barycentric;void main() { // 根据重心坐标确定是否绘制线框 float lineWidth = 0.01; // 设置线宽 if (min(min(v_barycentric.x, v_barycentric.y), v_barycentric.z) &lt; lineWidth) { // 接近边缘，绘制线框 out_FragColor = vec4(0.0, 0.0, 0.0, 1.0); } else { // 在三角形内部，根据需要设置颜色 discard; // 或者适当设置颜色 }} 请记住，这些修改都需要适应你当前的代码和 Cesium 的使用方式。具体细节可能需要进一步调整以确保与你的应用程序兼容。 在 3D 图形学中，重心坐标（Barycentric coordinates）用于表示在三角形内部的点相对于三角形顶点的位置。一个点的重心坐标是三个数（通常记作�,�,�u,v,w），它们的和为 1，每个数对应于点在三角形一个顶点上的“权重”。在图形 API 中，重心坐标通常用于插值（如纹理坐标、颜色等）。 当给每个三角形的顶点赋予不同的重心坐标： 第一个顶点：(1,0,0)(1,0,0) 第二个顶点：(0,1,0)(0,1,0) 第三个顶点：(0,0,1)(0,0,1) 在三角形的边上，至少有一个重心坐标将接近 0（因为边上的点只有两个顶点的“权重”）。在三角形内部，每个重心坐标都将大于 0。 所以，当你看到这样的代码： 1234glslCopy code if (min(min(v_barycentric.x, v_barycentric.y), v_barycentric.z) &lt; lineWidth) { // ... } 这段代码的意思是：如果在三个重心坐标中有任何一个接近 0（小于lineWidth），那么当前片段（Pixel）就处于三角形的边上或接近边缘。在这种情况下，如果你想渲染线框，你会在这些接近边缘的片段上应用一种颜色（如黑色），从而绘制出线框的效果。 而关于您的第一个问题，确实，这是一个顶点对应一个重心坐标，这三个顶点的重心坐标（(1,0,0)(1,0,0), (0,1,0)(0,1,0), (0,0,1)(0,0,1)）被分配给了三角形的三个顶点，这样可以在三角形内部以及边缘上插值这些坐标。当你在顶点着色器中将这些坐标传递到片段着色器，然后在片段着色器中使用这些坐标来检测边缘，你就能实现线框渲染的效果。","link":"/2025/03/16/cesium%20%E7%94%9F%E6%88%90%E7%BA%BF%E6%A1%86/"},{"title":"cesium 根据相机点和距离飞向","text":"在 GIS 开发中，三维地理数据的可视化和交互是非常重要的功能。本文将介绍如何使用 SmartEarth SDK（基于 Cesium 的扩展库）来加载 3D Tiles 模型，并实现模型的属性查询和高亮选择功能。 主要功能介绍本示例主要实现了以下功能： 加载多个 3D Tiles 模型 根据经纬度定位并创建标记点 查询并显示 3D Tiles 模型的属性信息 实现模型对象的高亮显示 这些功能在智慧城市、BIM 管理、城市规划等三维可视化应用中非常常见。下面我们来逐一介绍关键技术实现。 根据经纬度创建标记点，并添加到场景中： 12345678910111213141516const position = Cesium.Cartesian3.fromDegrees(lon1, lat1, 60);let cartographicPosition = Cesium.Cartographic.fromCartesian(position);const height = Viewer.scene.sampleHeight(cartographicPosition);// 创建标签const label = earthCtrl.factory.createLabel({ lon: lon1, lat: lat1, alt: height + 1, text: &quot;创建文本&quot;, image: &quot;https://cim.smartearth.cn/sdkdemo/master/src/static/image/mark.png&quot;, // 文本偏移量 pixelOffset: new SmartEarth.Cesium.Cartesian2(0, -50), // 图片偏移量 iPixelOffset: new SmartEarth.Cesium.Cartesian2(0, -20),}); 这段代码演示了如何创建一个带有图标和文本的标记点，sampleHeight方法用于获取该位置的地面高度，确保标记点正确放置。 4. 查询显示 3D Tiles 属性信息当点击模型时，我们需要获取并显示该位置模型的属性信息： 123456789101112131415// 高亮逻辑const winPosition = Viewer.scene.cartesianToCanvasCoordinates(position);const pickObject = Viewer.scene.pick(winPosition);// 获取所有属性const propertyIds = pickObject.getPropertyIds();let tooltipHTML = &quot;&quot;;for (let i = 0; i &lt; propertyIds.length; ++i) { const propertyId = propertyIds[i]; const value = pickObject.getProperty(propertyId); value &amp;&amp; (tooltipHTML += `${propertyId}:${value || &quot;无&quot;}&lt;br&gt;`);}// 显示提示框tooltip.showAts({ position: winPosition, text: tooltipHTML }); 这段代码通过pick函数获取鼠标位置下的 3D Tiles 对象，然后遍历其所有属性，生成 HTML 格式的提示内容。 5. 实现 3D Tiles 模型高亮实现点击模型后高亮显示选中的对象： 1234567891011121314151617181920212223242526// 把上一个高亮的tileset还原if (previousTileSet) { previousTileSet.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { return SmartEarth.Cesium.Color.WHITE; }, }, });}// 设置新的高亮样式const pickId = pickObject.getProperty(&quot;id&quot;);tileset.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { const featueId = feature.getProperty(&quot;id&quot;); if (pickId === featueId) { return SmartEarth.Cesium.Color.YELLOW; } else { return SmartEarth.Cesium.Color.WHITE; } }, },});previousTileSet = tileset; 这段代码使用Cesium3DTileStyle来设置模型的颜色样式。通过比较当前选中对象的 ID 和模型中每个 feature 的 ID，将匹配的对象设置为黄色高亮显示，其余部分保持白色。 6. 相机飞行定位最后，实现相机飞行到指定模型的功能： 12345const options = { duration: 2, offset: new SmartEarth.Cesium.HeadingPitchRange(1.0, -0.3, 1000),};earthCtrl.userScene.flyTo(tiltModel1.item, options); 这段代码使用flyTo方法使相机飞行到指定的模型位置，并设置了适当的视角和距离。 完整代码下面是完整的 HTML 和 JavaScript 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;初始化示例&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/CimSDK.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/Workers/layui/css/layui.css&quot; /&gt; &lt;style&gt; .funcBox { position: absolute; top: 30px; padding: 10px; width: 470px; background-color: rgba(0, 0, 0, 0.7); border-radius: 4px; left: 20px; color: #fff; } .layui-form-item { text-align: center; } .layui-form-label { width: unset !important; padding: 9px !important; } .layui-input-block { margin-left: 50px !important; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sdkContainer&quot;&gt;&lt;/div&gt; &lt;!--按钮--&gt; &lt;div class=&quot;funcBox layui-form&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;lon&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;lon&quot; placeholder=&quot;请输入经度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;lat&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;lat&quot; placeholder=&quot;请输入纬度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;alt&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;alt&quot; placeholder=&quot;请输入高度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;button id=&quot;btn1&quot; class=&quot;layui-btn&quot;&gt;定位&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./CimSDK/Workers/jquery-3.5.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./CimSDK/CimSDK.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; window.earthCtrl = new SmartEarth.EarthCtrl(&quot;sdkContainer&quot;); window.Viewer = earthCtrl.viewer; const Cesium = SmartEarth.Cesium; //显示fps earthCtrl.showFPS = true; //预载入输入框值 const lon1 = 118.36378039081389; $(&quot;#lon&quot;).val(lon1); const lat1 = 31.378263226883764; $(&quot;#lat&quot;).val(lat1); const alt1 = 60; $(&quot;#alt&quot;).val(alt1); let model; let previoisEntity = null; let previousTileSet = null; let tooltip = earthCtrl.core.createTooltip(); tooltip.showFun(false); async function load() { const lon1 = $(&quot;#lon&quot;).val(); const lat1 = $(&quot;#lat&quot;).val(); const alt1 = $(&quot;#alt&quot;).val(); // 加标记点 const position = Cesium.Cartesian3.fromDegrees(lon1, lat1, 60); let cartographicPosition = Cesium.Cartographic.fromCartesian(position); const height = Viewer.scene.sampleHeight(cartographicPosition); // 移除上一个点 if (previoisEntity) { Viewer.entities.remove(previoisEntity); } const label = earthCtrl.factory.createLabel({ lon: lon1, lat: lat1, alt: height + 1, text: &quot;创建文本&quot;, image: &quot;https://cim.smartearth.cn/sdkdemo/master/src/static/image/mark.png&quot;, // 文本偏移量 pixelOffset: new SmartEarth.Cesium.Cartesian2(0, -50), // 图片偏移量 iPixelOffset: new SmartEarth.Cesium.Cartesian2(0, -20), }); previoisEntity = label._primitive; // 高亮逻辑 const winPosition = Viewer.scene.cartesianToCanvasCoordinates(position); const pickObject = Viewer.scene.pick(winPosition); const tileset = pickObject.content._tileset; // 把上一个高亮的tileset还原 if (previousTileSet) { previousTileSet.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { return SmartEarth.Cesium.Color.WHITE; }, }, }); } const pickId = pickObject.getProperty(&quot;id&quot;); const propertyIds = pickObject.getPropertyIds(); // 获取所有属性 // 弹窗显示所有属性 const length = propertyIds.length; let tooltipHTML = &quot;&quot;; for (let i = 0; i &lt; length; ++i) { const propertyId = propertyIds[i]; console.log(`${propertyId}: ${pickObject.getProperty(propertyId)}`); const value = pickObject.getProperty(propertyId); value &amp;&amp; (tooltipHTML += `${propertyId}:${value || &quot;无&quot;}&lt;br&gt;`); } tooltip.showAts({ position: winPosition, text: tooltipHTML }); // 高亮逻辑 tileset.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { console.log(&quot;feature&quot;, feature.getPropertyIds()); const featueId = feature.getProperty(&quot;id&quot;); if (pickId === featueId) { return SmartEarth.Cesium.Color.YELLOW; } else { return SmartEarth.Cesium.Color.WHITE; } }, }, }); previousTileSet = tileset; } const url1 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d120240813104356/tileset.json&quot;; const tiltModel1 = await earthCtrl.factory.create3DTilesets({ url: url1, }); const url2 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d920240813104425/tileset.json&quot;; const tiltModel2 = await earthCtrl.factory.create3DTilesets({ url: url2, }); const url3 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d520240813104456/tileset.json&quot;; const tiltModel3 = await earthCtrl.factory.create3DTilesets({ url: url3, }); const options = { duration: 2, offset: new SmartEarth.Cesium.HeadingPitchRange(1.0, -0.3, 1000), }; earthCtrl.userScene.flyTo(tiltModel1.item, options); $(&quot;#btn1&quot;).on(&quot;click&quot;, () =&gt; { load(); }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2025/03/16/cesium%20%E8%BE%93%E5%85%A5%E7%BB%8F%E7%BA%AC%E5%BA%A6%E5%AE%9A%E4%BD%8D%E5%88%B03dtiles/"},{"title":"cesium修改CesiumTerrainProvider源码","text":"修改 CesiumTerrainProvider 源码传入地形的 bounds 参数，支持地形加后 flyTo 12345678910111213141516171819202122232425262728293031323334353637const bounds = data.bounds if (!data.projection || data.projection === &quot;EPSG:4326&quot;) { terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1, ellipsoid: terrainProviderBuilder.ellipsoid, rectangle: bounds.length ? Rectangle.fromDegrees(...bounds) : Rectangle.MAX_VALUE }); } else if (data.projection === &quot;EPSG:3857&quot;) { const epsg3857Bounds = Math.PI * terrainProviderBuilder.ellipsoid.maximumRadius; if(bounds[0] &lt; -epsg3857Bounds) { bounds[0] = -epsg3857Bounds } if(bounds[1] &lt; -epsg3857Bounds) { bounds[1] = -epsg3857Bounds } if(bounds[2] &gt; epsg3857Bounds) { bounds[2] = epsg3857Bounds } if(bounds[3] &gt; epsg3857Bounds) { bounds[3] = epsg3857Bounds } terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme({ numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1, ellipsoid: terrainProviderBuilder.ellipsoid, rectangleSouthwestInMeters: new Cartesian2( bounds[0], bounds[1] ), rectangleNortheastInMeters: new Cartesian2( bounds[2], bounds[3] ) }); } 1234const layer = await Cesium.CesiumTerrainProvider.fromUrl( options.url, options); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 地形飞跃 * @method * @param {Object} options 构造参数 * @param {Object} options.orientation 飞行到达地形的视角角度 * @param {Number} options.orientation.heading 航向 * @param {Number} options.orientation.pitch 俯仰 * @param {Number} options.orientation.roll 滚动 * @param {Number} options.height 飞行到达地形的视角高度 （默认10000米） * @param {Number} options.duration 以秒为单位的飞行持续时间 * @param {Function} options.complete 飞行完成时执行的函数 */ flyTo(options = {}) { //const that = this; const option = options; option.orientation = Cesium.defaultValue(options.orientation, { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-60), roll: Cesium.Math.toRadians(0), }); function webMercatorToLatLng(x, y) { const earthRadius = 6378137; // 地球半径，单位：米 const originShift = Math.PI * earthRadius; // 地球周长 const lon = (x / originShift) * 180.0; const lat = (180.0 / Math.PI) * (2.0 * Math.atan(Math.exp((y / originShift) * Math.PI)) - Math.PI / 2.0); return { lon, lat }; } if ( this._parameter.sourceType === &quot;ctb&quot; || this._parameter.sourceType === &quot;arcgis&quot; ) { //'EPSG:4326' const rectangle = this._primitive._tilingScheme.rectangle; const westDegrees = Cesium.Math.toDegrees(rectangle.west); // const westDegrees2 = Cesium.Math.toDegrees(rectangle.east); // const westDegrees3 = Cesium.Math.toDegrees(rectangle.north); // const westDegrees4 = Cesium.Math.toDegrees(rectangle.south); // console.log( // &quot;westDegrees&quot;, // westDegrees, // westDegrees2, // westDegrees3, // westDegrees4 // ); if (westDegrees &lt;= 180 &amp;&amp; westDegrees &gt;= -180) { const lon = Cesium.Math.toDegrees( (rectangle.west + rectangle.east) / 2 ); const lat = Cesium.Math.toDegrees( (rectangle.south + rectangle.north) / 2 ); const height = options.height || 10000; option.destination = Cesium.defaultValue( options.destination, Cesium.Cartesian3.fromDegrees(lon, lat, height) ); } else { const min = webMercatorToLatLng(rectangle.west, rectangle.south); const max = webMercatorToLatLng(rectangle.east, rectangle.north); const lon = (min.lon + max.lon) / 2; const lat = (min.lat + max.lat) / 2; const height = options.height || 10000; option.destination = Cesium.defaultValue( options.destination, Cesium.Cartesian3.fromDegrees(lon, lat, height) ); } this._coreMap.camera.flyTo(option); } }}","link":"/2025/03/16/cesium%E4%BF%AE%E6%94%B9CesiumTerrainProvider%E6%BA%90%E7%A0%81/"},{"title":"cesium加载10万点","text":"cesium 加载 10 万点 cesium 加载 10 万点 cesium 加载 10 万点 cesium 加载 10 万点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- Use correct character set. --&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;!-- Tell IE to use the latest, best version. --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;!-- Make the application on mobile take up the full browser screen and disable user scaling. --&gt; &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/CimSDK.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/Workers/layui/css/layui.css&quot;&gt; &lt;style&gt; html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;}.funcBox { position: absolute; top: 30px; padding: 10px; background-color: rgba(0, 0, 0, .7); border-radius: 4px; left: 20px; color: #fff;}.layui-form-item { text-align: center; margin-bottom: 0;}.layui-form-label { width: unset !important; padding: 9px !important;}.layui-input-block { margin-left: 70px !important;}&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sdkContainer&quot;&gt;&lt;/div&gt; &lt;div class=&quot;funcBox layui-form&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;button id=&quot;btn1&quot; class=&quot;layui-btn&quot; onclick=&quot;removeLayer()&quot;&gt;移除图层&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./CimSDK/Workers/jquery-3.5.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./CimSDK/CimSDK.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./CimSDK/Workers/layui/layui.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const Cesium = SmartEarth.Cesiumwindow.earthCtrl = new SmartEarth.EarthCtrl(&quot;sdkContainer&quot;, {});window.viewer = window.earthCtrl.viewer;earthCtrl.showFPS = true;const ellipsoid = viewer.scene.globe.ellipsoid;let billboardCollection;let instancingEnabled = true;// const instancedArraysExtension = context._instancedArrays;let billboardCount = 100489;let scale = 1.0;// Define the area where billboards will be placedconst centerLongitude = -1.385205433269729;const centerLatitude = 0.6777926580888163;const rectangleHalfSize = 0.5;const e = new Cesium.Rectangle( centerLongitude - rectangleHalfSize, centerLatitude - rectangleHalfSize, centerLongitude + rectangleHalfSize, centerLatitude + rectangleHalfSize);resetBillboardCollection()function resetBillboardCollection () { if (Cesium.defined(billboardCollection)) { viewer.scene.primitives.remove(billboardCollection); } billboardCollection = viewer.scene.primitives.add( new Cesium.BillboardCollection({ scene: viewer.scene, }) ); const gridSize = Math.sqrt(billboardCount); for (let y = 0; y &lt; gridSize; ++y) { for (let x = 0; x &lt; gridSize; ++x) { const longitude = Cesium.Math.lerp( e.west, e.east, x / (gridSize - 1) ); const latitude = Cesium.Math.lerp( e.south, e.north, y / (gridSize - 1) ); const position = new Cesium.Cartographic( longitude, latitude, 10000.0 ); billboardCollection.add({ position: ellipsoid.cartographicToCartesian(position), image: &quot;./demo/image/water.svg&quot;, scale: scale, }); } } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 没加上 scene 会慢","link":"/2025/03/16/cesium%E5%8A%A0%E8%BD%BD10%E4%B8%87%E7%82%B9/"},{"title":"cesium控制时间轴显示与隐藏","text":"12345678910timeLine(btn) { btn.checked = !btn.checked; Viewer.timeline.container.style.display = btn.checked ? &quot;block&quot; : &quot;none&quot;; if (btn.checked) { Viewer.timeline.container.style.bottom = &quot;40px&quot;; setTimeout(() =&gt; { Viewer.timeline.resize(); // 强制触发 Cesium 时间轴的布局更新 }, 0); } },","link":"/2025/03/16/cesium%E6%8E%A7%E5%88%B6%E6%97%B6%E9%97%B4%E8%BD%B4%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"title":"cesium实现限高分析","text":"Cesium ClassificationPrimitive Cesium 的 ClassificationPrimitive 是一个用于在三维场景中分类地表或其他几何体的工具。这种分类通常用于在现有的地表或模型上应用覆盖效果，比如标记特定区域、着色或其他视觉效果，用于突出显示某些特征或为特定应用添加信息层。 地表分类： ClassificationPrimitive 主要用于对地表进行分类处理，可以为地形或模型表面覆盖一层指定的材质或颜色，通常用于高亮、区分不同区域的用途。 与现有几何体的交互： 它能够与地形、3D Tiles 或其他几何图形结合使用，提供了一种方法来在这些图形上绘制或标记数据，而不修改原始数据。 高度自定义的视觉效果： 支持自定义的材质和着色方式，可以通过指定的Appearance对象来定义如何渲染覆盖层，包括但不限于使用 GLSL 着色器来创建复杂的视觉效果。 ClassificationPrimitive 可用于高亮显示特定区域，如城市规划区、受保护地区等 12345678910111213141516171819202122232425RestrictHeight.prototype.addToMap = function () { this.removeFromMap(); if (!this.positions) { return; } const positions = Cesium.Cartesian3.fromDegreesArray(this.positions); const polygonInstance = new Cesium.GeometryInstance({ geometry: new Cesium.PolygonGeometry({ polygonHierarchy: new Cesium.PolygonHierarchy(positions), height: this.baseHeight, extrudedHeight: this.baseHeight + this.extrudedHeight, }), attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor(this.color), }, }); this.limitHeightPrimitive = this._coreMap.scene.primitives.add( new Cesium.ClassificationPrimitive({ geometryInstances: polygonInstance, releaseGeometryInstances: false, classificationType: Cesium.ClassificationType.CESIUM_3D_TILE, }) );};","link":"/2025/03/16/cesium%E5%AE%9E%E7%8E%B0%E9%99%90%E9%AB%98%E5%88%86%E6%9E%90/"},{"title":"cesium点聚合点击扩散点位","text":"1234567891011// 点击聚合点扩散功能earthCtrl.pick((data, pickObject, movement) =&gt; { if (!pickObject) { return; } if (Array.isArray(pickObject.id) &amp;&amp; pickObject.id.length &gt; 1) { const clusteredEntities = pickObject.id; // 聚合点的所有实体 const rate = 4; // 缩放倍数 clusterLayer.expandCluster(clusteredEntities, rate); }}); 123456789101112131415161718192021222324252627/* * 点击扩散聚合点 * @param {*} clusteredEntities * @param {*} rate */ClusterLayer.prototype.expandCluster = function (clusteredEntities, rate = 4) { let totalLon = 0; let totalLat = 0; clusteredEntities.forEach(entity =&gt; { const position = entity.position.getValue(Cesium.JulianDate.now()); const cartographic = Cesium.Cartographic.fromCartesian(position); totalLon += Cesium.Math.toDegrees(cartographic.longitude); totalLat += Cesium.Math.toDegrees(cartographic.latitude); }); const centerLon = totalLon / clusteredEntities.length; const centerLat = totalLat / clusteredEntities.length; const currentHeight = this._viewer.camera.positionCartographic.height; const targetHeight = currentHeight / rate; this._viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, targetHeight), duration: 1.5, });};","link":"/2025/03/16/cesium%E7%82%B9%E8%81%9A%E5%90%88%E7%82%B9%E5%87%BB%E6%89%A9%E6%95%A3%E7%82%B9%E4%BD%8D/"},{"title":"cesium烟雾粒子设置风速和风向","text":"12345678earthCtrl.factory.createSmoke({ lon: 117.15552507924421, lat: 31.833227044869062, alt: 0, heading: 3.7577140651352736, windSpeed: 0.1, windDirection: 0, // 传的是角度，0是正北， 90是从东向西， 180是正南，270是从西向东}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273import * as Cesium from &quot;../Cesium.js&quot;;/** * Created by jiangge on 2018/8/6. */import SpatialObject from &quot;../Scene/SpatialObject.js&quot;;import ExportObject from &quot;../Parser/ExportObject.js&quot;;/** * @alias Smoke * @classdesc 烟雾效果类 * @desc Effect */class Smoke extends SpatialObject { /** * 构造方法 * @param {EarthCtrl} earthCtrl 地图控件 * @param {Object} options 创建参数 * @param {String} [options.id] 对象的唯一id * @param {String} [options.name] 对象的名字 * @param {Number} [options.lon] 对象的经度 * @param {Number} [options.lat] 对象的纬度 * @param {Number} [options.alt] 对象的高程 * @param {Number} [options.particleSize] 粒子的大小，默认是30 * @param {Number} [options.heading] 地图中设置的偏航角，弧度，默认是0 * @param {Number} [options.windSpeed] 风速，默认是0 * @param {Number} [options.windDirection] 风向，默认是0 * @see ObjectFactory#createSmoke */ constructor(earthCtrl, options) { super(earthCtrl, options); this._rtti = &quot;Smoke&quot;; this._primitive = null; this._parameter = options; this._spatialTransform.createFromWgs84( options.lon, options.lat, options.alt, options.heading, options.pitch, options.roll ); this._coreMap = earthCtrl.coreMap; this._windSpeed = options.windSpeed || 0; this._windDirection = options.windDirection || 0; this._heading = options.heading || 0; } addToMap() { const parameter = this._parameter; const coreMap = this._coreMap; // var staticPosition = Cesium.Cartesian3.fromDegrees(parameter.lon, parameter.lat, parameter.alt); // var entity = earthCtrl.entities.add({ position:staticPosition, label: { text: &quot;&quot; } }); // function computeModelMatrix(entity, time) { // var position = Cesium.Property.getValueOrUndefined(entity.position, time); // var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position); // return modelMatrix; // } function computeEmitterModelMatrix() { const hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0); const trs = new Cesium.TranslationRotationScale(); trs.translation = Cesium.Cartesian3.fromElements(2.5, 4, 1); trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr); const result = Cesium.Matrix4.fromTranslationRotationScale(trs); return result; } const windSpeed = this._windSpeed; const windDirection = (this._windDirection - Cesium.Math.toDegrees(this._heading)) % 360; const windDirectionRadians = Cesium.Math.toRadians(windDirection); const windVector = new Cesium.Cartesian3( Math.cos(windDirectionRadians) * windSpeed, Math.sin(windDirectionRadians) * windSpeed, 0 ); console.log(`Wind Direction: ${windDirection} degrees`); console.log(`Wind Vector: ${windVector.x}, ${windVector.y}, ${windVector.z}`); const particleSize = Cesium.defaultValue(parameter.particleSize, 30.0); const primitive = coreMap.scene.primitives.add( new Cesium.ParticleSystem({ //image: Cesium.defaultValue(parameter.image, &quot;./Assets/image/smoke.png&quot;), image: Cesium.defaultValue( parameter.image, `${globalThis.GEOWORLD_BASE_URL}Assets/Images/smoke.png` ), startColor: Cesium.defaultValue(parameter.startColor, Cesium.Color.fromRgba(0xcc333333)), //粒子出生时的颜色 endColor: Cesium.defaultValue(parameter.endColor, Cesium.Color.fromRgba(0x44cccccc)), //当粒子死亡时的颜色 startScale: Cesium.defaultValue(parameter.startScale, 1.0), //粒子出生时的比例，相对于原始大小 endScale: Cesium.defaultValue(parameter.endScale, 4.0), //粒子在死亡时的比例 minimumParticleLife: Cesium.defaultValue(parameter.minimumParticleLife, 1.0), //设置粒子寿命的可能持续时间的最小界限（以秒为单位），粒子的实际寿命将随机生成 maximumParticleLife: Cesium.defaultValue(parameter.maximumParticleLife, 6.0), //设置粒子寿命的可能持续时间的最大界限（以秒为单位），粒子的实际寿命将随机生成 minimumSpeed: Cesium.defaultValue(parameter.minimumSpeed, 5.0), //设置以米/秒为单位的最小界限，超过该最小界限，随机选择粒子的实际速度。 maximumSpeed: Cesium.defaultValue(parameter.maximumSpeed, 20.0), //设置以米/秒为单位的最大界限，超过该最大界限，随机选择粒子的实际速度。 imageSize: new Cesium.Cartesian2(particleSize, particleSize), //如果设置该属性，将会覆盖 minimumImageSize和maximumImageSize属性，以像素为单位缩放image的大小 emissionRate: Cesium.defaultValue(parameter.emissionRate, 10.0), //每秒发射的粒子数。 bursts: [], lifetime: Cesium.defaultValue(parameter.lifeTime, 16.0), //多长时间的粒子系统将以秒为单位发射粒子 emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(30.0)), //此系统的粒子发射器 共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类 modelMatrix: this._spatialTransform.modelMatrix, // 4x4转换矩阵，可将粒子系统从模型转换为世界坐标 emitterModelMatrix: computeEmitterModelMatrix(), // 4x4转换矩阵，用于在粒子系统本地坐标系中转换粒子系统发射器 updateCallback: (particle, dt) =&gt; { particle.velocity = Cesium.Cartesian3.add( particle.velocity, windVector, new Cesium.Cartesian3() ); }, }) ); this._primitive = primitive; } /** * 从地图中移除 * @method * */ removeFromMap() { if (this._primitive !== null) { this._coreMap.scene.primitives.remove(this._primitive); } } toJSON() { const that = this; return ExportObject.export(that); }}Object.defineProperties(Smoke.prototype, { /** * 烟雾的参数 * @type Object * @memberof Smoke.prototype * @readonly */ parameter: { get: function () { return this._parameter; }, }, /** * 是否显示 * @type Boolean * @memberof Smoke.prototype * */ show: { get: function () { if (this._primitive !== null) { return this._primitive.show; } return false; }, set: function (val) { if (this._primitive !== null) { this._primitive.show = val; } }, }, /** * 名称 * @type String * @memberof Smoke.prototype * */ name: { get: function () { if (this._parameter !== null) { return this._parameter.name; } return false; }, set: function (val) { if (this._parameter !== null) { this._parameter.name = val; } }, }, /** * 经度 * @type Number * @memberof Smoke.prototype * */ lon: { get: function () { if (this._parameter !== null) { return this._lon; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._lon === val) { return; } this._parameter.lon = val; this._spatialTransform.createFromWgs84( this._parameter.lon, this._parameter.lat, this._parameter.alt, this._parameter.heading, this._parameter.pitch, this._parameter.roll ); this._primitive.modelMatrix = this._spatialTransform.modelMatrix; } }, }, /** * 纬度 * @type Number * @memberof Smoke.prototype * */ lat: { get: function () { if (this._parameter !== null) { return this._lat; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._lat === val) { return; } this._parameter.lat = val; this._spatialTransform.createFromWgs84( this._parameter.lon, this._parameter.lat, this._parameter.alt, this._parameter.heading, this._parameter.pitch, this._parameter.roll ); this._primitive.modelMatrix = this._spatialTransform.modelMatrix; } }, }, /** * * 粒子大小 * @type Number * @memberof Smoke.prototype * */ particleSize: { get: function () { if (this._primitive !== null) { return this._primitive.particleSize; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._parameter.particleSize === val) { return; } this._parameter.particleSize = val; this._primitive.imageSize = new Cesium.Cartesian2( this._parameter.particleSize, this._parameter.particleSize ); } }, },});export default Smoke;","link":"/2025/03/16/cesium%E7%83%9F%E9%9B%BE%E7%B2%92%E5%AD%90%E8%AE%BE%E7%BD%AE%E9%A3%8E%E9%80%9F%E5%92%8C%E9%A3%8E%E5%90%91/"},{"title":"光栅化","text":"光栅化 前边的部分我们学习了MVP矩阵，如何把一个物体投影到一个规则立方体内([-1,1]3)，如何把这个规则立方体内点的物体投影在屏幕上，转变为二维图像，这就是光栅化的过程、 屏幕 把东西画在屏幕上 当进行完 MVP 变换之后，所有需要绘制的点都变换到 的立方体空间中了。 下一步工作就是要把结果绘制到屏幕上，在这之前先了解一下什么是屏幕。 屏幕由一系列的像素(Pixel，是 Picture element 的缩写)排布形成，像素的数量由分辨率决定，如分辨率是 1920 x 1080 的屏幕，就包含了 1920 x 1080 个像素。 每个像素表示的颜色由红（red）、绿（green）、蓝（blue）三种颜色混合而成。 抗锯齿 MSAA (多重采样抗锯齿) 事实上，刚刚提到的计算像素覆盖面积的做法是很难实现的。但我们可以通过超采样的方式来模拟。 所谓的超采样，是指在一个像素里面放多个采样点来检测三角形是否有被覆盖。 :::color2MSAA 是抗锯齿操作的第一步，也就是模糊操作（求平均）。 MSAA 增加采样点，并不是为了提高采样率（分辨率没有提高），而是为了得到一个更合理的三角形覆盖率。 MSAA 的代价是计算量大增，如果一个像素里面有 4 个采样点，那么计算量就大了 4 倍；如果一个像素里面有 16 个采样点，那么计算量就大了 16 倍。（事实上，工业界会会复用、优化这些采样点，因此计算量并没有增加太多）。 ::: :::color2工作原理： 对每个像素进行多个采样点采样 计算采样点被物体覆盖的比例 根据比例决定最终像素颜色 优点： 图像质量好，特别是对几何边缘 没有时间性模糊问题 缺点： 性能开销大（采样点越多开销越大） 只对几何边缘有效，对材质/着色器内部产生的锯齿无效 ::: FXAA (快速近似抗锯齿) :::color2工作原理： 是后处理抗锯齿技术 在渲染完成后检测画面中的边缘 对检测到的边缘进行模糊处理 优点： 性能开销小 能处理所有类型的锯齿（包括着色器产生的） 缺点： 可能会使画面整体略显模糊 可能会丢失一些细节 ::: :::color2快速近似抗锯齿（Fast Approximate Anti-Aliasing，简称 FXAA）：大致上来说，该方法是在得到最终图像后的一种处理，通过分析最终得到的图像，找到锯齿边缘，通过柔化、模糊等方式处理锯齿边缘，降低锯齿的可视性，来达到抗锯齿的目的。FXAA 具有消耗低，速度快的优点。 ::: Cesium 默认使用的是 FXAA (Fast Approximate Anti-aliasing)。可以通过以下代码启用/禁用 FXAA： 选择 FXAA 的原因： 性能开销小，适合 Web 场景的实时渲染 实现简单，作为后处理技术易于集成 对 WebGL 支持良好，兼容性强 足以满足大多数地理可视化场景的需求 TAA (时间抗锯齿)、 :::color2 工作原理： 利用前面几帧的信息 在时间维度上进行采样和混合 通过抖动采样模式获取子像素信息 优点： 图像质量很好 性能开销适中 可以处理半透明物体和细节 缺点： 在运动场景中可能产生拖影 需要额外存储前帧信息 实现复杂度高 ::: :::color2 MSAA：追求画质、性能够用的场景 FXAA：追求性能、对画质要求不是特别高的场景 TAA：现代游戏引擎的主流选择，平衡了质量和性能 ::: :::color2时间性抗锯齿（Temporal Anti-Aliasing，简称 TAA）：和一般的抗锯齿对像素的采样不同，TAA 是对时间的采样，将上一帧已经得到的结果，作为当前帧的参考，避免直接计算当前帧像素的颜色值，而是复用或着说参考像素在之前帧的颜色值。会导致画面比较模糊，且对于运动的物体效果会很不好。TAA 有升级版，即 TXAA，实际为 TAA+MSAA 的组合。 ::: 重心坐标插值 ![](https://cdn.nlark.com/yuque/0/2025/png/276041/1737556826723-d1522d16-c7f8-4e03-8669-9e307419150b.png) 当顶点在纹理上的对应 uv 坐标成功找到之后，三角形三个顶点中间的值需要用三角形的重心坐标插值计算得到 插值的运算不仅仅在纹理中，包括三角形内部的颜色和法线都可以用插值来计算并由此得到一个平滑的过度。 满足这个说明点 p 在三角形内 这是求出了 p 点的纹理坐标 重心坐标(Barycentric Coordinates)是在计算机图形学中用于在三角形内部进行插值的一种技术。它的基本思想是：三角形内的任意一点都可以用三个权重来表示，这些权重表示了该点受三角形三个顶点的影响程度。 基本定义 假设有一个三角形 ABC，内部任意一点 P 可以表示为：P = αA + βB + γC ,其中 α + β + γ = 1，且 α,β,γ ≥ 0 α = Area(PBC)/Area(ABC) β = Area(PCA)/Area(ABC) γ = Area(PAB)/Area(ABC) 重心坐标的表示就是(α,β,γ),如 A 点的重心坐标就是(1,0,0)。那么如何确定任意一点的重心坐标呢？这里要通过面积比来算，如上图中一点的坐标，α,β,γ 各个值就是另两个顶点连成的三角形在总面积的占比，如上图所示。 因为 ACA 的面积是 0， 所以 A 点的 β 是 0 而通过如上的表示，我们马上可以找到一个及其特殊的点，就是三角形自己的重心，它的重心坐标是(1/3,1/3,1/3)，这个点与三个顶点连线分成的三个三角形面积也恰好相等。 上图为对于三角形内任意一点的重心坐标计算的通用表达式 通过以上的介绍，我们知道了三角形内部的任意一点的坐标可以通过重心坐标求出表示出来，那么我们也可以利用重心坐标求三角形内部任意一点的其它属性，其他三角形内部的属性也可以用重心坐标的线性组合表示出来，如上图的颜色插值。（注意：重心坐标并没有投影下不变的性质，所以在插值如深度这种空间中的性质时，应该先在 3D 空间中用三维的坐标算出三维空间中的重心坐标进行插值，然后再放回而不能直接在投影之后的三角形中做插值。至于如何在已经投影的三角形在回到三维空间，应用逆变换即可。） 12345// 假设三个顶点都有颜色属性Color interpolatedColor = α * colorA + β * colorB + γ * colorC;// 纹理坐标插值UV interpolatedUV = α * uvA + β * uvB + γ * uvC;","link":"/2025/03/15/%E5%85%89%E6%A0%85%E5%8C%96/"}],"tags":[{"name":"cesium","slug":"cesium","link":"/tags/cesium/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"渲染","slug":"渲染","link":"/tags/%E6%B8%B2%E6%9F%93/"}],"categories":[{"name":"cesium","slug":"cesium","link":"/categories/cesium/"},{"name":"图形学","slug":"图形学","link":"/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"pages":[]}