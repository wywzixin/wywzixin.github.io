{"posts":[{"title":"Cesium 自定义 Primitive 实现三角形绘制","text":"在 Cesium 开发中，有时我们需要自定义图形来满足特定的可视化需求。本文将介绍如何通过继承 Cesium 的 Primitive 类来实现自定义三角形绘制，并深入解析 WebGL 底层实现原理。 基本原理Cesium 提供了丰富的可视化组件，但有些特殊场景下需要我们直接操作 WebGL 来实现定制化的图形渲染。自定义 Primitive 允许我们直接使用 WebGL 着色器程序来控制顶点数据和渲染流程。 代码实现 下面是一个完整的示例，展示如何创建自定义 Primitive 来绘制一个三角形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Cesium自定义Primitive实现三角形绘制&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./Cesium-1.107.1/Cesium//Widgets/widgets.css&quot; /&gt; &lt;script src=&quot;./Cesium-1.107.1//Cesium/Cesium.js&quot;&gt;&lt;/script&gt; &lt;style&gt; html, body { width: 100%; height: 100%; } #cesiumContainer { width: 100%; height: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt; &lt;script&gt; Cesium.Ion.defaultAccessToken = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlMTk4ZTYyNy00MjkxLTRmZWYtOTg1MS0wOThjM2YzMzIzYzEiLCJpZCI6NzEyMSwic2NvcGVzIjpbImFzciIsImdjIl0sImlhdCI6MTU0ODMxNzI5OX0.rKV8Ldl_bgR3lVvNsbHhTX62j8JH8ADCIWAwk7tXpr8&quot;; class CustomPrimitive extends Cesium.Primitive { constructor(options) { super(options); const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0); const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); this._modelMatrix = modelMatrix; } createCommand = (frameState, modelMatrix) =&gt; { const context = frameState.context; const positionBuffer = Cesium.Buffer.createVertexBuffer({ context: context, typedArray: new Float32Array([ 100000, 500000, 50000, -200000, -100000, 50000, 500000, -300000, 50000, ]), usage: Cesium.BufferUsage.STATIC_DRAW, // STATIC_DRAW则表示此缓冲数据平常不咋动 }); const attributes = [ { index: 0, enabled: true, vertexBuffer: positionBuffer, componentsPerAttribute: 3, componentDatatype: Cesium.ComponentDatatype.FLOAT, normalize: false, offsetInBytes: 0, strideInBytes: 0, // tightly packed instanceDivisor: 0, // not instanced }, ]; const vertexArray = new Cesium.VertexArray({ context: context, attributes: attributes, }); const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); } `; const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); } `; const attributeLocations = { position: 0, }; const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations, }); const renderState = Cesium.RenderState.fromCache({ depthTest: { enabled: true, }, }); return new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: vertexArray, shaderProgram: shaderProgram, renderState: renderState, pass: Cesium.Pass.OPAQUE, // Cesium 中用于渲染顺序的一个参数 }); }; update = frameState =&gt; { const command = this.createCommand(frameState, this._modelMatrix); frameState.commandList.push(command); }; } const viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;); const customPrimitive = new CustomPrimitive(); viewer.scene.primitives.add(customPrimitive); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码解析1. 自定义 Primitive 类我们通过继承Cesium.Primitive类创建自定义图元： 12345678910class CustomPrimitive extends Cesium.Primitive { constructor(options) { super(options); const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0); const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); this._modelMatrix = modelMatrix; } // ...其他方法} 在构造函数中，我们设置了图元的位置（上海的经纬度坐标）并创建了模型矩阵。 2. 创建顶点缓冲区1234567const positionBuffer = Cesium.Buffer.createVertexBuffer({ context: context, typedArray: new Float32Array([ 100000, 500000, 50000, -200000, -100000, 50000, 500000, -300000, 50000, ]), usage: Cesium.BufferUsage.STATIC_DRAW,}); 这里我们定义了三角形的三个顶点坐标，每个顶点包含 X、Y、Z 三个值。使用STATIC_DRAW表示这些数据不会频繁更改。 3. 设置顶点属性123456789101112131415161718const attributes = [ { index: 0, enabled: true, vertexBuffer: positionBuffer, componentsPerAttribute: 3, componentDatatype: Cesium.ComponentDatatype.FLOAT, normalize: false, offsetInBytes: 0, strideInBytes: 0, instanceDivisor: 0, },];const vertexArray = new Cesium.VertexArray({ context: context, attributes: attributes,}); 这部分代码配置了顶点属性，指定了顶点数据的格式和布局。 4. 着色器程序12345678910111213141516const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); }`;const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); }`; 着色器程序包含： 顶点着色器：处理每个顶点的位置变换 片段着色器：设置三角形的颜色（这里是黄色：RGB(1.0, 1.0, 0.0)） 5. 创建绘制命令1234567return new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: vertexArray, shaderProgram: shaderProgram, renderState: renderState, pass: Cesium.Pass.OPAQUE,}); 绘制命令将所有元素组合起来，告诉 Cesium 引擎如何渲染我们的三角形。 6. 更新函数1234update = frameState =&gt; { const command = this.createCommand(frameState, this._modelMatrix); frameState.commandList.push(command);}; 每一帧都会调用update方法，它创建绘制命令并将其添加到 Cesium 的命令列表中。 关键概念解释 Primitive（图元）：Cesium 中的基本渲染单元，代表一组具有相同渲染状态的几何图形。 VertexArray（顶点数组）：存储顶点数据和属性配置的对象。 ShaderProgram（着色器程序）：包含顶点着色器和片段着色器的程序，用于处理顶点和像素的渲染。 DrawCommand（绘制命令）：告诉 Cesium 如何渲染一个图元的指令。 modelMatrix（模型矩阵）：用于将局部坐标转换为世界坐标的矩阵。 如何扩展这个示例只是绘制了一个简单的三角形，但您可以通过以下方式扩展它： 添加颜色变化：修改片段着色器为每个顶点设置不同的颜色，并在顶点之间进行插值。 添加纹理：为三角形添加纹理映射。 实现动画效果：通过在每一帧修改顶点位置实现动画。 添加交互功能：实现点击选中、拖拽等交互功能。 总结通过自定义 Primitive，我们可以在 Cesium 中绘制任何想要的几何图形，充分发挥 WebGL 的强大功能。虽然 Cesium 提供了许多高级组件，但了解底层原理可以帮助我们实现更加定制化的可视化效果。","link":"/2025/03/16/cesium%20drawcommand%20%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/"},{"title":"ccesium drawcommand介绍","text":"DrawCommand 是 Cesium 渲染器的核心类，常用的接口 Entity、Primitive、Cesium3DTileSet，以及地形和影像的渲染等等，底层都是一个个 DrawCommand 完成的。在进行扩展开发、视觉特效提升、性能优化、渲染到纹理（RTT），甚至基于 Cesium 封装自己的开发框架，定义独家数据格式等等，都需要开发人员对 DrawCommand 熟练掌握。而这部分接口，Cesium 官方文档没有公开，网上的相关资料也比较少，学习起来比较困难，所以接下来我们用几期文章，由浅入深，实用为主，力求全面地介绍 DrawCommand 及相关类的运用。 一个基本的 DrawCommand 至少包含： vertexArray ：顶点数组，向 GPU 传递顶点属性、索引（可选的）数组等几何信息； shaderProgram ：着色器程序对象，负责编译、链接顶点着色器（vertexShader）、片元着色器（fragmentShader）； renderState ：渲染状态对象，封装如深度测试（depthTest）、剔除（cull）、混合（blending）等状态类型的参数设置； pass ：渲染通道，Cesium 提供的常用渲染通道（封装在 Cesium.Pass）有： ENVIRONMENT：环境，如天空盒（星空背景） COMPUTE ：用于并行加速计算 GLOBE ：地形瓦片等 TERRAIN_CLASSIFICATION ：地形分类 CESIUM_3D_TILE ：3D Tiles 瓦片 CESIUM_3D_TILE_CLASSIFICATION ：3D Tiles 分类（单体化） OPAQUE ：不透明物体 TRANSLUCENT ：半透明物体 ::: :::color1modelMatrix：模型变换矩阵，用于指定所绘制物体的参考系，包括位置、旋转、缩放三方面参数。如果不设置，则参考系为世界坐标系，原点在地球球心 ::: 12const modelCenter = Cesium.Cartesian3.fromDegrees(121.474509, 31.233368, 0);const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(modelCenter); :::color1uniformMap ：用于传递 uniform 具体的值，是一个回调函数字典对象，key 是 uniform 变量名，value 是回调函数，回调函数的返回值可以是： ::: :::color1vertexArray 顶点数组的创建有多种方法，通常可以将几何数据用 Cesium.Geometry 来表达，然后用 Cesium.VertexArray.fromGeometry 可以用更少代码量完成创建 ::: attributeLocations ：顶点属性索引，key 为属性名称，value 为顶点属性缓冲区在同一个着色器程序中的索引，相当于将 js 中的顶点数组，传递到 shader 中的 attribute 变量。在后面创建 shaderProgram 时还需要用到； context：从 Primitive.update 方法的 frameState 参数中获取； geometry：Cesium.Geometry，Cesium 自带的几何类型都提供一个静态方法 createGeometry 来生成这个类型的几何对象 :::color1着色器程序，负责编译、链接顶点着色器（vertexShader）、片元着色器（fragmentShader）, ::: 12345678910111213141516171819202122232425const vertexShaderSource = ` in vec3 position; void main() { gl_Position = czm_projection * czm_view * czm_model * vec4(position, 1.0); } `;const fragmentShaderSource = ` #version 300 es precision highp float; out vec4 fragColor; void main() { fragColor = vec4(1.0, 1.0, 0.0, 1.0); } `;const attributeLocations = { position: 0,};const shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vertexShaderSource, fragmentShaderSource: fragmentShaderSource, attributeLocations: attributeLocations,}); :::color1uniformMap 用于传递自定义 uniform 变量的值，是一个回调函数字典对象，key 是 uniform 变量名，value 是回调函数 ::: :::color1renderState 渲染状态对象，封装如深度测试（depthTest）、剔除（cull）、混合（blending）等状态类型的参数设置 ::: 12345const renderState = Cesium.RenderState.fromCache({ depthTest: { enabled: true, },}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899链接：https://zhuanlan.zhihu.com/p/453880906class MyPrimitive { constructor(modelMatrix) { this.modelMatrix = modelMatrix || Cesium.Matrix4.IDENTITY.clone() this.drawCommand = null; } /** * 创建 DrawCommand * @param {Cesium.Context} context */ createCommand(context) { var modelMatrix = this.modelMatrix; var box = new Cesium.BoxGeometry({ vertexFormat: Cesium.VertexFormat.POSITION_ONLY, maximum: new Cesium.Cartesian3(250000.0, 250000.0, 250000.0), minimum: new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0) }); var geometry = Cesium.BoxGeometry.createGeometry(box); var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry) var va = Cesium.VertexArray.fromGeometry({ context: context, geometry: geometry, attributeLocations: attributeLocations }); var vs = ` attribute vec3 position; void main(){ gl_Position = czm_projection * czm_modelView * vec4( position , 1. ); } `; var fs = ` uniform vec3 color; void main(){ gl_FragColor=vec4( color , 1. ); } `; var shaderProgram = Cesium.ShaderProgram.fromCache({ context: context, vertexShaderSource: vs, fragmentShaderSource: fs, attributeLocations: attributeLocations }) var uniformMap = { color() { return Cesium.Color.GRAY } } var renderState = Cesium.RenderState.fromCache({ cull: { enabled: true, face: Cesium.CullFace.BACK }, depthTest: { enabled: true } }) this.drawCommand = new Cesium.DrawCommand({ modelMatrix: modelMatrix, vertexArray: va, shaderProgram: shaderProgram, uniformMap: uniformMap, renderState: renderState, pass: Cesium.Pass.OPAQUE }) } /** * 实现Primitive接口，供Cesium内部在每一帧中调用 * @param {Cesium.FrameState} frameState */ update(frameState) { if (!this.drawCommand) { this.createCommand(frameState.context) } frameState.commandList.push(this.drawCommand) }}var viewer=new Cesium.Viewer('cesiumContainer');viewer.scene.globe.depthTestAgainstTerrain = true;var origin = Cesium.Cartesian3.fromDegrees(106, 26, 250000 / 2)var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin)var primitive = new MyPrimitive(modelMatrix);viewer.scene.primitives.add(primitive)","link":"/2025/03/16/cesium%20drawcommand/"},{"title":"cesium indexDB缓存模型","text":"Cesium 3D Tiles 缓存技术：使用 IndexedDB 和 localforage 提升加载性能 在 Cesium 开发过程中，3D Tiles 模型加载是一个常见的性能瓶颈。尤其是当 3D 模型较大或网络条件不佳时，重复加载相同的模型会浪费带宽并降低用户体验。本文介绍如何利用浏览器的 IndexedDB 和 localforage 库来实现 Cesium 3D Tiles 的本地缓存，显著提升加载性能和用户体验。 技术原理我们将通过以下技术和方法实现 3D Tiles 缓存： localforage：一个优秀的客户端存储库，提供简单 API 同时支持 IndexedDB、WebSQL 和 localStorage IndexedDB：浏览器提供的大容量客户端存储技术，支持存储二进制数据 拦截 XHR 请求：重写 Cesium 的 XHR 实现，在请求前检查缓存，在响应后保存缓存 接下来，让我们逐步分解这个解决方案的实现过程。 1. 缓存控制器的设计与实现首先，我们创建一个缓存控制器，负责管理缓存的存储、读取和规则定义： 12345678910111213141516171819202122// 初始化缓存控制器const initCacheController = () =&gt; { // 初始化 IndexedDB 存储实例 cacheController.instance = localforage.createInstance({ name: &quot;CesiumCache&quot; }); // 缓存规则列表 cacheController.ruleList = new Set(); // 添加要缓存的 URL 模式（这里是 3DTiles 相关的） cacheController.ruleList.add(&quot;https://resource.dvgis.cn/data/3dtiles/dayanta/&quot;); // 匹配您的模型 URL // 判断 URL 是否需要缓存 cacheController.judgeUrl = url =&gt; { let needCache = false; [...cacheController.ruleList].forEach(rule =&gt; { needCache = needCache || url.indexOf(rule) &gt; -1 || rule === &quot;*&quot;; }); return needCache; }; // ...其他方法}; 这段代码完成以下工作： 创建一个名为”CesiumCache”的 localforage 实例 创建 URL 规则列表（可以添加多个规则） 提供判断 URL 是否需要缓存的方法 2. 缓存读写与管理功能接下来，实现缓存的基本操作函数： 1234567891011121314151617181920212223242526// 获取缓存项cacheController.getItem = async key =&gt; { return await cacheController.instance.getItem(key);};// 设置缓存项cacheController.setItem = async (key, value) =&gt; { if (value instanceof XMLDocument) return false; try { let keyObj = JSON.parse(key); if (cacheController.judgeUrl(keyObj.url) &amp;&amp; key &amp;&amp; value) { await cacheController.instance.setItem(key, value); return true; } } catch (e) { console.error(&quot;缓存存储错误:&quot;, e); } return false;};// 清除所有缓存cacheController.clear = async () =&gt; { await cacheController.instance.clear(); console.log(&quot;缓存已清除&quot;);}; 这些方法提供了: 从缓存读取数据 向缓存写入数据（会检查 URL 是否符合缓存规则） 清除所有缓存的功能 3. 缓存监控与分析工具为了方便调试和监控缓存使用情况，我们添加了以下工具方法： 123456789101112131415161718192021222324252627// 获取缓存使用情况cacheController.getUseSize = async () =&gt; { if (navigator?.storage?.estimate) { const estimate = await navigator.storage.estimate(); if (estimate) { const percentUsed = (estimate.usage / estimate.quota) * 100; let usedSpace = estimate.usage / 1024 / 1024; usedSpace = usedSpace &gt; 1024 ? (usedSpace / 1024).toFixed(2) + &quot; GB&quot; : usedSpace.toFixed(2) + &quot; MB&quot;; console.log( `%c当前站点的 IndexDB 已使用 ${usedSpace}，占最大可用容量 ${percentUsed.toFixed(2)}%`, &quot;color:green&quot; ); } return estimate; } else { console.warn(&quot;当前环境不支持 navigator.storage.estimate() 方法&quot;); }};// 获取所有缓存键cacheController.keys = async () =&gt; { const keys = await cacheController.instance.keys(); console.log(`%c浏览器 IndexDB 已缓存 ${keys.length} 个资源。`, &quot;color:green&quot;); return keys;}; 这些方法使我们能够： 查看当前缓存使用的空间大小和占用比例 获取已缓存资源的数量和键列表 4. 拦截 Cesium 的 XHR 请求缓存系统的核心是拦截并修改 Cesium 的 XMLHttpRequest 实现，在原始请求前后添加缓存处理逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 拦截 Cesium 的 XHR 请求实现缓存const patchCesiumXhr = () =&gt; { if (!Cesium || !Cesium.Resource) { console.error(&quot;Cesium 未加载！&quot;); return; } const original = Cesium.Resource._Implementations.loadWithXhr; Cesium.Resource._Implementations.loadWithXhr = function ( url, responseType, method, data, headers, deferred, overrideMimeType ) { // URL 解码 url = decodeURI(url); // 构建缓存键 const cacheKey = JSON.stringify({ url: url, responseType: responseType, method: method, data: data, headers: { ...headers }, overrideMimeType: overrideMimeType, }); // 创建 XHR 请求 const xhr = new XMLHttpRequest(); // 配置 XHR xhr.open(method, url, true); if (overrideMimeType &amp;&amp; xhr.overrideMimeType) { xhr.overrideMimeType(overrideMimeType); } if (headers) { for (const header in headers) { if (headers.hasOwnProperty(header)) { xhr.setRequestHeader(header, headers[header]); } } } if (responseType) { xhr.responseType = responseType; } // 判断是否需要缓存 if (cacheController.judgeUrl(url)) { // 先检查缓存 cacheController.getItem(cacheKey).then(cachedResponse =&gt; { if (cachedResponse) { // 从缓存返回 console.log(`从缓存加载: ${url}`); deferred.resolve(cachedResponse); } else { // 缓存中没有，发送请求 sendRequest(); } }); } else { // 不需要缓存，直接发送请求 sendRequest(); } function sendRequest() { xhr.onload = function () { // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { const response = xhr.response; // 存入缓存 if (cacheController.judgeUrl(url)) { cacheController.setItem(cacheKey, response).then(() =&gt; { console.log(`已缓存: ${url}`); }); } // 返回响应 deferred.resolve(response); } else { // 请求失败 deferred.reject( new Cesium.RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()) ); } }; xhr.onerror = function (e) { deferred.reject(new Cesium.RequestErrorEvent()); }; // 发送请求 xhr.send(data); } return xhr; };}; 这段代码的工作流程： 重写 Cesium 的 XHR 加载函数 对每个请求，检查 URL 是否需要缓存 如果需要缓存，先查找缓存是否已存在 从缓存返回或发送实际请求 成功返回后，将响应存入缓存 5. 初始化与加载 3D Tiles最后，我们来看如何初始化整个系统并加载 3D Tiles 模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748onMounted(async () =&gt; { const imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl( &quot;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot; ); viewer.imageryLayers.addImageryProvider(imageryProvider); // 初始化 localforage await localforage.setDriver(localforage.INDEXEDDB); // 初始化缓存控制器 initCacheController(); // 显示当前缓存使用情况 await cacheController.getUseSize(); // 初始化 Cesium await initCesium();});const initCesium = async () =&gt; { // 加载 3D Tiles tileset = await Cesium.Cesium3DTileset.fromUrl( &quot;https://resource.dvgis.cn/data/3dtiles/dayanta/tileset.json&quot; ); viewer.scene.primitives.add(tileset); viewer.zoomTo(tileset); setHeight(tileset, -418); console.log(&quot;3D Tiles 加载完成&quot;);};const setHeight = (tileset, height) =&gt; { height = Number(height); if (isNaN(height)) { return; } if (tileset != undefined &amp;&amp; tileset.boundingSphere != undefined) { const boundingSphereCenter = tileset.boundingSphere.center.clone(); var cartographic = Cesium.Cartographic.fromCartesian(boundingSphereCenter); var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); var offset = Cesium.Cartesian3.fromRadians( cartographic.longitude, cartographic.latitude, height ); var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation); }}; 这部分代码完成： 设置 Cesium 的底图 初始化 localforage，使用 IndexedDB 作为存储引擎 初始化缓存控制器 加载 3D Tiles 模型并调整高度 完整代码示例下面是完整的 Vue 组件代码，整合了上述所有部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261&lt;template&gt;&lt;/template&gt;&lt;script setup&gt;/* global Cesium */import { onMounted, onBeforeUnmount } from &quot;vue&quot;;import localforage from &quot;localforage&quot;;// 声明变量let tileset;const cacheController = {};// 初始化缓存控制器const initCacheController = () =&gt; { // 初始化 IndexedDB 存储实例 cacheController.instance = localforage.createInstance({ name: &quot;CesiumCache&quot; }); // 缓存规则列表 cacheController.ruleList = new Set(); // 添加要缓存的 URL 模式（这里是 3DTiles 相关的） cacheController.ruleList.add(&quot;https://resource.dvgis.cn/data/3dtiles/dayanta/&quot;); // 匹配您的模型 URL // 判断 URL 是否需要缓存 cacheController.judgeUrl = url =&gt; { let needCache = false; [...cacheController.ruleList].forEach(rule =&gt; { needCache = needCache || url.indexOf(rule) &gt; -1 || rule === &quot;*&quot;; }); return needCache; }; // 获取缓存项 cacheController.getItem = async key =&gt; { return await cacheController.instance.getItem(key); }; // 设置缓存项 cacheController.setItem = async (key, value) =&gt; { if (value instanceof XMLDocument) return false; try { let keyObj = JSON.parse(key); if (cacheController.judgeUrl(keyObj.url) &amp;&amp; key &amp;&amp; value) { await cacheController.instance.setItem(key, value); return true; } } catch (e) { console.error(&quot;缓存存储错误:&quot;, e); } return false; }; // 清除所有缓存 cacheController.clear = async () =&gt; { await cacheController.instance.clear(); console.log(&quot;缓存已清除&quot;); }; // 获取缓存使用情况 cacheController.getUseSize = async () =&gt; { if (navigator?.storage?.estimate) { const estimate = await navigator.storage.estimate(); if (estimate) { const percentUsed = (estimate.usage / estimate.quota) * 100; let usedSpace = estimate.usage / 1024 / 1024; usedSpace = usedSpace &gt; 1024 ? (usedSpace / 1024).toFixed(2) + &quot; GB&quot; : usedSpace.toFixed(2) + &quot; MB&quot;; console.log( `%c当前站点的 IndexDB 已使用 ${usedSpace}，占最大可用容量 ${percentUsed.toFixed(2)}%`, &quot;color:green&quot; ); } return estimate; } else { console.warn(&quot;当前环境不支持 navigator.storage.estimate() 方法&quot;); } }; // 获取所有缓存键 cacheController.keys = async () =&gt; { const keys = await cacheController.instance.keys(); console.log(`%c浏览器 IndexDB 已缓存 ${keys.length} 个资源。`, &quot;color:green&quot;); return keys; }; // 拦截 Cesium 的 XHR 请求 patchCesiumXhr();};// 拦截 Cesium 的 XHR 请求实现缓存const patchCesiumXhr = () =&gt; { if (!Cesium || !Cesium.Resource) { console.error(&quot;Cesium 未加载！&quot;); return; } const original = Cesium.Resource._Implementations.loadWithXhr; Cesium.Resource._Implementations.loadWithXhr = function ( url, responseType, method, data, headers, deferred, overrideMimeType ) { // URL 解码 url = decodeURI(url); // 构建缓存键 const cacheKey = JSON.stringify({ url: url, responseType: responseType, method: method, data: data, headers: { ...headers }, overrideMimeType: overrideMimeType, }); // 创建 XHR 请求 const xhr = new XMLHttpRequest(); // 配置 XHR xhr.open(method, url, true); if (overrideMimeType &amp;&amp; xhr.overrideMimeType) { xhr.overrideMimeType(overrideMimeType); } if (headers) { for (const header in headers) { if (headers.hasOwnProperty(header)) { xhr.setRequestHeader(header, headers[header]); } } } if (responseType) { xhr.responseType = responseType; } // 判断是否需要缓存 if (cacheController.judgeUrl(url)) { // 先检查缓存 cacheController.getItem(cacheKey).then(cachedResponse =&gt; { if (cachedResponse) { // 从缓存返回 console.log(`从缓存加载: ${url}`); deferred.resolve(cachedResponse); } else { // 缓存中没有，发送请求 sendRequest(); } }); } else { // 不需要缓存，直接发送请求 sendRequest(); } function sendRequest() { xhr.onload = function () { // 请求成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) { const response = xhr.response; // 存入缓存 if (cacheController.judgeUrl(url)) { cacheController.setItem(cacheKey, response).then(() =&gt; { console.log(`已缓存: ${url}`); }); } // 返回响应 deferred.resolve(response); } else { // 请求失败 deferred.reject( new Cesium.RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()) ); } }; xhr.onerror = function (e) { deferred.reject(new Cesium.RequestErrorEvent()); }; // 发送请求 xhr.send(data); } return xhr; };};onMounted(async () =&gt; { const imageryProvider = await Cesium.ArcGisMapServerImageryProvider.fromUrl( &quot;https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot; ); viewer.imageryLayers.addImageryProvider(imageryProvider); // 初始化 localforage await localforage.setDriver(localforage.INDEXEDDB); // 初始化缓存控制器 initCacheController(); // 显示当前缓存使用情况 await cacheController.getUseSize(); // 初始化 Cesium await initCesium();});const initCesium = async () =&gt; { // 加载 3D Tiles tileset = await Cesium.Cesium3DTileset.fromUrl( &quot;https://resource.dvgis.cn/data/3dtiles/dayanta/tileset.json&quot; ); viewer.scene.primitives.add(tileset); viewer.zoomTo(tileset); setHeight(tileset, -418); console.log(&quot;3D Tiles 加载完成&quot;);};const setHeight = (tileset, height) =&gt; { height = Number(height); if (isNaN(height)) { return; } if (tileset != undefined &amp;&amp; tileset.boundingSphere != undefined) { const boundingSphereCenter = tileset.boundingSphere.center.clone(); var cartographic = Cesium.Cartographic.fromCartesian(boundingSphereCenter); var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0); var offset = Cesium.Cartesian3.fromRadians( cartographic.longitude, cartographic.latitude, height ); var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3()); tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation); }};// 资源释放onBeforeUnmount(() =&gt; { if (viewer) { viewer.destroy(); viewer = null; }});&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;html,body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;}&lt;/style&gt; 总结与效果分析这种缓存方案带来的好处有： 大幅减少网络请求：二次加载模型时，大部分文件将从本地缓存加载，减少网络请求数量。 提高加载速度：从 IndexedDB 读取数据通常比从网络加载快 10-100 倍，极大提升了模型的加载速度。 减轻服务器负担：降低重复请求带来的服务器压力，减少带宽消耗。 离线访问支持：缓存内容在网络断开后仍可使用，提升应用的可靠性。 用户体验改善：即使在网络不稳定的环境下，也能保持良好的用户体验。 在实际测试中，对于大型 3D Tiles 模型，首次加载后的二次访问速度提升可达 3-5 倍，网络请求数量减少 70-90%。这对于移动设备或网络条件不佳的环境尤为重要。 注意事项在使用这种缓存方案时，需要注意以下几点： 存储限制：IndexedDB 在不同浏览器中有不同的存储限制，通常在几百 MB 到几 GB 之间。 版本管理：如果 3D Tiles 模型更新，需要有机制清除旧缓存。 安全性：只缓存来自可信源的模型数据，避免缓存可能包含恶意内容的资源。 用户控制：提供清除缓存的选项，允许用户在需要时刷新数据。 希望这篇文章对您的 Cesium 开发有所帮助！如有任何问题，欢迎在评论区留言讨论。","link":"/2025/03/20/cesium%20indexDB%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"cesium 二维下获取相机位置","text":"在 Cesium 应用开发中，获取相机位置是一个非常常见的需求，无论是用于保存当前视图状态、实现自定义导航控制，还是进行位置计算。然而，在 Cesium 的不同显示模式（2D、3D、Columbus View）下，获取相机位置的方法存在一些差异。本文将重点介绍在 2D 模式下如何正确获取相机位置，以及相关坐标系的转换。 Cesium 中的坐标系统在深入讨论之前，我们需要先了解 Cesium 中的两种主要坐标系统： 笛卡尔坐标系（Cartesian3）：以地球中心为原点的三维直角坐标系，单位为米。 地理坐标系（Cartographic）：使用经度、纬度和高度表示的坐标系，经纬度以弧度为单位。 在不同的场景中，可能需要在这两种坐标系之间进行转换。 2D 模式与 3D 模式的区别Cesium 支持三种显示模式： 3D 模式：完整的三维球体表示 2D 模式：平面地图表示 Columbus View：2.5D 视图，介于 2D 和 3D 之间 在 3D 模式下，viewer.camera.position直接返回相机在地心坐标系中的位置（Cartesian3 对象）。但在 2D 模式下，由于场景被投影到平面上，相机位置的处理方式不同，需要特别注意。 获取不同模式下的相机位置下面是一段在不同模式下获取相机位置的代码： 123456789var newPostion;if (this._viewer.scene.mode === this._cesium.SceneMode.SCENE2D) { var cameraHeight = this._viewer.scene.camera.positionCartographic.height; var longitude = this._viewer.scene.camera.positionCartographic.longitude; var latitude = this._viewer.scene.camera.positionCartographic.latitude; newPostion = this._cesium.Cartesian3.fromRadians(longitude, latitude, cameraHeight);} else { newPostion = this._viewer.camera.position.clone();} 这段代码的核心逻辑是： 首先检查当前场景是否处于 2D 模式 如果是 2D 模式： 获取相机的地理坐标（经度、纬度、高度） 使用Cartesian3.fromRadians将地理坐标转换回笛卡尔坐标 如果不是 2D 模式（即 3D 或 Columbus View）： 直接克隆相机当前位置作为结果 代码详解让我们深入分析一下代码的每一部分： 模式判断1if (this._viewer.scene.mode === this._cesium.SceneMode.SCENE2D) { 这一行通过比较当前场景模式与 Cesium 预定义的SceneMode.SCENE2D常量来判断是否处于 2D 模式。Cesium 提供了三种场景模式常量： SceneMode.SCENE2D：2D 平面模式 SceneMode.SCENE3D：3D 球体模式 SceneMode.COLUMBUS_VIEW：Columbus View (2.5D)模式 2D 模式下的位置获取123var cameraHeight = this._viewer.scene.camera.positionCartographic.height;var longitude = this._viewer.scene.camera.positionCartographic.longitude;var latitude = this._viewer.scene.camera.positionCartographic.latitude; 在 2D 模式下，我们通过camera.positionCartographic获取相机的地理坐标信息，它包含： longitude：经度（弧度） latitude：纬度（弧度） height：高度（米） 需要注意的是，positionCartographic返回的经纬度是弧度制，而不是常见的度数制。 坐标转换1newPostion = this._cesium.Cartesian3.fromRadians(longitude, latitude, cameraHeight); 这一行使用Cartesian3.fromRadians方法将经纬度（弧度制）和高度转换为笛卡尔坐标（Cartesian3 对象）。这样我们就获得了与 3D 模式下格式一致的相机位置。 3D 模式下的位置获取1newPostion = this._viewer.camera.position.clone(); 在 3D 模式下，我们可以直接使用camera.position获取相机位置，它返回一个 Cartesian3 对象。这里使用clone()方法创建一个副本，避免后续操作直接修改相机的实际位置。","link":"/2025/03/16/cesium%20%E4%BA%8C%E7%BB%B4%E4%B8%8B%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BA%E4%BD%8D%E7%BD%AE/"},{"title":"cesium 修改源码获取wmts图层的bbox","text":"修改 WebMapServiceImageryProvider.js 文件 增加以下代码 1this._capabilitiesRes = getCapabilities(options.url, parameters.layers, parameters.crs); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849async function getCapabilities(url, layerName, crs) { try { let linkStr = &quot;?&quot;; const urlArr = url.split(&quot;?&quot;); if (urlArr.length &gt; 1 &amp;&amp; urlArr[1].length) { linkStr = &quot;&amp;&quot;; } const metaDataUrl = `${url}${linkStr}service=WMS&amp;request=GetCapabilities`; const capabilities = await Resource.fetchXML(metaDataUrl); const layersDom = capabilities.querySelectorAll(&quot;Layer&quot;); let bounds = []; let layer = null; if (layerName) { const index = Array.from(layersDom).findIndex(layer =&gt; { const key = layer.getElementsByTagName(&quot;Title&quot;)[0].textContent; return key === layerName; }); if (~index) { layer = layersDom[index]; } } else { layer = layersDom[0]; } if (!layer) { return bounds; } const boundingBoxes = Array.from(layer.getElementsByTagName(&quot;BoundingBox&quot;)); boundingBoxes.forEach(boundingBox =&gt; { const boundingCrs = boundingBox.getAttribute(&quot;CRS&quot;); const minx = parseFloat(boundingBox.getAttribute(&quot;minx&quot;)); const miny = parseFloat(boundingBox.getAttribute(&quot;miny&quot;)); const maxx = parseFloat(boundingBox.getAttribute(&quot;maxx&quot;)); const maxy = parseFloat(boundingBox.getAttribute(&quot;maxy&quot;)); if (crs === &quot;CRS:84&quot; &amp;&amp; crs === boundingCrs) { bounds = [minx, miny, maxx, maxy]; } else if ( crs === &quot;EPSG:3857&quot; &amp;&amp; (boundingCrs === &quot;EPSG:900913&quot; || boundingCrs === &quot;EPSG:3857&quot;) ) { bounds = [minx, miny, maxx, maxy]; } else if (crs === &quot;EPSG:4326&quot; &amp;&amp; crs === boundingCrs) { bounds = [miny, minx, maxy, maxx]; } }); return bounds; } catch (error) { console.log(&quot;error&quot;, error); }}","link":"/2025/03/16/cesium%20%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E8%8E%B7%E5%8F%96wmts%E5%9B%BE%E5%B1%82%E7%9A%84bbox/"},{"title":"cesium 拾取错误开了贴地","text":"cesium 开了 clampGround 会出现拾取失误，点击这个面高亮，别的面会高亮 上边还有个模型 解决办法 123456789101112131415161718192021let editHandler = new SmartEarth.Cesium.ScreenSpaceEventHandler(Viewer.scene.canvas);let previosObj = null;editHandler.setInputAction(movement =&gt; { const pickedObjects = Viewer.scene.drillPick(movement.position); if (pickedObjects) { let pick = pickedObjects.pop(); while (!pick.id &amp;&amp; pickedObjects.length &gt; 0) { pick = pickedObjects.pop(); } if (previosObj) { previosObj.id.polygon.material = SmartEarth.Cesium.Color.fromAlpha( SmartEarth.Cesium.Color.BLUE, 0.5 ); } if (pick.id &amp;&amp; pick.id.polygon) { pick.id.polygon.material = new SmartEarth.Cesium.Color(1, 0, 0, 1); previosObj = pick; } }}, SmartEarth.Cesium.ScreenSpaceEventType.LEFT_CLICK);","link":"/2025/03/16/cesium%20%E6%8B%BE%E5%8F%96%E9%94%99%E8%AF%AF%E5%BC%80%E4%BA%86%E8%B4%B4%E5%9C%B0/"},{"title":"cesium 海流限制范围","text":"Cesium 洋流可视化区域限制技术在 Cesium 三维可视化开发中，洋流（海流）的可视化是海洋相关应用的重要组成部分。然而，有时我们需要将洋流的显示限制在特定的地理区域内，比如某个海域或湾区，而不是整个海洋。本文将介绍如何通过多边形边界结合点在多边形内的判断算法，实现 Cesium 中洋流的区域限制显示。 问题背景在海洋可视化场景中，我们通常会加载全球或区域的洋流数据，但实际应用中可能只关注特定区域的洋流情况。如果不做区域限制，会出现以下问题： 数据计算量大，影响性能 视觉上不够聚焦，难以凸显重点区域 洋流可能显示在陆地或不相关的水域上 因此，我们需要一种方法，将洋流的显示限制在指定的多边形区域内。 技术方案我们的解决方案基于以下核心思路： 定义一个多边形区域作为洋流显示的边界 使用点在多边形内的判断算法（射线算法） 在洋流粒子渲染前进行位置判断，仅渲染位于多边形内的粒子 这种方法既保证了视觉效果，又优化了性能。 核心算法：点在多边形内的判断判断一个点是否在多边形内是计算几何中的经典问题。我们采用的是射线算法（Ray Casting Algorithm），也称为奇偶规则（Even-Odd Rule）。该算法的思路是： 从判断点向任意固定方向（通常选择水平向右）引一条射线 计算这条射线与多边形边界的交点数量 如果交点数为奇数，则点在多边形内；如果为偶数，则点在多边形外 下面是这个算法的详细实现： 123456789101112131415161718192021222324252627function isPointInPolygon(point, polygon) { // 初始化结果为false（假设点在多边形外） let inside = false; // 获取待检测点的坐标 let x = point[0], y = point[1]; // 遍历多边形的所有边 // i是当前点，j是前一个点，这样就能形成一条边 for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) { // 获取多边形当前边的两个端点坐标 let xi = polygon[i][0], yi = polygon[i][1]; // 当前点 let xj = polygon[j][0], yj = polygon[j][1]; // 前一个点 // 这行是算法的核心，检查射线与边的相交情况 let intersect = yi &gt; y !== yj &gt; y &amp;&amp; // 第一个条件：确保边跨过射线 x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi; // 第二个条件：确保交点在点的右侧 // 每次找到一个有效交点，就翻转inside的值 if (intersect) inside = !inside; } return inside;} 算法原理解析这个算法看起来很简洁，但蕴含了精妙的几何原理： 射线法的核心思想：从点发出一条水平射线，统计它与多边形边界的交点数。奇数交点表示在内部，偶数交点表示在外部。 判断边是否跨过射线：yi &gt; y !== yj &gt; y 这个条件确保了当前边的一个端点在射线上方，另一个在射线下方，即这条边跨过了水平射线。 计算交点位置：x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi 这个表达式计算了边与射线的交点的 x 坐标，然后判断这个交点是否在原点的右侧。 奇偶切换：每找到一个交点，就翻转 inside 的状态，最终得到点的内外状态。 在 Cesium 中应用在 Cesium 中应用这个算法，我们需要解决两个问题： 如何获取屏幕坐标对应的地理坐标 如何结合洋流数据与多边形区域判断 获取地理坐标通过 Cesium 提供的 API，我们可以将屏幕坐标转换为地球表面的经纬度坐标： 12345678910// 从相机位置通过屏幕点发射射线，计算与地球表面的交点const cartesian = viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), viewer.scene.globe.ellipsoid);// 转换为经纬度坐标const cartographic = Cesium.Cartographic.fromCartesian(cartesian);const lon = Cesium.Math.toDegrees(cartographic.longitude);const lat = Cesium.Math.toDegrees(cartographic.latitude); 这段代码的作用是将屏幕上的 2D 坐标点(x, y)转换为地球表面上的 3D 坐标点，然后获取其经纬度值。 结合洋流数据与区域判断最关键的部分是将洋流数据与多边形区域判断结合起来： 1234567891011121314151617181920212223function fieldisDefined(x, y) { // 首先获取屏幕坐标对应的地理坐标 const cartesian = _oceanmap.viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), _oceanmap.viewer.scene.globe.ellipsoid ); if (!cartesian) return false; // 转换为经纬度坐标 const cartographic = Cesium.Cartographic.fromCartesian(cartesian); const lon = Cesium.Math.toDegrees(cartographic.longitude); const lat = Cesium.Math.toDegrees(cartographic.latitude); // 判断点是否在原有海洋区域内 const isInOcean = field(x, y)[2] !== null; // 判断点是否在指定的多边形区域内 const isInBoundary = isPointInPolygon([lon, lat], _oceanmap.bounds); // 同时满足两个条件：在海洋中且在边界内 return isInOcean &amp;&amp; isInBoundary;} 这个函数完成了两项重要检查： 确保点位于海洋中（通过洋流数据判断） 确保点位于我们指定的多边形区域内 只有同时满足这两个条件，我们才会在该位置渲染洋流粒子。 实施效果通过这种方法，我们可以将洋流的显示精确限制在我们感兴趣的区域内，如南海特定海域、台湾海峡或者某个港湾等。这不仅提升了视觉效果，还优化了性能，因为只有部分粒子需要计算和渲染。 完整代码实现下面是创建带区域限制的洋流场的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 创建洋流场并设置边界field = earthCtrl.factory.createOceanField({ name: &quot;ocean1&quot;, type: &quot;ocean&quot;, upath: &quot;./data/MIT.0000000001_UVEL_1.dat&quot;, vpath: &quot;./data/MIT.0000000001_VVEL_1.dat&quot;, bounds: [ [112.27127810594834, 19.225753080468763], [110.03847818240308, 17.427581061438815], [111.95290379190146, 12.594412699775589], [118.57050910216816, 13.584956070591218], [118.77371765142777, 19.065063097417365], [112.27127810594834, 19.225753080468763], ],});// 判断点是否在多边形内的函数function isPointInPolygon(point, polygon) { let inside = false; let x = point[0], y = point[1]; for (let i = 0, j = polygon.length - 1; i &lt; polygon.length; j = i++) { let xi = polygon[i][0], yi = polygon[i][1]; let xj = polygon[j][0], yj = polygon[j][1]; let intersect = yi &gt; y !== yj &gt; y &amp;&amp; x &lt; ((xj - xi) * (y - yi)) / (yj - yi) + xi; if (intersect) inside = !inside; } return inside;}// 判断点是否在洋流场定义区域内，并且在指定边界内function fieldisDefined(x, y) { // 首先获取屏幕坐标对应的地理坐标 const cartesian = _oceanmap.viewer.camera.pickEllipsoid( new Cesium.Cartesian2(x, y), _oceanmap.viewer.scene.globe.ellipsoid ); if (!cartesian) return false; // 转换为经纬度坐标 const cartographic = Cesium.Cartographic.fromCartesian(cartesian); const lon = Cesium.Math.toDegrees(cartographic.longitude); const lat = Cesium.Math.toDegrees(cartographic.latitude); // 判断点是否在原有海洋区域内 const isInOcean = field(x, y)[2] !== null; // 判断点是否在指定的多边形区域内 const isInBoundary = isPointInPolygon([lon, lat], _oceanmap.bounds); // 同时满足两个条件：在海洋中且在边界内 return isInOcean &amp;&amp; isInBoundary;} 总结通过结合点在多边形内的判断算法与 Cesium 的坐标转换功能，我们成功实现了洋流的区域限制显示。这种方法既保证了视觉效果的聚焦，又优化了性能。在实际应用中，可以根据需要调整多边形边界，灵活控制洋流的显示区域。","link":"/2025/03/16/cesium%20%E6%B5%B7%E6%B5%81%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4/"},{"title":"Cesium 根据目标点和距离飞行","text":"在 Cesium 三维可视化开发中，经常需要精确控制相机的位置和视角。本文将介绍如何根据目标点位置、相机与目标的距离、视角方向等参数，计算出相机的精确位置，并实现相机飞行定位的功能。 相机定位的核心问题在 Cesium 中，直接设置相机位置通常需要提供世界坐标系中的绝对位置。但在实际应用中，我们往往更关心： 相机需要看向哪个点（目标点） 相机距离目标点多远（距离） 相机应该从什么角度观察目标（方位角和俯仰角） 这就需要我们编写一个函数，将这些更直观的参数转换为 Cesium 相机所需的绝对位置。 解决方案原理我们的解决方案基于以下步骤： 以目标点为中心建立局部坐标系（东北上 ENU 坐标系） 在该坐标系中计算相机的相对位置 将相对位置转换回世界坐标系 这样就能准确定位相机，无论目标点在地球上的哪个位置。 核心函数解析下面是计算相机位置的核心函数： 12345678910111213141516171819function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量（初始位置在目标点正上方） var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;} 关键步骤说明 创建局部坐标系： 1var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); 这一步创建了一个转换矩阵，将局部坐标系（东、北、上）与全球坐标系关联起来。 设置初始偏移： 1var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); 初始偏移设置为(0,0,distance)，表示相机位于目标点正上方 distance 距离处。 计算旋转： 123var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0)); 这里创建一个旋转矩阵，注意参数的调整： -heading：负号是因为 Cesium 中 heading 的方向定义 pitch - Cesium.Math.PI_OVER_TWO：减去 90 度是因为我们的初始位置在正上方 应用旋转： 1Cesium.Matrix3.multiplyByVector(rotation, offset, offset); 将旋转应用到偏移向量上。 转换到全球坐标： 1Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); 将局部坐标系中的偏移量转换为全球坐标系中的位置。 使用示例了解了原理后，下面看看如何使用这个函数： 1234567891011121314151617181920// 目标点的位置（经度、纬度、高度）var targetPosition = Cesium.Cartesian3.fromDegrees(116.391, 39.904, 50);// 设置相机参数var distanceFromTarget = 1000; // 相机距离目标点1000米var heading = Cesium.Math.toRadians(45); // 方位角45度var pitch = Cesium.Math.toRadians(30); // 俯仰角30度// 计算相机位置var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch);// 设置相机视图viewer.camera.setView({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, },}); 这样设置后，相机会精确地位于目标点东北方向 1000 米处，并以 45 度方位角和 30 度俯仰角观察目标点。 应用场景这种相机定位方法在许多场景中非常有用： 关键位置展示：快速定位到建筑物、地标等关键点的最佳观察位置 动画路径设计：创建围绕目标点的相机飞行路径 自定义导航控制：实现更直观的导航控制，如”环绕目标点旋转”、”拉近/拉远”等 多视角切换：在不同角度之间平滑过渡，展示目标的不同方面 完整代码这里是完整的实现代码，包含了计算函数和使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 根据目标点、距离和视角计算相机位置 * @param {Cesium.Cartesian3} targetPosition 目标点的位置 * @param {Number} distanceFromTarget 相机到目标点的距离（米） * @param {Number} heading 方位角（弧度） * @param {Number} pitch 俯仰角（弧度） * @returns {Cesium.Cartesian3} 计算出的相机位置 */function calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch) { // 创建一个以目标点为中心的局部东北上(ENU)坐标系 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(targetPosition); // 计算相机的偏移量 var offset = new Cesium.Cartesian3(0, 0, distanceFromTarget); // 根据heading和pitch旋转偏移量 var rotation = Cesium.Matrix3.fromHeadingPitchRoll( new Cesium.HeadingPitchRoll(-heading, pitch - Cesium.Math.PI_OVER_TWO, 0) ); Cesium.Matrix3.multiplyByVector(rotation, offset, offset); // 将偏移量从局部坐标系转换到全球坐标系 var cameraPosition = new Cesium.Cartesian3(); Cesium.Matrix4.multiplyByPoint(transform, offset, cameraPosition); return cameraPosition;}// 使用示例function flyToPositionWithCamera() { // 目标点的位置（北京天安门） var targetPosition = Cesium.Cartesian3.fromDegrees(116.391, 39.904, 50); // 设置相机参数 var distanceFromTarget = 1000; // 相机距离目标点1000米 var heading = Cesium.Math.toRadians(45); // 方位角45度 var pitch = Cesium.Math.toRadians(30); // 俯仰角30度 // 计算相机位置 var cameraPosition = calculateCameraPosition(targetPosition, distanceFromTarget, heading, pitch); // 设置相机视图 viewer.camera.flyTo({ destination: cameraPosition, orientation: { heading: heading, pitch: pitch, roll: 0, }, duration: 2, // 飞行时间，单位秒 });}// 调用函数flyToPositionWithCamera(); 总结通过这种方法，我们可以更加直观地控制 Cesium 中的相机位置，无需直接处理复杂的世界坐标系。这对于创建精确的观察视角、设计相机动画路径等场景非常有用。 希望这篇文章对您在 Cesium 开发中控制相机有所帮助！","link":"/2025/03/16/cesium%20%E6%A0%B9%E6%8D%AE%E7%9B%B8%E6%9C%BA%E7%82%B9%E5%92%8C%E8%B7%9D%E7%A6%BB%E9%A3%9E%E5%90%91/"},{"title":"cesium 加载4490坐标系","text":"1.修改 ArcGisMapServerImageryProvider.js 源码 读取切片元数据时增加支持 wkid 4490 坐标系的判断，同时将切片信息也传 1234567if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, tileInfo: data.tileInfo, // 传入tileInfo，用于后面GeographicTilingScheme的计算 }); //SmartEarth 修改} fullExtent 范围增加 wkid 4490 坐标系判断 1234567891011if (data.fullExtent.spatialReference.wkid === 4490) { /** Geoworld Add **/ // SmartEarth 修改 that._rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); // SmartEarth 修改} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function metadataSuccess(data, imageryProviderBuilder) { const tileInfo = data.tileInfo; if (!defined(tileInfo)) { imageryProviderBuilder.useTiles = false; } else { imageryProviderBuilder.tileWidth = tileInfo.rows; imageryProviderBuilder.tileHeight = tileInfo.cols; if (tileInfo.spatialReference.wkid === 102100 || tileInfo.spatialReference.wkid === 102113) { imageryProviderBuilder.tilingScheme = new WebMercatorTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, }); } else if (data.tileInfo.spatialReference.wkid === 4326) { imageryProviderBuilder.tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, }); /** Geoworld **/ //SmartEarth 修改 } else if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: imageryProviderBuilder.ellipsoid, tileInfo: data.tileInfo, // 传入tileInfo，用于后面GeographicTilingScheme的计算 }); //SmartEarth 修改 } else { const message = `Tile spatial reference WKID ${data.tileInfo.spatialReference.wkid} is not supported.`; throw new RuntimeError(message); } imageryProviderBuilder.maximumLevel = data.tileInfo.lods.length - 1; if (defined(data.fullExtent)) { if ( defined(data.fullExtent.spatialReference) &amp;&amp; defined(data.fullExtent.spatialReference.wkid) ) { if ( data.fullExtent.spatialReference.wkid === 102100 || data.fullExtent.spatialReference.wkid === 102113 ) { const projection = new WebMercatorProjection(); const extent = data.fullExtent; const sw = projection.unproject( new Cartesian3( Math.max( extent.xmin, -imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), Math.max( extent.ymin, -imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), 0.0 ) ); const ne = projection.unproject( new Cartesian3( Math.min( extent.xmax, imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), Math.min( extent.ymax, imageryProviderBuilder.tilingScheme.ellipsoid.maximumRadius * Math.PI ), 0.0 ) ); imageryProviderBuilder.rectangle = new Rectangle( sw.longitude, sw.latitude, ne.longitude, ne.latitude ); } else if (data.fullExtent.spatialReference.wkid === 4326) { imageryProviderBuilder.rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); } else if (data.fullExtent.spatialReference.wkid === 4490) { /** Geoworld Add **/ // SmartEarth 修改 that._rectangle = Rectangle.fromDegrees( data.fullExtent.xmin, data.fullExtent.ymin, data.fullExtent.xmax, data.fullExtent.ymax ); // SmartEarth 修改 } else { const extentMessage = `fullExtent.spatialReference WKID ${data.fullExtent.spatialReference.wkid} is not supported.`; throw new RuntimeError(extentMessage); } } } else { imageryProviderBuilder.rectangle = imageryProviderBuilder.tilingScheme.rectangle; } imageryProviderBuilder.useTiles = true; } if (defined(data.copyrightText) &amp;&amp; data.copyrightText.length &gt; 0) { if (defined(imageryProviderBuilder.credit)) { imageryProviderBuilder.tileCredits = [new Credit(data.copyrightText)]; } else { imageryProviderBuilder.credit = new Credit(data.copyrightText); } }} 2.修改 GeographicTilingScheme 类 1234/** Geoworld Add **///SmartEarth 修改this._tileInfo = options.tileInfo;//SmartEarth 修改 修改切片矩阵计算获取行列号 xy 值的原型方法 getNumberOfXTilesAtLevel 和 getNumberOfYTilesAtLevel 1234567891011121314151617181920212223242526272829303132333435GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) { // return this._numberOfLevelZeroTilesX &lt;&lt; level; /** Geoworld Add **/ //SmartEarth 修改 if (!defined(this._tileInfo)) { return this._numberOfLevelZeroTilesX &lt;&lt; level; } const currentMatrix = this._tileInfo.lods.filter(function (item) { return item.level === level; }); const currentResolution = currentMatrix[0].resolution; return Math.round(360 / (this._tileInfo.rows * currentResolution)); //SmartEarth 修改};/** * Gets the total number of tiles in the Y direction at a specified level-of-detail. * * @param {number} level The level-of-detail. * @returns {number} The number of tiles in the Y direction at the given level. */GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) { // return this._numberOfLevelZeroTilesY &lt;&lt; level; //SmartEarth 修改 if (!defined(this._tileInfo)) { return this._numberOfLevelZeroTilesY &lt;&lt; level; } // 使用切片矩阵计算 const currentMatrix = this._tileInfo.lods.filter(function (item) { return item.level === level; }); const currentResolution = currentMatrix[0].resolution; return Math.round(180 / (this._tileInfo.cols * currentResolution)); //SmartEarth 修改}; 3.修改 Ellipsoid 类，定义 2000 椭球参数 1234567891011/** * An Ellipsoid instance initialized to the CGCS2000 standard. * * @type {Ellipsoid} * @constant *//** Geoworld Add **/Ellipsoid.CGCS2000 = Object.freeze( // eslint-disable-next-line no-loss-of-precision new Ellipsoid(6378137.0, 6378137.0, 6356752.31414035585)); 使用 123456789101112131415161718192021222324252627282930var cgs2000Ellipsolid = new Cesium.Ellipsoid(6378137.0, 6378137.0, 6356752.31414035585);var myGeographicTilingScheme = new Cesium.GeographicTilingScheme({ ellipsoid: cgs2000Ellipsolid, rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90), numberOfLevelZeroTilesX: 4, numberOfLevelZeroTilesY: 2,});var esriWMTS = new Cesium.ArcGisMapServerImageryProvider({ url: &quot;http://Ip:6080/arcgis/rest/services/jssl_vector_L3_L17/MapServer&quot;, layer: &quot;jssl_vector_L3_L17&quot;, tilingScheme: myGeographicTilingScheme, rectangle: myRectangle, minimumLevel: 0, ellipsoid: cgs2000Ellipsolid, maximumLevel: 14,});var cgs2000GeographicProj = new Cesium.GeographicProjection(cgs2000Ellipsolid);var viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;, { animation: false, geocoder: false, timeline: false, navigationHelpButton: false, baseLayerPicker: false, mapProjection: cgs2000GeographicProj, imageryProvider: esriWMTS,});viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(119.56156642831284, 32.419457329767326, 272683),});","link":"/2025/03/16/cesium%20%E5%8A%A0%E8%BD%BD4490%E5%9D%90%E6%A0%87%E7%B3%BB/"},{"title":"cesium 生成线框","text":"为了在你的自定义**CityPrimitive**中添加重心坐标，你需要修改你的几何体数据，为每个顶点增加这些坐标。重心坐标是一个在三角形顶点上为**[1, 0, 0]**，**[0, 1, 0]**，**[0, 0, 1]**，并在内部插值的属性。这样，三角形的每个边上的坐标都会接近零，并且可以在片段着色器中用来判断一个片段是否接近边缘。 首先，你需要为你的几何体的每个三角形的顶点生成这些坐标。在 Cesium 中，可以在你创建顶点属性的时候添加这些坐标。例如： 12345678910111213141516171819202122232425262728// 生成重心坐标属性function generateBarycentricCoordinates(geometry) { const numberOfVertices = Cesium.Geometry.computeNumberOfVertices(geometry); const barycentricCoordinates = new Float32Array(numberOfVertices * 3); for (let i = 0, len = numberOfVertices / 3; i &lt; len; ++i) { barycentricCoordinates[i * 9 + 0] = 1; // 第一个顶点 barycentricCoordinates[i * 9 + 1] = 0; barycentricCoordinates[i * 9 + 2] = 0; barycentricCoordinates[i * 9 + 3] = 0; // 第二个顶点 barycentricCoordinates[i * 9 + 4] = 1; barycentricCoordinates[i * 9 + 5] = 0; barycentricCoordinates[i * 9 + 6] = 0; // 第三个顶点 barycentricCoordinates[i * 9 + 7] = 0; barycentricCoordinates[i * 9 + 8] = 1; } return new Cesium.GeometryAttribute({ componentDatatype: Cesium.ComponentDatatype.FLOAT, componentsPerAttribute: 3, values: barycentricCoordinates, });}// 在你的几何体中添加重心坐标属性this.geometry.attributes.barycentric = generateBarycentricCoordinates(this.geometry); 接着，在你的createCommand函数中，你需要确保这个新属性被传递到着色器中，并且绑定到一个顶点着色器输入： 1234567javascriptCopy codeconst attributeLocations = { position: 0, normal: 1, st: 2, barycentric: 3 // 添加新的属性位置}; 然后，在你的顶点着色器中，你需要接收并传递这个属性到片段着色器： 1234567891011glslCopy code // 顶点着色器 // ... in vec3 barycentric;out vec3 v_barycentric;void main() { // ... v_barycentric = barycentric; // ...} 最后，在你的片段着色器中，你需要使用这个v_barycentric来确定是否绘制线框： 12345678910111213141516glslCopy code // 片段着色器 // ... in vec3 v_barycentric;void main() { // 根据重心坐标确定是否绘制线框 float lineWidth = 0.01; // 设置线宽 if (min(min(v_barycentric.x, v_barycentric.y), v_barycentric.z) &lt; lineWidth) { // 接近边缘，绘制线框 out_FragColor = vec4(0.0, 0.0, 0.0, 1.0); } else { // 在三角形内部，根据需要设置颜色 discard; // 或者适当设置颜色 }} 请记住，这些修改都需要适应你当前的代码和 Cesium 的使用方式。具体细节可能需要进一步调整以确保与你的应用程序兼容。 在 3D 图形学中，重心坐标（Barycentric coordinates）用于表示在三角形内部的点相对于三角形顶点的位置。一个点的重心坐标是三个数（通常记作�,�,�u,v,w），它们的和为 1，每个数对应于点在三角形一个顶点上的“权重”。在图形 API 中，重心坐标通常用于插值（如纹理坐标、颜色等）。 当给每个三角形的顶点赋予不同的重心坐标： 第一个顶点：(1,0,0)(1,0,0) 第二个顶点：(0,1,0)(0,1,0) 第三个顶点：(0,0,1)(0,0,1) 在三角形的边上，至少有一个重心坐标将接近 0（因为边上的点只有两个顶点的“权重”）。在三角形内部，每个重心坐标都将大于 0。 所以，当你看到这样的代码： 1234glslCopy code if (min(min(v_barycentric.x, v_barycentric.y), v_barycentric.z) &lt; lineWidth) { // ... } 这段代码的意思是：如果在三个重心坐标中有任何一个接近 0（小于lineWidth），那么当前片段（Pixel）就处于三角形的边上或接近边缘。在这种情况下，如果你想渲染线框，你会在这些接近边缘的片段上应用一种颜色（如黑色），从而绘制出线框的效果。 而关于您的第一个问题，确实，这是一个顶点对应一个重心坐标，这三个顶点的重心坐标（(1,0,0)(1,0,0), (0,1,0)(0,1,0), (0,0,1)(0,0,1)）被分配给了三角形的三个顶点，这样可以在三角形内部以及边缘上插值这些坐标。当你在顶点着色器中将这些坐标传递到片段着色器，然后在片段着色器中使用这些坐标来检测边缘，你就能实现线框渲染的效果。","link":"/2025/03/16/cesium%20%E7%94%9F%E6%88%90%E7%BA%BF%E6%A1%86/"},{"title":"cesium 根据相机点和距离飞向","text":"在 GIS 开发中，三维地理数据的可视化和交互是非常重要的功能。本文将介绍如何使用 SmartEarth SDK（基于 Cesium 的扩展库）来加载 3D Tiles 模型，并实现模型的属性查询和高亮选择功能。 本示例主要实现了以下功能： 加载多个 3D Tiles 模型 根据经纬度定位并创建标记点 查询并显示 3D Tiles 模型的属性信息 实现模型对象的高亮显示 这些功能在智慧城市、BIM 管理、城市规划等三维可视化应用中非常常见。下面我们来逐一介绍关键技术实现。 根据经纬度创建标记点，并添加到场景中： 12345678910111213141516const position = Cesium.Cartesian3.fromDegrees(lon1, lat1, 60);let cartographicPosition = Cesium.Cartographic.fromCartesian(position);const height = Viewer.scene.sampleHeight(cartographicPosition);// 创建标签const label = earthCtrl.factory.createLabel({ lon: lon1, lat: lat1, alt: height + 1, text: &quot;创建文本&quot;, image: &quot;https://cim.smartearth.cn/sdkdemo/master/src/static/image/mark.png&quot;, // 文本偏移量 pixelOffset: new SmartEarth.Cesium.Cartesian2(0, -50), // 图片偏移量 iPixelOffset: new SmartEarth.Cesium.Cartesian2(0, -20),}); 这段代码演示了如何创建一个带有图标和文本的标记点，sampleHeight方法用于获取该位置的地面高度，确保标记点正确放置。 4. 查询显示 3D Tiles 属性信息当点击模型时，我们需要获取并显示该位置模型的属性信息： 123456789101112131415// 高亮逻辑const winPosition = Viewer.scene.cartesianToCanvasCoordinates(position);const pickObject = Viewer.scene.pick(winPosition);// 获取所有属性const propertyIds = pickObject.getPropertyIds();let tooltipHTML = &quot;&quot;;for (let i = 0; i &lt; propertyIds.length; ++i) { const propertyId = propertyIds[i]; const value = pickObject.getProperty(propertyId); value &amp;&amp; (tooltipHTML += `${propertyId}:${value || &quot;无&quot;}&lt;br&gt;`);}// 显示提示框tooltip.showAts({ position: winPosition, text: tooltipHTML }); 这段代码通过pick函数获取鼠标位置下的 3D Tiles 对象，然后遍历其所有属性，生成 HTML 格式的提示内容。 5. 实现 3D Tiles 模型高亮实现点击模型后高亮显示选中的对象： 1234567891011121314151617181920212223242526// 把上一个高亮的tileset还原if (previousTileSet) { previousTileSet.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { return SmartEarth.Cesium.Color.WHITE; }, }, });}// 设置新的高亮样式const pickId = pickObject.getProperty(&quot;id&quot;);tileset.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { const featueId = feature.getProperty(&quot;id&quot;); if (pickId === featueId) { return SmartEarth.Cesium.Color.YELLOW; } else { return SmartEarth.Cesium.Color.WHITE; } }, },});previousTileSet = tileset; 这段代码使用Cesium3DTileStyle来设置模型的颜色样式。通过比较当前选中对象的 ID 和模型中每个 feature 的 ID，将匹配的对象设置为黄色高亮显示，其余部分保持白色。 6. 相机飞行定位最后，实现相机飞行到指定模型的功能： 12345const options = { duration: 2, offset: new SmartEarth.Cesium.HeadingPitchRange(1.0, -0.3, 1000),};earthCtrl.userScene.flyTo(tiltModel1.item, options); 这段代码使用flyTo方法使相机飞行到指定的模型位置，并设置了适当的视角和距离。 完整代码下面是完整的 HTML 和 JavaScript 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;初始化示例&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/CimSDK.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./CimSDK/Workers/layui/css/layui.css&quot; /&gt; &lt;style&gt; .funcBox { position: absolute; top: 30px; padding: 10px; width: 470px; background-color: rgba(0, 0, 0, 0.7); border-radius: 4px; left: 20px; color: #fff; } .layui-form-item { text-align: center; } .layui-form-label { width: unset !important; padding: 9px !important; } .layui-input-block { margin-left: 50px !important; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sdkContainer&quot;&gt;&lt;/div&gt; &lt;!--按钮--&gt; &lt;div class=&quot;funcBox layui-form&quot;&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;lon&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;lon&quot; placeholder=&quot;请输入经度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;lat&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;lat&quot; placeholder=&quot;请输入纬度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;alt&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input id=&quot;alt&quot; placeholder=&quot;请输入高度&quot; class=&quot;layui-input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;button id=&quot;btn1&quot; class=&quot;layui-btn&quot;&gt;定位&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./CimSDK/Workers/jquery-3.5.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./CimSDK/CimSDK.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot;&gt; window.earthCtrl = new SmartEarth.EarthCtrl(&quot;sdkContainer&quot;); window.Viewer = earthCtrl.viewer; const Cesium = SmartEarth.Cesium; //显示fps earthCtrl.showFPS = true; //预载入输入框值 const lon1 = 118.36378039081389; $(&quot;#lon&quot;).val(lon1); const lat1 = 31.378263226883764; $(&quot;#lat&quot;).val(lat1); const alt1 = 60; $(&quot;#alt&quot;).val(alt1); let model; let previoisEntity = null; let previousTileSet = null; let tooltip = earthCtrl.core.createTooltip(); tooltip.showFun(false); async function load() { const lon1 = $(&quot;#lon&quot;).val(); const lat1 = $(&quot;#lat&quot;).val(); const alt1 = $(&quot;#alt&quot;).val(); // 加标记点 const position = Cesium.Cartesian3.fromDegrees(lon1, lat1, 60); let cartographicPosition = Cesium.Cartographic.fromCartesian(position); const height = Viewer.scene.sampleHeight(cartographicPosition); // 移除上一个点 if (previoisEntity) { Viewer.entities.remove(previoisEntity); } const label = earthCtrl.factory.createLabel({ lon: lon1, lat: lat1, alt: height + 1, text: &quot;创建文本&quot;, image: &quot;https://cim.smartearth.cn/sdkdemo/master/src/static/image/mark.png&quot;, // 文本偏移量 pixelOffset: new SmartEarth.Cesium.Cartesian2(0, -50), // 图片偏移量 iPixelOffset: new SmartEarth.Cesium.Cartesian2(0, -20), }); previoisEntity = label._primitive; // 高亮逻辑 const winPosition = Viewer.scene.cartesianToCanvasCoordinates(position); const pickObject = Viewer.scene.pick(winPosition); const tileset = pickObject.content._tileset; // 把上一个高亮的tileset还原 if (previousTileSet) { previousTileSet.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { return SmartEarth.Cesium.Color.WHITE; }, }, }); } const pickId = pickObject.getProperty(&quot;id&quot;); const propertyIds = pickObject.getPropertyIds(); // 获取所有属性 // 弹窗显示所有属性 const length = propertyIds.length; let tooltipHTML = &quot;&quot;; for (let i = 0; i &lt; length; ++i) { const propertyId = propertyIds[i]; console.log(`${propertyId}: ${pickObject.getProperty(propertyId)}`); const value = pickObject.getProperty(propertyId); value &amp;&amp; (tooltipHTML += `${propertyId}:${value || &quot;无&quot;}&lt;br&gt;`); } tooltip.showAts({ position: winPosition, text: tooltipHTML }); // 高亮逻辑 tileset.style = new Cesium.Cesium3DTileStyle({ color: { evaluateColor: feature =&gt; { console.log(&quot;feature&quot;, feature.getPropertyIds()); const featueId = feature.getProperty(&quot;id&quot;); if (pickId === featueId) { return SmartEarth.Cesium.Color.YELLOW; } else { return SmartEarth.Cesium.Color.WHITE; } }, }, }); previousTileSet = tileset; } const url1 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d120240813104356/tileset.json&quot;; const tiltModel1 = await earthCtrl.factory.create3DTilesets({ url: url1, }); const url2 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d920240813104425/tileset.json&quot;; const tiltModel2 = await earthCtrl.factory.create3DTilesets({ url: url2, }); const url3 = &quot;http://106.120.22.26:9096/gisserver/c3dserver/c3d520240813104456/tileset.json&quot;; const tiltModel3 = await earthCtrl.factory.create3DTilesets({ url: url3, }); const options = { duration: 2, offset: new SmartEarth.Cesium.HeadingPitchRange(1.0, -0.3, 1000), }; earthCtrl.userScene.flyTo(tiltModel1.item, options); $(&quot;#btn1&quot;).on(&quot;click&quot;, () =&gt; { load(); }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2025/03/16/cesium%20%E8%BE%93%E5%85%A5%E7%BB%8F%E7%BA%AC%E5%BA%A6%E5%AE%9A%E4%BD%8D%E5%88%B03dtiles/"},{"title":"cesium实现限高分析","text":"Cesium ClassificationPrimitive Cesium 的 ClassificationPrimitive 是一个用于在三维场景中分类地表或其他几何体的工具。这种分类通常用于在现有的地表或模型上应用覆盖效果，比如标记特定区域、着色或其他视觉效果，用于突出显示某些特征或为特定应用添加信息层。 地表分类： ClassificationPrimitive 主要用于对地表进行分类处理，可以为地形或模型表面覆盖一层指定的材质或颜色，通常用于高亮、区分不同区域的用途。 与现有几何体的交互： 它能够与地形、3D Tiles 或其他几何图形结合使用，提供了一种方法来在这些图形上绘制或标记数据，而不修改原始数据。 高度自定义的视觉效果： 支持自定义的材质和着色方式，可以通过指定的Appearance对象来定义如何渲染覆盖层，包括但不限于使用 GLSL 着色器来创建复杂的视觉效果。 ClassificationPrimitive 可用于高亮显示特定区域，如城市规划区、受保护地区等 12345678910111213141516171819202122232425RestrictHeight.prototype.addToMap = function () { this.removeFromMap(); if (!this.positions) { return; } const positions = Cesium.Cartesian3.fromDegreesArray(this.positions); const polygonInstance = new Cesium.GeometryInstance({ geometry: new Cesium.PolygonGeometry({ polygonHierarchy: new Cesium.PolygonHierarchy(positions), height: this.baseHeight, extrudedHeight: this.baseHeight + this.extrudedHeight, }), attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor(this.color), }, }); this.limitHeightPrimitive = this._coreMap.scene.primitives.add( new Cesium.ClassificationPrimitive({ geometryInstances: polygonInstance, releaseGeometryInstances: false, classificationType: Cesium.ClassificationType.CESIUM_3D_TILE, }) );};","link":"/2025/03/16/cesium%E5%AE%9E%E7%8E%B0%E9%99%90%E9%AB%98%E5%88%86%E6%9E%90/"},{"title":"cesium加载10万点","text":"Cesium 优化：高效加载 10 万点位的实现方案 在 WebGIS 应用开发中，大量点位标记的高效渲染一直是一个挑战。特别是在 Cesium 这样的三维地图引擎中，当需要同时展示上万甚至十万级别的点位标记时，性能问题尤为突出。本文将分享一种在 Cesium 中高效加载和渲染 10 万级点位的实现方案，重点关注 BillboardCollection 的优化配置。 问题背景在实际业务中，我们经常需要在地图上展示大量的点位标记，例如： 全国范围内的监测站点数据 城市级别的物联网设备分布 人口热力图点位 轨迹点位数据 当这些点位数量达到万级甚至十万级时，常规的渲染方式会导致严重的性能问题： 页面加载缓慢，甚至浏览器崩溃 交互操作卡顿，FPS 大幅下降 内存占用过高 优化方案通过实验发现，Cesium 的 BillboardCollection 在创建时，如果传入scene参数，可以显著提升大量点位的渲染性能。这是因为传入 scene 参数后，BillboardCollection 会使用 WebGL 的实例化渲染(Instanced Arrays)技术，大幅减少渲染调用次数。 下面是一个加载 10 万点位的优化实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Cesium = SmartEarth.Cesium;window.earthCtrl = new SmartEarth.EarthCtrl(&quot;sdkContainer&quot;, {});window.viewer = window.earthCtrl.viewer;earthCtrl.showFPS = true;const ellipsoid = viewer.scene.globe.ellipsoid;let billboardCollection;let instancingEnabled = true;// const instancedArraysExtension = context._instancedArrays;let billboardCount = 100489;let scale = 1.0;// Define the area where billboards will be placedconst centerLongitude = -1.385205433269729;const centerLatitude = 0.6777926580888163;const rectangleHalfSize = 0.5;const e = new Cesium.Rectangle( centerLongitude - rectangleHalfSize, centerLatitude - rectangleHalfSize, centerLongitude + rectangleHalfSize, centerLatitude + rectangleHalfSize);resetBillboardCollection();function resetBillboardCollection() { if (Cesium.defined(billboardCollection)) { viewer.scene.primitives.remove(billboardCollection); } billboardCollection = viewer.scene.primitives.add( new Cesium.BillboardCollection({ scene: viewer.scene, }) ); const gridSize = Math.sqrt(billboardCount); for (let y = 0; y &lt; gridSize; ++y) { for (let x = 0; x &lt; gridSize; ++x) { const longitude = Cesium.Math.lerp(e.west, e.east, x / (gridSize - 1)); const latitude = Cesium.Math.lerp(e.south, e.north, y / (gridSize - 1)); const position = new Cesium.Cartographic(longitude, latitude, 10000.0); billboardCollection.add({ position: ellipsoid.cartographicToCartesian(position), image: &quot;./demo/image/water.svg&quot;, scale: scale, }); } }} 代码解析让我们详细分析一下代码的关键部分： 1. 核心优化点12345billboardCollection = viewer.scene.primitives.add( new Cesium.BillboardCollection({ scene: viewer.scene, })); 这里的关键优化是在创建 BillboardCollection 时传入scene参数。这看似简单的一步却有巨大的性能提升，主要原因是： 启用了 WebGL 的 Instanced Arrays 扩展功能 减少了 CPU 到 GPU 的数据传输次数 降低了 WebGL 的绘制调用(draw calls)次数 2. 点位生成策略12345678const gridSize = Math.sqrt(billboardCount);for (let y = 0; y &lt; gridSize; ++y) { for (let x = 0; x &lt; gridSize; ++x) { const longitude = Cesium.Math.lerp(e.west, e.east, x / (gridSize - 1)); const latitude = Cesium.Math.lerp(e.south, e.north, y / (gridSize - 1)); // ... }} 这段代码采用网格分布策略生成点位： 计算网格大小为点位总数的平方根（约 317×317 网格） 使用双重循环填充整个矩形区域 通过线性插值(Cesium.Math.lerp)均匀分布点位 3. 点位创建123456const position = new Cesium.Cartographic(longitude, latitude, 10000.0);billboardCollection.add({ position: ellipsoid.cartographicToCartesian(position), image: &quot;./demo/image/water.svg&quot;, scale: scale,}); 每个点位的创建过程： 创建经纬度高度的笛卡尔坐标 转换为地心坐标系(ECEF) 使用统一的 SVG 图标 应用统一的缩放比例 性能对比实验表明，添加scene参数前后的性能差异非常显著： 配置 点位数量 平均 FPS 加载时间 内存占用 不带 scene 参数 100,489 &lt;10 &gt;10 秒 高 带 scene 参数 100,489 &gt;30 &lt;3 秒 中等 通过截图可以看到，使用优化方案后，即使是在渲染 10 万级别的点位时，FPS 仍然能够维持在 30 以上，确保了良好的用户体验。 总结通过在 BillboardCollection 中正确配置scene参数，结合其他优化技巧，我们成功实现了在 Cesium 中高效渲染 10 万级点位的功能。这种方法大幅提升了渲染性能，降低了内存占用，使得大规模点位可视化成为可能。","link":"/2025/03/16/cesium%E5%8A%A0%E8%BD%BD10%E4%B8%87%E7%82%B9/"},{"title":"cesium修改CesiumTerrainProvider源码","text":"问题背景在实际开发中，我们经常遇到这样的需求：加载一个地形数据后，希望视图自动定位到该地形覆盖的区域，以便用户直观地看到完整的地形数据。默认情况下，Cesium 并不提供这样的功能，加载地形后视图不会自动调整，用户需要手动寻找地形所在位置。这个问题的关键在于： CesiumTerrainProvider 默认不接收地形边界（bounds）参数即使有了 bounds 信息，也缺少一个自动飞行到该区域的便捷方法不同坐标系（EPSG:4326 和 EPSG:3857）的 bounds 处理方式不同 解决方案我们的解决方案分为两个部分：从地形元数据中获取 bopunds修改 CesiumTerrainProvider 源码，使其支持传入地形的 bounds 参数实现一个 flyTo 方法，方便地形加载后自动飞行到指定区域 12345678910111213141516171819202122232425262728293031323334353637const bounds = data.bounds if (!data.projection || data.projection === &quot;EPSG:4326&quot;) { terrainProviderBuilder.tilingScheme = new GeographicTilingScheme({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1, ellipsoid: terrainProviderBuilder.ellipsoid, rectangle: bounds.length ? Rectangle.fromDegrees(...bounds) : Rectangle.MAX_VALUE }); } else if (data.projection === &quot;EPSG:3857&quot;) { const epsg3857Bounds = Math.PI * terrainProviderBuilder.ellipsoid.maximumRadius; if(bounds[0] &lt; -epsg3857Bounds) { bounds[0] = -epsg3857Bounds } if(bounds[1] &lt; -epsg3857Bounds) { bounds[1] = -epsg3857Bounds } if(bounds[2] &gt; epsg3857Bounds) { bounds[2] = epsg3857Bounds } if(bounds[3] &gt; epsg3857Bounds) { bounds[3] = epsg3857Bounds } terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme({ numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1, ellipsoid: terrainProviderBuilder.ellipsoid, rectangleSouthwestInMeters: new Cartesian2( bounds[0], bounds[1] ), rectangleNortheastInMeters: new Cartesian2( bounds[2], bounds[3] ) }); } 1234const layer = await Cesium.CesiumTerrainProvider.fromUrl( options.url, options); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 地形飞跃 * @method * @param {Object} options 构造参数 * @param {Object} options.orientation 飞行到达地形的视角角度 * @param {Number} options.orientation.heading 航向 * @param {Number} options.orientation.pitch 俯仰 * @param {Number} options.orientation.roll 滚动 * @param {Number} options.height 飞行到达地形的视角高度 （默认10000米） * @param {Number} options.duration 以秒为单位的飞行持续时间 * @param {Function} options.complete 飞行完成时执行的函数 */ flyTo(options = {}) { //const that = this; const option = options; option.orientation = Cesium.defaultValue(options.orientation, { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-60), roll: Cesium.Math.toRadians(0), }); function webMercatorToLatLng(x, y) { const earthRadius = 6378137; // 地球半径，单位：米 const originShift = Math.PI * earthRadius; // 地球周长 const lon = (x / originShift) * 180.0; const lat = (180.0 / Math.PI) * (2.0 * Math.atan(Math.exp((y / originShift) * Math.PI)) - Math.PI / 2.0); return { lon, lat }; } if ( this._parameter.sourceType === &quot;ctb&quot; || this._parameter.sourceType === &quot;arcgis&quot; ) { //'EPSG:4326' const rectangle = this._primitive._tilingScheme.rectangle; const westDegrees = Cesium.Math.toDegrees(rectangle.west); // const westDegrees2 = Cesium.Math.toDegrees(rectangle.east); // const westDegrees3 = Cesium.Math.toDegrees(rectangle.north); // const westDegrees4 = Cesium.Math.toDegrees(rectangle.south); // console.log( // &quot;westDegrees&quot;, // westDegrees, // westDegrees2, // westDegrees3, // westDegrees4 // ); if (westDegrees &lt;= 180 &amp;&amp; westDegrees &gt;= -180) { const lon = Cesium.Math.toDegrees( (rectangle.west + rectangle.east) / 2 ); const lat = Cesium.Math.toDegrees( (rectangle.south + rectangle.north) / 2 ); const height = options.height || 10000; option.destination = Cesium.defaultValue( options.destination, Cesium.Cartesian3.fromDegrees(lon, lat, height) ); } else { const min = webMercatorToLatLng(rectangle.west, rectangle.south); const max = webMercatorToLatLng(rectangle.east, rectangle.north); const lon = (min.lon + max.lon) / 2; const lat = (min.lat + max.lat) / 2; const height = options.height || 10000; option.destination = Cesium.defaultValue( options.destination, Cesium.Cartesian3.fromDegrees(lon, lat, height) ); } this._coreMap.camera.flyTo(option); } }}","link":"/2025/03/16/cesium%E4%BF%AE%E6%94%B9CesiumTerrainProvider%E6%BA%90%E7%A0%81/"},{"title":"cesium控制时间轴显示与隐藏","text":"在 Cesium 三维地球应用中，时间轴（Timeline）是一个强大的组件，它允许用户在时间维度上浏览和控制数据。然而，在某些场景下，我们可能希望根据应用需求动态控制时间轴的显示或隐藏。本文将详细介绍如何实现这一功能，并提供完整的代码示例和最佳实践。根据按钮的选中状态，设置时间轴容器的 CSS display 属性当按钮选中时，设置为 block，使时间轴显示当按钮未选中时，设置为 none，使时间轴隐藏注意需要修改 DOM 后可能不生效 需要强制触发 Cesium 时间轴的布局更新Viewer.timeline.resize()使用 setTimeout 异步调用 resize()方法，强制时间轴重新计算自身布局 12345678910timeLine(btn) { btn.checked = !btn.checked; Viewer.timeline.container.style.display = btn.checked ? &quot;block&quot; : &quot;none&quot;; if (btn.checked) { Viewer.timeline.container.style.bottom = &quot;40px&quot;; setTimeout(() =&gt; { Viewer.timeline.resize(); // 强制触发 Cesium 时间轴的布局更新 }, 0); } },","link":"/2025/03/16/cesium%E6%8E%A7%E5%88%B6%E6%97%B6%E9%97%B4%E8%BD%B4%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"title":"cesium点聚合点击扩散点位","text":"Cesium 实现点聚合点击扩散效果 在 Cesium 三维地图应用中，当需要展示大量点位数据时，点聚合(Point Clustering)是一种常用的可视化优化技术。然而，聚合后的点位如何高效地展示和交互，成为了一个关键问题。本文将介绍一种简洁而实用的解决方案：点击聚合点后，相机自动飞行并放大到合适的高度，实现聚合点的”扩散”效果，让用户可以清晰查看聚合点包含的所有单独点位。 问题背景在处理大规模点位数据时，点聚合技术可以有效减少渲染压力，提升应用性能。但这带来了新的交互挑战： 用户如何查看被聚合的详细点位？ 如何设计直观的交互方式展开聚合点？ 扩散后，如何让用户清晰地了解空间位置关系？ 传统的解决方案往往是点击后弹出列表，或者简单地取消聚合显示所有点位，这些方法要么缺乏空间关联性，要么容易产生视觉混乱。 解决方案我们设计了一种基于相机飞行的扩散效果：当用户点击聚合点时，应用会计算聚合点内所有点位的中心位置，然后控制相机飞行到该位置上方的适当高度，使得聚合点自然”扩散”为单独的点位。 这种方案的优势在于： 保持了空间上下文，用户不会迷失方向 交互方式直观，符合用户心智模型 视觉效果流畅，提供良好的用户体验 实现代码1. 点击事件处理首先，我们需要处理地图点击事件，判断用户是否点击了聚合点： 1234567891011// 点击聚合点扩散功能earthCtrl.pick((data, pickObject, movement) =&gt; { if (!pickObject) { return; } if (Array.isArray(pickObject.id) &amp;&amp; pickObject.id.length &gt; 1) { const clusteredEntities = pickObject.id; // 聚合点的所有实体 const rate = 4; // 缩放倍数 clusterLayer.expandCluster(clusteredEntities, rate); }}); 这段代码的关键点： 通过pick事件捕获用户点击 判断点击对象的 id 是否为数组且长度大于 1，这是 Cesium 中聚合点的典型特征 获取聚合点包含的所有实体，传递给扩散函数 设置缩放倍数，决定相机放大的程度 2. 扩散功能实现接下来，实现扩散函数，计算聚合点中心并控制相机飞行： 1234567891011121314151617181920212223/* * 点击扩散聚合点 * @param {*} clusteredEntities * @param {*} rate */ClusterLayer.prototype.expandCluster = function (clusteredEntities, rate = 4) { let totalLon = 0; let totalLat = 0; clusteredEntities.forEach(entity =&gt; { const position = entity.position.getValue(Cesium.JulianDate.now()); const cartographic = Cesium.Cartographic.fromCartesian(position); totalLon += Cesium.Math.toDegrees(cartographic.longitude); totalLat += Cesium.Math.toDegrees(cartographic.latitude); }); const centerLon = totalLon / clusteredEntities.length; const centerLat = totalLat / clusteredEntities.length; const currentHeight = this._viewer.camera.positionCartographic.height; const targetHeight = currentHeight / rate; this._viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, targetHeight), duration: 1.5, });}; 这段代码的实现细节： 遍历所有聚合实体，获取每个点的位置 计算所有点的经纬度平均值，作为聚合点的中心 获取当前相机高度，并根据缩放倍数计算目标高度 使用flyTo方法控制相机飞行到新位置，实现平滑的过渡效果 代码解析中心点计算逻辑聚合点中心的计算使用了简单的平均值： 12345678clusteredEntities.forEach(entity =&gt; { const position = entity.position.getValue(Cesium.JulianDate.now()); const cartographic = Cesium.Cartographic.fromCartesian(position); totalLon += Cesium.Math.toDegrees(cartographic.longitude); totalLat += Cesium.Math.toDegrees(cartographic.latitude);});const centerLon = totalLon / clusteredEntities.length;const centerLat = totalLat / clusteredEntities.length; 这里的关键操作： 使用position.getValue()获取当前时间点的位置值 将 Cartesian3 坐标转换为经纬度表示 累加所有点的经纬度值，最后求平均值 相机高度计算相机高度的计算基于当前视图高度和缩放比例： 12const currentHeight = this._viewer.camera.positionCartographic.height;const targetHeight = currentHeight / rate; 这种方式确保了缩放效果与当前视图状态相适应： 当用户在高空视图点击聚合点时，扩散后会显示中等范围 当用户在低空视图点击聚合点时，扩散后会显示更详细的局部区域 相机飞行控制最后，使用 Cesium 的飞行功能实现平滑过渡： 1234this._viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, targetHeight), duration: 1.5,}); destination参数指定目标位置，使用之前计算的中心点和高度 duration参数控制飞行动画的持续时间，1.5 秒提供了良好的平衡，既不会太慢导致用户等待，也不会太快导致视觉不连贯 总结点聚合点击扩散功能是一种简单而强大的交互设计，它既保留了点聚合带来的性能优势，又解决了聚合点信息查看的交互问题。通过控制相机的智能飞行，我们实现了自然流畅的扩散效果，让用户可以轻松地在不同层级之间进行探索。 这种实现方式代码量少，易于集成，同时可以根据实际需求进行各种优化和扩展。在处理大规模点位数据的 Cesium 应用中，这将成为一个非常实用的交互功能。","link":"/2025/03/16/cesium%E7%82%B9%E8%81%9A%E5%90%88%E7%82%B9%E5%87%BB%E6%89%A9%E6%95%A3%E7%82%B9%E4%BD%8D/"},{"title":"cesium烟雾粒子设置风速和风向","text":"Cesium 实现烟雾粒子效果及风向风速控制 在三维 GIS 应用中，烟雾效果是一种常见的环境特效，可用于模拟工厂排放、火灾现场、火山活动等场景。通过 Cesium 的粒子系统(ParticleSystem)，我们可以实现逼真的烟雾效果，并且通过添加风速和风向参数来控制烟雾的飘动方向，使其更符合实际场景。本文将详细介绍如何在 Cesium 中实现一个可控制风速和风向的烟雾粒子效果。通过本文介绍的方法，我们可以实现以下效果： 在地图上指定位置创建烟雾粒子 控制烟雾的大小、颜色、密度等参数 设置风速和风向，使烟雾按照指定方向飘动 实时调整烟雾的各项参数 基本原理Cesium 的粒子系统(ParticleSystem)提供了强大的粒子效果生成能力，它通过控制粒子的生命周期、大小、颜色、运动轨迹等参数来模拟各种特效。我们可以使用它的以下特性来实现烟雾效果： 发射器(Emitter): 用锥形发射器模拟烟囱排放 粒子生命周期: 控制粒子从生成到消失的过程 颜色渐变: 从深色到浅色模拟烟雾扩散 大小变化: 粒子从小到大模拟烟雾扩散 速度控制: 设置粒子的初始速度和变化 更新回调: 通过 updateCallback 添加风向和风速影响 使用方法12345678earthCtrl.factory.createSmoke({ lon: 117.15552507924421, lat: 31.833227044869062, alt: 0, heading: 3.7577140651352736, windSpeed: 0.1, windDirection: 0, // 传的是角度，0是正北， 90是从东向西， 180是正南，270是从西向东}); 参数说明： lon、lat、alt: 烟雾在地球上的位置（经度、纬度、高度） heading: 烟雾发射方向的偏航角，单位为弧度 windSpeed: 风速，影响烟雾飘动的速度 windDirection: 风向，单位为角度，0 表示北风（从北向南吹），90 表示东风（从东向西吹），依此类推 实现原理详解1. 风向与风速的计算风向风速的核心是将角度和速度值转换为三维空间中的矢量： 12345678const windSpeed = this._windSpeed;const windDirection = (this._windDirection - Cesium.Math.toDegrees(this._heading)) % 360;const windDirectionRadians = Cesium.Math.toRadians(windDirection);const windVector = new Cesium.Cartesian3( Math.cos(windDirectionRadians) * windSpeed, Math.sin(windDirectionRadians) * windSpeed, 0); 这里需要注意几点： 风向角度需要考虑烟雾本身的 heading 角度，所以要进行减法运算 角度需要转换为弧度以便进行三角函数计算 最终得到的是一个三维向量，表示风的方向和大小 2. 粒子更新回调的应用风的效果是通过粒子系统的 updateCallback 回调函数实现的： 123updateCallback: (particle, dt) =&gt; { particle.velocity = Cesium.Cartesian3.add(particle.velocity, windVector, new Cesium.Cartesian3());}; 在每一帧更新时，将风向矢量添加到粒子的速度向量上，使粒子的运动轨迹受到风的影响。 3. 发射器位置与朝向烟雾的发射器采用锥形(ConeEmitter)，并且需要设置一个合适的位置和朝向： 12345678function computeEmitterModelMatrix() { const hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0); const trs = new Cesium.TranslationRotationScale(); trs.translation = Cesium.Cartesian3.fromElements(2.5, 4, 1); trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr); const result = Cesium.Matrix4.fromTranslationRotationScale(trs); return result;} 参数调优要实现更真实的烟雾效果，需要调整以下关键参数： 1. 颜色参数12startColor: Cesium.Color.fromRgba(0xcc333333), // 粒子出生时的颜色endColor: Cesium.Color.fromRgba(0x44cccccc), // 当粒子死亡时的颜色 烟雾初始颜色通常较深，透明度较高 结束颜色较淡，透明度降低，模拟烟雾扩散 2. 大小参数12startScale: 1.0, // 粒子出生时的比例endScale: 4.0, // 粒子在死亡时的比例 从小到大的变化模拟烟雾扩散过程 合适的比例可以创造更自然的效果 3. 生命周期参数12minimumParticleLife: 1.0, // 粒子寿命的最小值(秒)maximumParticleLife: 6.0, // 粒子寿命的最大值(秒) 较长的生命周期可以让烟雾飘得更远 最小最大值的差距可以创造不均匀的效果 4. 速度参数12minimumSpeed: 5.0, // 粒子的最小速度(米/秒)maximumSpeed: 20.0, // 粒子的最大速度(米/秒) 速度会影响烟雾上升和扩散的速率 风速会在此基础上叠加影响 完整代码实现以下是烟雾效果的完整实现代码，包括风向风速控制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256/** * @alias Smoke * @classdesc 烟雾效果类 * @desc Effect */class Smoke extends SpatialObject { /** * 构造方法 * @param {EarthCtrl} earthCtrl 地图控件 * @param {Object} options 创建参数 * @param {String} [options.id] 对象的唯一id * @param {String} [options.name] 对象的名字 * @param {Number} [options.lon] 对象的经度 * @param {Number} [options.lat] 对象的纬度 * @param {Number} [options.alt] 对象的高程 * @param {Number} [options.particleSize] 粒子的大小，默认是30 * @param {Number} [options.heading] 地图中设置的偏航角，弧度，默认是0 * @param {Number} [options.windSpeed] 风速，默认是0 * @param {Number} [options.windDirection] 风向，默认是0 * @see ObjectFactory#createSmoke */ constructor(earthCtrl, options) { super(earthCtrl, options); this._rtti = &quot;Smoke&quot;; this._primitive = null; this._parameter = options; this._spatialTransform.createFromWgs84( options.lon, options.lat, options.alt, options.heading, options.pitch, options.roll ); this._coreMap = earthCtrl.coreMap; this._windSpeed = options.windSpeed || 0; this._windDirection = options.windDirection || 0; this._heading = options.heading || 0; } addToMap() { const parameter = this._parameter; const coreMap = this._coreMap; function computeEmitterModelMatrix() { const hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0); const trs = new Cesium.TranslationRotationScale(); trs.translation = Cesium.Cartesian3.fromElements(2.5, 4, 1); trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr); const result = Cesium.Matrix4.fromTranslationRotationScale(trs); return result; } const windSpeed = this._windSpeed; const windDirection = (this._windDirection - Cesium.Math.toDegrees(this._heading)) % 360; const windDirectionRadians = Cesium.Math.toRadians(windDirection); const windVector = new Cesium.Cartesian3( Math.cos(windDirectionRadians) * windSpeed, Math.sin(windDirectionRadians) * windSpeed, 0 ); console.log(`Wind Direction: ${windDirection} degrees`); console.log(`Wind Vector: ${windVector.x}, ${windVector.y}, ${windVector.z}`); const particleSize = Cesium.defaultValue(parameter.particleSize, 30.0); const primitive = coreMap.scene.primitives.add( new Cesium.ParticleSystem({ //image: Cesium.defaultValue(parameter.image, &quot;./Assets/image/smoke.png&quot;), image: Cesium.defaultValue( parameter.image, `${globalThis.GEOWORLD_BASE_URL}Assets/Images/smoke.png` ), startColor: Cesium.defaultValue(parameter.startColor, Cesium.Color.fromRgba(0xcc333333)), //粒子出生时的颜色 endColor: Cesium.defaultValue(parameter.endColor, Cesium.Color.fromRgba(0x44cccccc)), //当粒子死亡时的颜色 startScale: Cesium.defaultValue(parameter.startScale, 1.0), //粒子出生时的比例，相对于原始大小 endScale: Cesium.defaultValue(parameter.endScale, 4.0), //粒子在死亡时的比例 minimumParticleLife: Cesium.defaultValue(parameter.minimumParticleLife, 1.0), //设置粒子寿命的可能持续时间的最小界限（以秒为单位），粒子的实际寿命将随机生成 maximumParticleLife: Cesium.defaultValue(parameter.maximumParticleLife, 6.0), //设置粒子寿命的可能持续时间的最大界限（以秒为单位），粒子的实际寿命将随机生成 minimumSpeed: Cesium.defaultValue(parameter.minimumSpeed, 5.0), //设置以米/秒为单位的最小界限，超过该最小界限，随机选择粒子的实际速度。 maximumSpeed: Cesium.defaultValue(parameter.maximumSpeed, 20.0), //设置以米/秒为单位的最大界限，超过该最大界限，随机选择粒子的实际速度。 imageSize: new Cesium.Cartesian2(particleSize, particleSize), //如果设置该属性，将会覆盖 minimumImageSize和maximumImageSize属性，以像素为单位缩放image的大小 emissionRate: Cesium.defaultValue(parameter.emissionRate, 10.0), //每秒发射的粒子数。 bursts: [], lifetime: Cesium.defaultValue(parameter.lifeTime, 16.0), //多长时间的粒子系统将以秒为单位发射粒子 emitter: new Cesium.ConeEmitter(Cesium.Math.toRadians(30.0)), //此系统的粒子发射器 共有 圆形、锥体、球体、长方体 ( BoxEmitter,CircleEmitter,ConeEmitter,SphereEmitter ) 几类 modelMatrix: this._spatialTransform.modelMatrix, // 4x4转换矩阵，可将粒子系统从模型转换为世界坐标 emitterModelMatrix: computeEmitterModelMatrix(), // 4x4转换矩阵，用于在粒子系统本地坐标系中转换粒子系统发射器 updateCallback: (particle, dt) =&gt; { particle.velocity = Cesium.Cartesian3.add( particle.velocity, windVector, new Cesium.Cartesian3() ); }, }) ); this._primitive = primitive; } /** * 从地图中移除 * @method * */ removeFromMap() { if (this._primitive !== null) { this._coreMap.scene.primitives.remove(this._primitive); } } toJSON() { const that = this; return ExportObject.export(that); }}Object.defineProperties(Smoke.prototype, { /** * 烟雾的参数 * @type Object * @memberof Smoke.prototype * @readonly */ parameter: { get: function () { return this._parameter; }, }, /** * 是否显示 * @type Boolean * @memberof Smoke.prototype * */ show: { get: function () { if (this._primitive !== null) { return this._primitive.show; } return false; }, set: function (val) { if (this._primitive !== null) { this._primitive.show = val; } }, }, /** * 名称 * @type String * @memberof Smoke.prototype * */ name: { get: function () { if (this._parameter !== null) { return this._parameter.name; } return false; }, set: function (val) { if (this._parameter !== null) { this._parameter.name = val; } }, }, /** * 经度 * @type Number * @memberof Smoke.prototype * */ lon: { get: function () { if (this._parameter !== null) { return this._lon; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._lon === val) { return; } this._parameter.lon = val; this._spatialTransform.createFromWgs84( this._parameter.lon, this._parameter.lat, this._parameter.alt, this._parameter.heading, this._parameter.pitch, this._parameter.roll ); this._primitive.modelMatrix = this._spatialTransform.modelMatrix; } }, }, /** * 纬度 * @type Number * @memberof Smoke.prototype * */ lat: { get: function () { if (this._parameter !== null) { return this._lat; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._lat === val) { return; } this._parameter.lat = val; this._spatialTransform.createFromWgs84( this._parameter.lon, this._parameter.lat, this._parameter.alt, this._parameter.heading, this._parameter.pitch, this._parameter.roll ); this._primitive.modelMatrix = this._spatialTransform.modelMatrix; } }, }, /** * * 粒子大小 * @type Number * @memberof Smoke.prototype * */ particleSize: { get: function () { if (this._primitive !== null) { return this._primitive.particleSize; } return undefined; }, set: function (val) { if (this._parameter !== null) { if (this._parameter.particleSize === val) { return; } this._parameter.particleSize = val; this._primitive.imageSize = new Cesium.Cartesian2( this._parameter.particleSize, this._parameter.particleSize ); } }, },});export default Smoke; 总结通过 Cesium 的粒子系统，结合风向和风速的控制，我们实现了一个真实而灵活的烟雾效果。该效果不仅可以模拟静态烟雾，还可以根据风的参数动态调整烟雾的飘动方向和速度，适用于各种需要烟雾效果的场景。 关键技术点回顾： 使用 Cesium.ParticleSystem 创建基础粒子系统 通过风向角度和风速值计算风向矢量 在 updateCallback 中将风向矢量添加到粒子速度中 通过参数控制烟雾的颜色、大小、生命周期等特性","link":"/2025/03/16/cesium%E7%83%9F%E9%9B%BE%E7%B2%92%E5%AD%90%E8%AE%BE%E7%BD%AE%E9%A3%8E%E9%80%9F%E5%92%8C%E9%A3%8E%E5%90%91/"}],"tags":[{"name":"cesium","slug":"cesium","link":"/tags/cesium/"}],"categories":[{"name":"cesium","slug":"cesium","link":"/categories/cesium/"}],"pages":[]}